From 5f603ede7f5052124f696e7830a7dca9a5aeffc0 Mon Sep 17 00:00:00 2001
From: keklick1337 <86933883+keklick1337@users.noreply.github.com>
Date: Thu, 5 Dec 2024 15:28:50 +0400
Subject: [PATCH] abc 7z-extended command-line options
Add -fp option

Use passwords list to open archive (new feature)
You can use -fp argument with selection passwords list ./7zz x test.7z -fppasswords.txt 7zz will try all passwords from list to open archive.

Unpack files with mask in filename (new feature)
We must add characters "$?" to the end of a mask's pattern which means that searching starts from the tail of a file's full path

for *NIX
./7zz x test.7z -i'!*/*ense*.txt$?' -i'!*/*ip*.hhp$?' -i'!*.mak$?' -ssc-

for WINDOWS
7zz.exe x test.7z -i!*/*ense*.txt$? -i!*/*ip*.hhp$? -i!*.mak$? -ssc-

An example below also extracts necessary files from test.7z archive by original 7zz application. Though some folders containing matching words are extracted as well.

7zz.exe x test.7z -i!*\*example*.txt -i!*\*test*.txt -i!*.rar -i!*.zip -i!*.7z -r

---
 CPP/7zip/Archive/7z/7zDecode.cpp              |   2 +
 CPP/7zip/Archive/7z/7zExtract.cpp             |   5 +-
 CPP/7zip/Archive/7z/7zHandler.cpp             |   6 +-
 CPP/7zip/Archive/7z/7zIn.cpp                  |  96 +-
 CPP/7zip/Archive/7z/7zIn.h                    |   8 +-
 CPP/7zip/Archive/7z/7zUpdate.cpp              |  26 +
 CPP/7zip/Archive/Rar/Rar5Handler.cpp          |  79 +-
 CPP/7zip/Archive/Rar/RarHandler.cpp           | 819 ++++++++++--------
 CPP/7zip/Archive/Zip/ZipHandler.cpp           | 310 +++++--
 CPP/7zip/IPassword.h                          |   7 +
 CPP/7zip/UI/Common/ArchiveCommandLine.cpp     |   9 +-
 CPP/7zip/UI/Common/ArchiveCommandLine.h       |   4 +-
 CPP/7zip/UI/Common/ArchiveExtractCallback.cpp |  25 +
 CPP/7zip/UI/Common/ArchiveExtractCallback.h   |   4 +
 CPP/7zip/UI/Common/ArchiveOpenCallback.cpp    |  37 +
 CPP/7zip/UI/Common/ArchiveOpenCallback.h      |  11 +-
 CPP/7zip/UI/Common/UpdateCallback.h           |  25 +-
 .../UI/Console/ExtractCallbackConsole.cpp     |  18 +
 CPP/7zip/UI/Console/ExtractCallbackConsole.h  |   3 +
 CPP/7zip/UI/Console/Main.cpp                  |  87 +-
 CPP/7zip/UI/Console/MainAr.cpp                |   2 +-
 CPP/7zip/UI/Console/OpenCallbackConsole.cpp   |  36 +
 CPP/7zip/UI/Console/OpenCallbackConsole.h     | 142 ++-
 CPP/7zip/UI/Console/UpdateCallbackConsole.cpp |  43 +
 README.md                                     |  16 +-
 25 files changed, 1326 insertions(+), 494 deletions(-)

diff --git a/CPP/Common/Wildcard.cpp b/CPP/Common/Wildcard.cpp
index b561a89..b198dfd 100644
--- a/CPP/Common/Wildcard.cpp
+++ b/CPP/Common/Wildcard.cpp
@@ -610,8 +610,17 @@ void CCensor::AddItem(ECensorPathMode pathMode, bool include, const UString &pat
   if (path.IsEmpty())
     throw "Empty file path";
 
+// by abc321
+  UString path2 = path;
+  bool Reverse = false;
+  if (path.Len() > 1 && (UString)(path.RightPtr(2)) == L"$?") {
+      Reverse = true;
+      path2 = path.Left(path.Len() - 2);
+  }
+// by abc321
+
   UStringVector pathParts;
-  SplitPathToParts(path, pathParts);
+  SplitPathToParts(path2, pathParts); // by abc321 - path variable changed to path2
 
   CCensorPathProps props2 = props;
 
@@ -726,12 +735,21 @@ void CCensor::AddItem(ECensorPathMode pathMode, bool include, const UString &pat
     // return; // for debug : ignore item (don't create Item)
   }
   */
+  
+  // by abc321
+  if (Reverse) {
+      forFile = true;
+      forDir = true;
+      props2.Recursive = false;
+  }
+  // by abc321
 
   CItem item;
   item.PathParts = pathParts;
   item.ForDir = forDir;
   item.ForFile = forFile;
   item.Recursive = props2.Recursive;
+  item.Reverse = Reverse; // by abc321
   item.WildcardMatching = props2.WildcardMatching;
   Pairs[(unsigned)index].Head.AddItem(include, item, ignoreWildcardIndex);
 }
diff --git a/CPP/Common/Wildcard.h b/CPP/Common/Wildcard.h
index 4f81da9..b7f2981 100644
--- a/CPP/Common/Wildcard.h
+++ b/CPP/Common/Wildcard.h
@@ -36,6 +36,7 @@ struct CItem
   bool Recursive;
   bool ForFile;
   bool ForDir;
+  bool Reverse; // by abc321
   bool WildcardMatching;
   
   #ifdef _WIN32
diff --git a/CPP/7zip/Archive/7z/7zDecode.cpp b/CPP/7zip/Archive/7z/7zDecode.cpp
index f863df9..359627b 100644
--- a/CPP/7zip/Archive/7z/7zDecode.cpp
+++ b/CPP/7zip/Archive/7z/7zDecode.cpp
@@ -431,6 +431,8 @@ HRESULT CDecoder::Decode(
         isEncrypted = true;
         if (!getTextPassword)
           return E_NOTIMPL;
+        if (!getNextPassword) // by abc321
+          return E_NOTIMPL; // by abc321
         CMyComBSTR_Wipe passwordBSTR;
         RINOK(getTextPassword->CryptoGetTextPassword(&passwordBSTR))
         passwordIsDefined = true;
diff --git a/CPP/7zip/Archive/7z/7zExtract.cpp b/CPP/7zip/Archive/7z/7zExtract.cpp
index cc4a573..0082be8 100644
--- a/CPP/7zip/Archive/7z/7zExtract.cpp
+++ b/CPP/7zip/Archive/7z/7zExtract.cpp
@@ -362,9 +362,12 @@ Z7_COM7F_IMF(CHandler::Extract(const UInt32 *indices, UInt32 numItems,
 
     #ifndef Z7_NO_CRYPTO
     CMyComPtr<ICryptoGetTextPassword> getTextPassword;
+    CMyComPtr<ICryptoGetNextPassword> getNextPassword; // by abc321
     if (extractCallback)
       extractCallback.QueryInterface(IID_ICryptoGetTextPassword, &getTextPassword);
-    #endif
+    if (extractCallback) // by abc321
+      extractCallback.QueryInterface(IID_ICryptoGetNextPassword, &getNextPassword); // by abc321
+#endif
 
     try
     {
diff --git a/CPP/7zip/Archive/7z/7zHandler.cpp b/CPP/7zip/Archive/7z/7zHandler.cpp
index 0fd46b8..c4b39a3 100644
--- a/CPP/7zip/Archive/7z/7zHandler.cpp
+++ b/CPP/7zip/Archive/7z/7zHandler.cpp
@@ -690,8 +690,11 @@ Z7_COM7F_IMF(CHandler::Open(IInStream *stream,
 
     #ifndef Z7_NO_CRYPTO
     CMyComPtr<ICryptoGetTextPassword> getTextPassword;
+    CMyComPtr<ICryptoGetNextPassword> getNextPassword; // by abc321
     if (openArchiveCallback)
       openArchiveCallbackTemp.QueryInterface(IID_ICryptoGetTextPassword, &getTextPassword);
+    if (openArchiveCallback) // by abc321
+      openArchiveCallbackTemp.QueryInterface(IID_ICryptoGetNextPassword, &getNextPassword); // by abc321
     #endif
 
     CInArchive archive(
@@ -709,7 +712,8 @@ Z7_COM7F_IMF(CHandler::Open(IInStream *stream,
         EXTERNAL_CODECS_VARS
         _db
         #ifndef Z7_NO_CRYPTO
-          , getTextPassword, _isEncrypted, _passwordIsDefined, _password
+          //, getTextPassword, _isEncrypted, _passwordIsDefined, _password 
+          , getTextPassword, getNextPassword, _isEncrypted, _passwordIsDefined, _password // by abc321
         #endif
         );
     RINOK(result)
diff --git a/CPP/7zip/Archive/7z/7zIn.cpp b/CPP/7zip/Archive/7z/7zIn.cpp
index 81862d0..aef7a3c 100644
--- a/CPP/7zip/Archive/7z/7zIn.cpp
+++ b/CPP/7zip/Archive/7z/7zIn.cpp
@@ -1178,11 +1178,18 @@ HRESULT CInArchive::ReadAndDecodePackedStreams(
 
   for (CNum i = 0; i < folders.NumFolders; i++)
   {
-    CByteBuffer &data = dataVector.AddNew();
-    const UInt64 unpackSize64 = folders.GetFolderUnpackSize(i);
-    const size_t unpackSize = (size_t)unpackSize64;
-    if (unpackSize != unpackSize64)
-      ThrowUnsupported();
+     CByteBuffer &data = dataVector.AddNew();
+     const UInt64 unpackSize64 = folders.GetFolderUnpackSize(i);
+     const size_t unpackSize = (size_t)unpackSize64;
+     if (unpackSize != unpackSize64)
+        ThrowUnsupported();
+
+     // by abc321 \/
+     bool passwordTested = false;
+     while (!passwordTested) {
+        passwordTested = true;
+     // by abc321 /\~
+
     data.Alloc(unpackSize);
     
     CMyComPtr2_Create<ISequentialOutStream, CBufPtrSeqOutStream> outStreamSpec;
@@ -1190,37 +1197,63 @@ HRESULT CInArchive::ReadAndDecodePackedStreams(
     
     bool dataAfterEnd_Error = false;
 
-    HRESULT result = decoder.Decode(
-        EXTERNAL_CODECS_LOC_VARS
-        _stream, baseOffset + dataOffset,
-        folders, i,
-        NULL, // &unpackSize64
-        
-        outStreamSpec,
-        NULL, // *compressProgress
+      HRESULT result = decoder.Decode(
+         EXTERNAL_CODECS_LOC_VARS
+         _stream, baseOffset + dataOffset,
+         folders, i,
+         NULL, // &unpackSize64
 
-        NULL  // **inStreamMainRes
-        , dataAfterEnd_Error
-        
-        Z7_7Z_DECODER_CRYPRO_VARS
-        #if !defined(Z7_ST)
-          , false // mtMode
-          , 1     // numThreads
-          , 0     // memUsage
-        #endif
-      );
-    
-    RINOK(result)
-    
-    if (dataAfterEnd_Error)
-      ThereIsHeaderError = true;
-    
-    if (unpackSize != outStreamSpec->GetPos())
-      ThrowIncorrect();
+         outStreamSpec,
+         NULL, // *compressProgress
+
+         NULL  // **inStreamMainRes
+         , dataAfterEnd_Error
+
+         Z7_7Z_DECODER_CRYPRO_VARS
+#if !defined(Z7_ST)
+         , false // mtMode
+         , 1     // numThreads
+         , 0     // memUsage
+#endif
+      );
+
+      RINOK(result)
+
+         if (dataAfterEnd_Error)
+            ThereIsHeaderError = true;
+
+      if (unpackSize != outStreamSpec->GetPos())
+         ThrowIncorrect();
+
+      // by abc321 \/
+      if (getNextPassword) {
+         if (folders.FolderCRCs.ValidAndDefined(i)) {
+            if (CrcCalc(data, unpackSize) != folders.FolderCRCs.Vals[i]) {
+               CMyComBSTR_Wipe passwordBSTR;
+               //RINOK(getNextPassword->CryptoGetNextPassword(&passwordBSTR))
+               getNextPassword->CryptoGetNextPassword(&passwordBSTR);
+               if (passwordBSTR) {
+                  password = passwordBSTR;
+                  passwordTested = false;
+               }
+            }
+            else {
+               getNextPassword->CryptoPasswordValid();
+            }
+         }
+      }
+
+      if (passwordTested)
+      // by abc321 /\~
 
     if (folders.FolderCRCs.ValidAndDefined(i))
       if (CrcCalc(data, unpackSize) != folders.FolderCRCs.Vals[i])
         ThrowIncorrect();
+
+   // by abc321 \/
+     }
+   // by abc321 /\~
+
   }
 
   if (folders.PackPositions)
diff --git a/CPP/7zip/Archive/7z/7zIn.h b/CPP/7zip/Archive/7z/7zIn.h
index 99bb779..4b5c5c5 100644
--- a/CPP/7zip/Archive/7z/7zIn.h
+++ b/CPP/7zip/Archive/7z/7zIn.h
@@ -26,8 +26,12 @@ namespace N7z {
 #define Z7_7Z_DECODER_CRYPRO_VARS_DECL
 #define Z7_7Z_DECODER_CRYPRO_VARS
 #else
-#define Z7_7Z_DECODER_CRYPRO_VARS_DECL , ICryptoGetTextPassword *getTextPassword, bool &isEncrypted, bool &passwordIsDefined, UString &password
-#define Z7_7Z_DECODER_CRYPRO_VARS , getTextPassword, isEncrypted, passwordIsDefined, password
+// by abc321 \/
+#define Z7_7Z_DECODER_CRYPRO_VARS_DECL , ICryptoGetTextPassword *getTextPassword, ICryptoGetNextPassword *getNextPassword, bool &isEncrypted, bool &passwordIsDefined, UString &password
+#define Z7_7Z_DECODER_CRYPRO_VARS , getTextPassword, getNextPassword, isEncrypted, passwordIsDefined, password
+// by abc321 /\~
+//#define Z7_7Z_DECODER_CRYPRO_VARS_DECL , ICryptoGetTextPassword *getTextPassword, bool &isEncrypted, bool &passwordIsDefined, UString &password
+//#define Z7_7Z_DECODER_CRYPRO_VARS , getTextPassword, isEncrypted, passwordIsDefined, password
 #endif
 
 struct CParsedMethods
diff --git a/CPP/7zip/Archive/7z/7zUpdate.cpp b/CPP/7zip/Archive/7z/7zUpdate.cpp
index b97b893..8ec9cd1 100644
--- a/CPP/7zip/Archive/7z/7zUpdate.cpp
+++ b/CPP/7zip/Archive/7z/7zUpdate.cpp
@@ -1784,6 +1784,7 @@ class CThreadDecoder Z7_final
   
   #ifndef Z7_NO_CRYPTO
   CMyComPtr<ICryptoGetTextPassword> getTextPassword;
+  CMyComPtr<ICryptoGetNextPassword> getNextPassword; // by abc321
   #endif
 
   DECL_EXTERNAL_CODECS_LOC_VARS_DECL
@@ -1869,11 +1869,36 @@ Z7_CLASS_IMP_NOQIB_1(
   UString Password;
 };
 
+// by abc321 \/
+// not sure that this part is required
+Z7_CLASS_IMP_NOQIB_1(
+   CCryptoGetNextPassword
+   , ICryptoGetNextPassword
+)
+public:
+   UString Password;
+};
+// by abc321 /\~
+
 Z7_COM7F_IMF(CCryptoGetTextPassword::CryptoGetTextPassword(BSTR *password))
 {
   return StringToBstr(Password, password);
 }
 
+// by abc321 \/
+Z7_COM7F_IMF(CCryptoGetNextPassword::CryptoGetNextPassword(BSTR *password))
+{
+   // is not implemented correctly
+   return StringToBstr(Password, password);
+}
+
+Z7_COM7F_IMF(CCryptoGetNextPassword::CryptoPasswordValid())
+{
+   // is not implemented correctly
+   return S_OK;
+}
+// by abc321 /\~
+
 Z7_COM7F_IMF(CCryptoGetTextPassword::CryptoGetPasswordIfAny(bool& passwordIsDefined, UString& password))
 {
   passwordIsDefined = !Password.Len();
@@ -2180,6 +2205,7 @@ HRESULT Update(
 
   CCryptoGetTextPassword *getPasswordSpec = NULL;
   CMyComPtr<ICryptoGetTextPassword> getTextPassword;
+  CMyComPtr<ICryptoGetNextPassword> getNextPassword; // by abc321 - need impementation below
   if (needEncryptedRepack)
   {
     getPasswordSpec = new CCryptoGetTextPassword;
diff --git a/CPP/7zip/Archive/Rar/Rar5Handler.cpp b/CPP/7zip/Archive/Rar/Rar5Handler.cpp
index 4887bd1..4624e74 100644
--- a/CPP/7zip/Archive/Rar/Rar5Handler.cpp
+++ b/CPP/7zip/Archive/Rar/Rar5Handler.cpp
@@ -600,8 +600,13 @@ class CInArchive
     Position += addValue;
   }
 
+//  HRESULT Open(IInStream *inStream, const UInt64 *searchHeaderSizeLimit, ICryptoGetTextPassword *getTextPassword,
+//      CInArcInfo &info);
+
+  // by abc321 \/
   HRESULT Open(IInStream *inStream, const UInt64 *searchHeaderSizeLimit, ICryptoGetTextPassword *getTextPassword,
-      CInArcInfo &info);
+     ICryptoGetNextPassword *getNextPassword, CInArcInfo &info);
+  // by abc321 /\~
 };
   
 
@@ -841,8 +846,12 @@ bool CInArcInfo::ParseExtra(const Byte *p, size_t size)
 
 
 
+//HRESULT CInArchive::Open(IInStream *stream, const UInt64 *searchHeaderSizeLimit, ICryptoGetTextPassword *getTextPassword,
+//    CInArcInfo &info)
+// by abc321 \/
 HRESULT CInArchive::Open(IInStream *stream, const UInt64 *searchHeaderSizeLimit, ICryptoGetTextPassword *getTextPassword,
-    CInArcInfo &info)
+   ICryptoGetNextPassword *getNextPassword, CInArcInfo &info)
+// by abc321 /\~
 {
   m_CryptoMode = false;
   
@@ -888,12 +897,37 @@ HRESULT CInArchive::Open(IInStream *stream, const UInt64 *searchHeaderSizeLimit,
     m_CryptoDecoder.Create_if_Empty();
     RINOK(m_CryptoDecoder->SetDecoderProps(
         Get_Buf_Data(), (unsigned)Get_Buf_RemainSize(), false, false))
+   // by abc321 \/
+   bool passwordTested = false;
+   while (!passwordTested) {
+      passwordTested = true;
+   // by abc321 /\~
+
     RINOK(MySetPassword(getTextPassword, m_CryptoDecoder.ClsPtr()))
     if (!m_CryptoDecoder->CalcKey_and_CheckPassword())
     {
-      WrongPassword = True;
-      return S_FALSE;
-    }
+      // by abc321 \/
+      if (getTextPassword) {
+         CMyComBSTR_Wipe password;
+         //RINOK(getNextPassword->CryptoGetNextPassword(&password))
+         getNextPassword->CryptoGetNextPassword(&password);
+         if (password)
+            passwordTested = false;
+      }
+      if (passwordTested) {
+      // by abc321 /\~
+         WrongPassword = True;
+         return S_FALSE;
+      } // by abc321
+    }
+   // by abc321 \/
+   else {
+      if (getTextPassword)
+         getNextPassword->CryptoPasswordValid();
+   }
+   }
+   // by abc321 /\~
+
     RINOK(ReadBlockHeader(h))
   }
 
@@ -1010,6 +1044,7 @@ struct CUnpacker
   CMyComPtr<ISequentialInStream> filterStream;
   CMyComPtr2<ICompressFilter, NCrypto::NRar5::CDecoder> cryptoDecoder;
   CMyComPtr<ICryptoGetTextPassword> getTextPassword;
+  CMyComPtr<ICryptoGetNextPassword> getNextPassword; // by abc321
   CMyComPtr2<ISequentialOutStream, COutStreamWithHash> outStream;
 
   CByteBuffer _tempBuf;
@@ -1098,10 +1133,34 @@ HRESULT CUnpacker::Create(DECL_EXTERNAL_CODECS_LOC_VARS
       return E_NOTIMPL;
     }
 
+   // by abc321 \/
+   bool passwordTested = false;
+   while (!passwordTested) {
+      passwordTested = true;
+   // by abc321 /\~
+
     RINOK(MySetPassword(getTextPassword, cryptoDecoder.ClsPtr()))
       
     if (!cryptoDecoder->CalcKey_and_CheckPassword())
       wrongPassword = True;
+
+   // by abc321 \/
+   if (getNextPassword) {
+      if (wrongPassword) {
+         CMyComBSTR_Wipe password;
+         //RINOK(getNextPassword->CryptoGetNextPassword(&password))
+         getNextPassword->CryptoGetNextPassword(&password);
+         if (password) {
+            passwordTested = false;
+            wrongPassword = false;
+         }
+      }
+      else {
+         getNextPassword->CryptoPasswordValid();
+      }
+   }
+   }
+   // by abc321 /\~
   }
 
   return S_OK;
@@ -2233,6 +2292,7 @@ HRESULT CHandler::Open2(IInStream *stream,
   {
     openCallback->QueryInterface(IID_IArchiveOpenVolumeCallback, (void **)&openVolumeCallback);
     openCallback->QueryInterface(IID_ICryptoGetTextPassword, (void **)&unpacker.getTextPassword);
+    openCallback->QueryInterface(IID_ICryptoGetNextPassword, (void **)&unpacker.getNextPassword); // by abc321
   }
   // unpacker.getTextPassword = getTextPassword;
   
@@ -2289,7 +2349,8 @@ HRESULT CHandler::Open2(IInStream *stream,
     
     CInArcInfo arcInfo_Open;
     {
-      const HRESULT res = arch.Open(inStream, maxCheckStartPosition, unpacker.getTextPassword, arcInfo_Open);
+      //const HRESULT res = arch.Open(inStream, maxCheckStartPosition, unpacker.getTextPassword, arcInfo_Open);
+      const HRESULT res = arch.Open(inStream, maxCheckStartPosition, unpacker.getTextPassword, unpacker.getNextPassword, arcInfo_Open); // by abc321
       if (arch.IsArc && arch.UnexpectedEnd)
         _errorFlags |= kpv_ErrorFlags_UnexpectedEnd;
       if (_arcs.IsEmpty())
@@ -3268,6 +3329,12 @@ Z7_COM7F_IMF(CHandler::Extract(const UInt32 *indices, UInt32 numItems,
       if (!unpacker.getTextPassword)
         extractCallback->QueryInterface(IID_ICryptoGetTextPassword, (void **)&unpacker.getTextPassword);
 
+   // by abc321 \/
+    if (item->IsEncrypted())
+      if (!unpacker.getNextPassword)
+        extractCallback->QueryInterface(IID_ICryptoGetNextPassword, (void **)&unpacker.getNextPassword);
+   // by abc321 /\~
+
     bool wrongPassword;
     HRESULT result = unpacker.Create(EXTERNAL_CODECS_VARS *item, isSolid, wrongPassword);
 
diff --git a/CPP/7zip/Archive/Rar/RarHandler.cpp b/CPP/7zip/Archive/Rar/RarHandler.cpp
index 1750379..0806b5d 100644
--- a/CPP/7zip/Archive/Rar/RarHandler.cpp
+++ b/CPP/7zip/Archive/Rar/RarHandler.cpp
@@ -170,8 +170,12 @@ class CInArchive
   bool HeaderErrorWarning;
 
   HRESULT Open(IInStream *inStream, const UInt64 *searchHeaderSizeLimit);
+  // by abc321 \/
+  //HRESULT GetNextItem(CItem &item, ICryptoGetTextPassword *getTextPassword,
+  //    bool &filled, EErrorType &error);
   HRESULT GetNextItem(CItem &item, ICryptoGetTextPassword *getTextPassword,
-      bool &filled, EErrorType &error);
+     ICryptoGetNextPassword *getNextPassword,  bool &filled, EErrorType &error);
+  // by abc321 /\~
 };
   
 static bool CheckHeaderCrc(const Byte *header, size_t headerSize)
@@ -186,7 +190,7 @@ HRESULT CInArchive::Open(IInStream *stream, const UInt64 *searchHeaderSizeLimit)
   RINOK(InStream_GetPos_GetSize(stream, m_StreamStartPosition, ArcInfo.FileSize))
   m_Position = m_StreamStartPosition;
 
-  UInt64 arcStartPos = m_StreamStartPosition;
+   UInt64 arcStartPos = m_StreamStartPosition;
   {
     Byte marker[NHeader::kMarkerSize];
     RINOK(ReadStream_FALSE(stream, marker, NHeader::kMarkerSize))
@@ -499,7 +503,10 @@ bool CInArchive::ReadHeaderReal(const Byte *p, unsigned size, CItem &item)
   return true;
 }
 
-HRESULT CInArchive::GetNextItem(CItem &item, ICryptoGetTextPassword *getTextPassword, bool &filled, EErrorType &error)
+// by abc321 \/
+//HRESULT CInArchive::GetNextItem(CItem &item, ICryptoGetTextPassword *getTextPassword, bool &filled, EErrorType &error)
+HRESULT CInArchive::GetNextItem(CItem &item, ICryptoGetTextPassword *getTextPassword, ICryptoGetNextPassword *getNextPassword, bool &filled, EErrorType &error)
+// by abc321 /\~
 {
   filled = false;
   error = k_ErrorType_OK;
@@ -507,103 +514,137 @@ HRESULT CInArchive::GetNextItem(CItem &item, ICryptoGetTextPassword *getTextPass
   {
     RINOK(InStream_SeekSet(m_Stream, m_Position))
     ArcInfo.EndPos = m_Position;
-    if (!m_CryptoMode && (ArcInfo.Flags &
-        NHeader::NArchive::kBlockHeadersAreEncrypted) != 0)
-    {
-      m_CryptoMode = false;
-      if (!getTextPassword)
-      {
-        error = k_ErrorType_DecryptionError;
-        return S_OK; // return S_FALSE;
-      }
-      if (!m_RarAES)
-      {
-        m_RarAESSpec = new NCrypto::NRar3::CDecoder;
-        m_RarAES = m_RarAESSpec;
-      }
-      // m_RarAESSpec->SetRar350Mode(ArcInfo.IsEncryptOld());
-
-      {
-        // Salt
-        const UInt32 kSaltSize = 8;
-        Byte salt[kSaltSize];
-        if (!ReadBytesAndTestSize(salt, kSaltSize))
-          return S_FALSE;
-        m_Position += kSaltSize;
-        RINOK(m_RarAESSpec->SetDecoderProperties2(salt, kSaltSize))
-      }
 
-      {
-        // Password
-        CMyComBSTR_Wipe password;
-        RINOK(getTextPassword->CryptoGetTextPassword(&password))
-        unsigned len = 0;
-        if (password)
-          len = MyStringLen(password);
-        if (len > kPasswordLen_MAX)
-          len = kPasswordLen_MAX;
-        
-        CByteBuffer_Wipe buffer(len * 2);
-        for (unsigned i = 0; i < len; i++)
-        {
-          wchar_t c = password[i];
-          ((Byte *)buffer)[i * 2] = (Byte)c;
-          ((Byte *)buffer)[i * 2 + 1] = (Byte)(c >> 8);
-        }
-        
-        m_RarAESSpec->SetPassword((const Byte *)buffer, len * 2);
-      }
-
-      const UInt32 kDecryptedBufferSize = (1 << 12);
-      if (m_DecryptedDataAligned.Size() == 0)
-      {
-        // const UInt32 kAlign = 16;
-        m_DecryptedDataAligned.AllocAtLeast(kDecryptedBufferSize);
-        if (!m_DecryptedDataAligned.IsAllocated())
-          return E_OUTOFMEMORY;
-      }
-      RINOK(m_RarAES->Init())
-      size_t decryptedDataSizeT = kDecryptedBufferSize;
-      RINOK(ReadStream(m_Stream, m_DecryptedDataAligned, &decryptedDataSizeT))
-      m_DecryptedDataSize = (UInt32)decryptedDataSizeT;
-      m_DecryptedDataSize = m_RarAES->Filter(m_DecryptedDataAligned, m_DecryptedDataSize);
-
-      m_CryptoMode = true;
-      m_CryptoPos = 0;
-    }
-
-    m_FileHeaderData.AllocAtLeast(7);
-    size_t processed = 7;
-    RINOK(ReadBytesSpec((Byte *)m_FileHeaderData, &processed))
-    if (processed != 7)
-    {
-      if (processed != 0)
-        error = k_ErrorType_UnexpectedEnd;
-      ArcInfo.EndPos = m_Position + processed; // test it
-      return S_OK;
-    }
-
-    const Byte *p = m_FileHeaderData;
-    m_BlockHeader.CRC = Get16(p + 0);
-    m_BlockHeader.Type = p[2];
-    m_BlockHeader.Flags = Get16(p + 3);
-    m_BlockHeader.HeadSize = Get16(p + 5);
-
-    if (m_BlockHeader.HeadSize < 7)
-    {
-      error = k_ErrorType_Corrupted;
-      return S_OK;
-      // ThrowExceptionWithCode(CInArchiveException::kIncorrectArchive);
-    }
-
-    if (m_BlockHeader.Type < NHeader::NBlockType::kFileHeader ||
-        m_BlockHeader.Type > NHeader::NBlockType::kEndOfArchive)
-    {
-      error = m_CryptoMode ?
-          k_ErrorType_DecryptionError :
-          k_ErrorType_Corrupted;
-      return S_OK;
-    }
+   // by abc321 \/
+   size_t processed = 7;
+   bool passwordTested = false;
+   UInt64 streamPosition = m_Position;
+   while (!passwordTested) {
+      passwordTested = true;
+      // by abc321 /\~
+
+      if (!m_CryptoMode && (ArcInfo.Flags &
+         NHeader::NArchive::kBlockHeadersAreEncrypted) != 0)
+      {
+         m_CryptoMode = false;
+         if (!getTextPassword)
+         {
+            error = k_ErrorType_DecryptionError;
+            return S_OK; // return S_FALSE;
+         }
+         if (!m_RarAES)
+         {
+            m_RarAESSpec = new NCrypto::NRar3::CDecoder;
+            m_RarAES = m_RarAESSpec;
+         }
+         // m_RarAESSpec->SetRar350Mode(ArcInfo.IsEncryptOld());
+
+         {
+            // Salt
+            const UInt32 kSaltSize = 8;
+            Byte salt[kSaltSize];
+            if (!ReadBytesAndTestSize(salt, kSaltSize))
+               return S_FALSE;
+            m_Position += kSaltSize;
+            RINOK(m_RarAESSpec->SetDecoderProperties2(salt, kSaltSize))
+         }
+
+         {
+            // Password
+            CMyComBSTR_Wipe password;
+            RINOK(getTextPassword->CryptoGetTextPassword(&password))
+               unsigned len = 0;
+            if (password)
+               len = MyStringLen(password);
+            if (len > kPasswordLen_MAX)
+               len = kPasswordLen_MAX;
+
+            CByteBuffer_Wipe buffer(len * 2);
+            for (unsigned i = 0; i < len; i++)
+            {
+               wchar_t c = password[i];
+               ((Byte *)buffer)[i * 2] = (Byte)c;
+               ((Byte *)buffer)[i * 2 + 1] = (Byte)(c >> 8);
+            }
+
+            m_RarAESSpec->SetPassword((const Byte *)buffer, len * 2);
+         }
+
+         const UInt32 kDecryptedBufferSize = (1 << 12);
+         if (m_DecryptedDataAligned.Size() == 0)
+         {
+            // const UInt32 kAlign = 16;
+            m_DecryptedDataAligned.AllocAtLeast(kDecryptedBufferSize);
+            if (!m_DecryptedDataAligned.IsAllocated())
+               return E_OUTOFMEMORY;
+         }
+         RINOK(m_RarAES->Init())
+            size_t decryptedDataSizeT = kDecryptedBufferSize;
+         RINOK(ReadStream(m_Stream, m_DecryptedDataAligned, &decryptedDataSizeT))
+            m_DecryptedDataSize = (UInt32)decryptedDataSizeT;
+         m_DecryptedDataSize = m_RarAES->Filter(m_DecryptedDataAligned, m_DecryptedDataSize);
+
+         m_CryptoMode = true;
+         m_CryptoPos = 0;
+      }
+
+      m_FileHeaderData.AllocAtLeast(7);
+      //size_t processed = 7; // by abc321
+      processed = 7; // by abc321
+      RINOK(ReadBytesSpec((Byte *)m_FileHeaderData, &processed))
+         if (processed != 7)
+         {
+            if (processed != 0)
+               error = k_ErrorType_UnexpectedEnd;
+            ArcInfo.EndPos = m_Position + processed; // test it
+            return S_OK;
+         }
+
+      const Byte *p = m_FileHeaderData;
+      m_BlockHeader.CRC = Get16(p + 0);
+      m_BlockHeader.Type = p[2];
+      m_BlockHeader.Flags = Get16(p + 3);
+      m_BlockHeader.HeadSize = Get16(p + 5);
+
+      if (m_BlockHeader.HeadSize < 7)
+      {
+         error = k_ErrorType_Corrupted;
+         return S_OK;
+         // ThrowExceptionWithCode(CInArchiveException::kIncorrectArchive);
+      }
+
+      // by abc321 \/
+      if (m_CryptoMode && getNextPassword)
+         if (m_BlockHeader.Type < NHeader::NBlockType::kFileHeader ||
+            m_BlockHeader.Type > NHeader::NBlockType::kEndOfArchive) {
+            
+            CMyComBSTR_Wipe password;
+            //RINOK(getNextPassword->CryptoGetNextPassword(&password))
+            getNextPassword->CryptoGetNextPassword(&password);
+
+            if (password) {
+               RINOK(InStream_SeekSet(m_Stream, streamPosition))
+               m_Position = streamPosition;
+               passwordTested = false;
+               m_CryptoMode = false;
+            }
+         }
+      if (passwordTested) {
+      // by abc321 /\~
+
+      if (m_BlockHeader.Type < NHeader::NBlockType::kFileHeader ||
+         m_BlockHeader.Type > NHeader::NBlockType::kEndOfArchive)
+      {
+         error = m_CryptoMode ?
+            k_ErrorType_DecryptionError :
+            k_ErrorType_Corrupted;
+         return S_OK;
+      }
+
+      // by abc321 \/
+      }
+   }
+   // by abc321 /\~
 
     if (m_BlockHeader.Type == NHeader::NBlockType::kEndOfArchive)
     {
@@ -682,6 +723,12 @@ HRESULT CInArchive::GetNextItem(CItem &item, ICryptoGetTextPassword *getTextPass
       m_Position += processed;
       FinishCryptoBlock();
       ArcInfo.EndPos = m_Position;
+
+     // by abc321 \/
+     // code was commented due to CryptoPasswordValid is called in the code below
+     //if (getNextPassword)
+        //RINOK(getNextPassword->CryptoPasswordValid())
+     // by abc321 /\~
       return S_OK;
     }
 
@@ -1053,7 +1100,8 @@ HRESULT CHandler::Open2(IInStream *stream,
   {
     CMyComPtr<IArchiveOpenVolumeCallback> openVolumeCallback;
     CMyComPtr<ICryptoGetTextPassword> getTextPassword;
-    
+   CMyComPtr<ICryptoGetNextPassword> getNextPassword; // by abc321
+
     CVolumeName seqName;
 
     UInt64 totalBytes = 0;
@@ -1063,7 +1111,8 @@ HRESULT CHandler::Open2(IInStream *stream,
     {
       openCallback->QueryInterface(IID_IArchiveOpenVolumeCallback, (void **)&openVolumeCallback);
       openCallback->QueryInterface(IID_ICryptoGetTextPassword, (void **)&getTextPassword);
-    }
+     openCallback->QueryInterface(IID_ICryptoGetNextPassword, (void **)&getNextPassword); // by abc321
+   }
 
     bool nextVol_is_Required = false;
 
@@ -1140,7 +1189,8 @@ HRESULT CHandler::Open2(IInStream *stream,
         // bool decryptionError;
         // AString errorMessageLoc;
         bool filled;
-        HRESULT result = archive.GetNextItem(item, getTextPassword, filled, error);
+        //HRESULT result = archive.GetNextItem(item, getTextPassword, filled, error); // by abc321
+        HRESULT result = archive.GetNextItem(item, getTextPassword, getNextPassword, filled, error); // by abc321
         
         if (error != k_ErrorType_OK)
         {
@@ -1394,6 +1444,7 @@ Z7_COM7F_IMF(CHandler::Extract(const UInt32 *indices, UInt32 numItems,
 {
   COM_TRY_BEGIN
   CMyComPtr<ICryptoGetTextPassword> getTextPassword;
+  CMyComPtr<ICryptoGetNextPassword> getNextPassword; // by abc321
   UInt64 // censoredTotalUnPacked = 0,
         // censoredTotalPacked = 0,
         importantTotalUnPacked = 0;
@@ -1482,271 +1533,307 @@ Z7_COM7F_IMF(CHandler::Extract(const UInt32 *indices, UInt32 numItems,
   bool solidStart = true;
   
   for (unsigned i = 0;;
-      i++,
-      currentImportantTotalUnPacked += currentUnPackSize,
-      currentImportantTotalPacked += currentPackSize)
+     i++,
+     currentImportantTotalUnPacked += currentUnPackSize,
+     currentImportantTotalPacked += currentPackSize)
   {
-    lps->InSize = currentImportantTotalPacked;
-    lps->OutSize = currentImportantTotalUnPacked;
-    RINOK(lps->SetCur())
-
-    if (i >= importantIndexes.Size())
-      break;
-
-    CMyComPtr<ISequentialOutStream> realOutStream;
-
-    Int32 askMode;
-    if (extractStatuses[i])
-      askMode = testMode ?
-          NExtract::NAskMode::kTest :
-          NExtract::NAskMode::kExtract;
-    else
-      askMode = NExtract::NAskMode::kSkip;
-
-    UInt32 index = importantIndexes[i];
-
-    const CRefItem &refItem = _refItems[index];
-    const CItem &item = _items[refItem.ItemIndex];
-    const CItem &lastItem = _items[refItem.ItemIndex + refItem.NumItems - 1];
-    
-    UInt64 outSize = (UInt64)(Int64)-1;
-    currentUnPackSize = 0;
-    if (lastItem.Is_Size_Defined())
-    {
-      outSize = lastItem.Size;
-      currentUnPackSize = outSize;
-    }
-
-    currentPackSize = GetPackSize(index);
-
-    if (item.IgnoreItem())
-      continue;
-
-    RINOK(extractCallback->GetStream(index, &realOutStream, askMode))
-
-    if (!IsSolid(index))
-      solidStart = true;
-    if (item.IsDir())
-    {
-      RINOK(extractCallback->PrepareOperation(askMode))
-      RINOK(extractCallback->SetOperationResult(NExtract::NOperationResult::kOK))
-      continue;
-    }
-
-    bool mustBeProcessedAnywhere = false;
-    if (i < importantIndexes.Size() - 1)
-    {
-      // const CRefItem &nextRefItem = _refItems[importantIndexes[i + 1]];
-      // const CItem &nextItemInfo = _items[nextRefItem.ItemIndex];
-      // mustBeProcessedAnywhere = nextItemInfo.IsSolid();
-      mustBeProcessedAnywhere = IsSolid(importantIndexes[i + 1]);
-    }
-    
-    if (!mustBeProcessedAnywhere && !testMode && !realOutStream)
-      continue;
-    
-    if (!realOutStream && !testMode)
-      askMode = NExtract::NAskMode::kSkip;
-
-    RINOK(extractCallback->PrepareOperation(askMode))
-
-    COutStreamWithCRC *outStreamSpec = new COutStreamWithCRC;
-    CMyComPtr<ISequentialOutStream> outStream(outStreamSpec);
-    outStreamSpec->SetStream(realOutStream);
-    outStreamSpec->Init();
-    realOutStream.Release();
-    
-    if (!volsInStream)
-    {
-      volsInStreamSpec = new CVolsInStream;
-      volsInStream = volsInStreamSpec;
-    }
-
-    volsInStreamSpec->Init(&_arcs, &_items, refItem);
-
-    UInt64 packSize = currentPackSize;
-
-    // packedPos += item.PackSize;
-    // unpackedPos += 0;
-    
-    CMyComPtr<ISequentialInStream> inStream;
-    
-    if (item.IsEncrypted())
-    {
-      // CMyComPtr<ICryptoSetPassword> cryptoSetPassword;
-      
-      if (item.UnPackVersion >= 29)
-      {
-        if (!rar3CryptoDecoder)
-        {
-          rar3CryptoDecoderSpec = new NCrypto::NRar3::CDecoder;
-          rar3CryptoDecoder = rar3CryptoDecoderSpec;
-        }
-        // rar3CryptoDecoderSpec->SetRar350Mode(item.UnPackVersion < 36);
-        /*
-        CMyComPtr<ICompressSetDecoderProperties2> cryptoProperties;
-        RINOK(rar3CryptoDecoder.QueryInterface(IID_ICompressSetDecoderProperties2,
-            &cryptoProperties));
-        */
-        RINOK(rar3CryptoDecoderSpec->SetDecoderProperties2(item.Salt, item.HasSalt() ? sizeof(item.Salt) : 0))
-        filterStreamSpec->Filter = rar3CryptoDecoder;
-      }
-      else if (item.UnPackVersion >= 20)
-      {
-        if (!rar20CryptoDecoder)
-        {
-          rar20CryptoDecoderSpec = new NCrypto::NRar2::CDecoder;
-          rar20CryptoDecoder = rar20CryptoDecoderSpec;
-        }
-        filterStreamSpec->Filter = rar20CryptoDecoder;
-      }
-      else
-      {
-        outStream.Release();
-        RINOK(extractCallback->SetOperationResult(NExtract::NOperationResult::kUnsupportedMethod))
-        continue;
-      }
-      
-      // RINOK(filterStreamSpec->Filter.QueryInterface(IID_ICryptoSetPassword, &cryptoSetPassword));
-
-      if (!getTextPassword)
-        extractCallback->QueryInterface(IID_ICryptoGetTextPassword, (void **)&getTextPassword);
-
-      if (!getTextPassword)
-      {
-        outStream.Release();
-        RINOK(extractCallback->SetOperationResult(NExtract::NOperationResult::kUnsupportedMethod))
-        continue;
-      }
-
-      // if (getTextPassword)
-      {
-        CMyComBSTR_Wipe password;
-        RINOK(getTextPassword->CryptoGetTextPassword(&password))
-        
-        if (item.UnPackVersion >= 29)
-        {
-          unsigned len = 0;
-          if (password)
-            len = MyStringLen(password);
-          if (len > kPasswordLen_MAX)
-            len = kPasswordLen_MAX;
-          CByteBuffer_Wipe buffer(len * 2);
-          for (unsigned k = 0; k < len; k++)
-          {
-            wchar_t c = password[k];
-            ((Byte *)buffer)[k * 2] = (Byte)c;
-            ((Byte *)buffer)[k * 2 + 1] = (Byte)(c >> 8);
-          }
-          rar3CryptoDecoderSpec->SetPassword((const Byte *)buffer, len * 2);
-        }
-        else
-        {
-          AString_Wipe oemPassword;
-          if (password)
-          {
-            UString_Wipe unicode;
-            unicode.SetFromBstr(password);
-            if (unicode.Len() > kPasswordLen_MAX)
-              unicode.DeleteFrom(kPasswordLen_MAX);
-            UnicodeStringToMultiByte2(oemPassword, unicode, CP_OEMCP);
-          }
-          rar20CryptoDecoderSpec->SetPassword((const Byte *)(const char *)oemPassword, oemPassword.Len());
-        }
-      }
-      /*
-      else
-      {
-        RINOK(cryptoSetPassword->CryptoSetPassword(NULL, 0));
-      }
-      */
-      
-      filterStreamSpec->SetInStream(volsInStream);
-      filterStreamSpec->SetOutStreamSize(NULL);
-      inStream = filterStream;
-    }
-    else
-    {
-      inStream = volsInStream;
-    }
-    
-    CMyComPtr<ICompressCoder> commonCoder;
-    
-    switch (item.Method)
-    {
-      case '0':
-      {
-        commonCoder = copyCoder;
-        break;
-      }
-      case '1':
-      case '2':
-      case '3':
-      case '4':
-      case '5':
-      {
-        unsigned m;
-        for (m = 0; m < methodItems.Size(); m++)
-          if (methodItems[m].RarUnPackVersion == item.UnPackVersion)
-            break;
-        if (m == methodItems.Size())
-        {
-          CMethodItem mi;
-          mi.RarUnPackVersion = item.UnPackVersion;
-
-          mi.Coder.Release();
-          if (item.UnPackVersion <= 40)
-          {
-            UInt32 methodID = 0x40300;
-            if (item.UnPackVersion < 20)
-              methodID += 1;
-            else if (item.UnPackVersion < 29)
-              methodID += 2;
-            else
-              methodID += 3;
-            RINOK(CreateCoder_Id(EXTERNAL_CODECS_VARS methodID, false, mi.Coder))
-          }
-         
-          if (!mi.Coder)
-          {
-            outStream.Release();
-            RINOK(extractCallback->SetOperationResult(NExtract::NOperationResult::kUnsupportedMethod))
-            continue;
-          }
-
-          m = methodItems.Add(mi);
-        }
-        CMyComPtr<ICompressCoder> decoder = methodItems[m].Coder;
-
-        CMyComPtr<ICompressSetDecoderProperties2> compressSetDecoderProperties;
-        RINOK(decoder.QueryInterface(IID_ICompressSetDecoderProperties2,
-            &compressSetDecoderProperties))
-        
-        Byte isSolid = (Byte)((IsSolid(index) || item.IsSplitBefore()) ? 1: 0);
-        if (solidStart)
-        {
-          isSolid = 0;
-          solidStart = false;
-        }
-
-
-        RINOK(compressSetDecoderProperties->SetDecoderProperties2(&isSolid, 1))
-          
-        commonCoder = decoder;
-        break;
-      }
-      default:
-        outStream.Release();
-        RINOK(extractCallback->SetOperationResult(NExtract::NOperationResult::kUnsupportedMethod))
-        continue;
-    }
-    
-    HRESULT result = commonCoder->Code(inStream, outStream, &packSize, &outSize, progress);
-    
-    if (item.IsEncrypted())
-      filterStreamSpec->ReleaseInStream();
-    
-    if (outSize == (UInt64)(Int64)-1)
+     lps->InSize = currentImportantTotalPacked;
+     lps->OutSize = currentImportantTotalUnPacked;
+     RINOK(lps->SetCur())
+
+        if (i >= importantIndexes.Size())
+           break;
+
+     CMyComPtr<ISequentialOutStream> realOutStream;
+
+     Int32 askMode;
+     if (extractStatuses[i])
+        askMode = testMode ?
+        NExtract::NAskMode::kTest :
+        NExtract::NAskMode::kExtract;
+     else
+        askMode = NExtract::NAskMode::kSkip;
+
+     UInt32 index = importantIndexes[i];
+
+     const CRefItem &refItem = _refItems[index];
+     const CItem &item = _items[refItem.ItemIndex];
+     const CItem &lastItem = _items[refItem.ItemIndex + refItem.NumItems - 1];
+
+     UInt64 outSize = (UInt64)(Int64)-1;
+     currentUnPackSize = 0;
+     if (lastItem.Is_Size_Defined())
+     {
+        outSize = lastItem.Size;
+        currentUnPackSize = outSize;
+     }
+
+     currentPackSize = GetPackSize(index);
+
+     if (item.IgnoreItem())
+        continue;
+
+     RINOK(extractCallback->GetStream(index, &realOutStream, askMode))
+
+        if (!IsSolid(index))
+           solidStart = true;
+     if (item.IsDir())
+     {
+        RINOK(extractCallback->PrepareOperation(askMode))
+           RINOK(extractCallback->SetOperationResult(NExtract::NOperationResult::kOK))
+           continue;
+     }
+
+     bool mustBeProcessedAnywhere = false;
+     if (i < importantIndexes.Size() - 1)
+     {
+        // const CRefItem &nextRefItem = _refItems[importantIndexes[i + 1]];
+        // const CItem &nextItemInfo = _items[nextRefItem.ItemIndex];
+        // mustBeProcessedAnywhere = nextItemInfo.IsSolid();
+        mustBeProcessedAnywhere = IsSolid(importantIndexes[i + 1]);
+     }
+
+     if (!mustBeProcessedAnywhere && !testMode && !realOutStream)
+        continue;
+
+     if (!realOutStream && !testMode)
+        askMode = NExtract::NAskMode::kSkip;
+
+     RINOK(extractCallback->PrepareOperation(askMode))
+
+        COutStreamWithCRC *outStreamSpec = new COutStreamWithCRC;
+     CMyComPtr<ISequentialOutStream> outStream(outStreamSpec);
+     outStreamSpec->SetStream(realOutStream);
+     outStreamSpec->Init();
+     realOutStream.Release();
+
+     // abc321 code \/
+     HRESULT result = S_FALSE;
+     bool passwordTested = false;
+     while (!passwordTested) {
+        passwordTested = true;
+     // abc321 code /\~
+
+
+     if (!volsInStream)
+     {
+        volsInStreamSpec = new CVolsInStream;
+        volsInStream = volsInStreamSpec;
+     }
+
+     volsInStreamSpec->Init(&_arcs, &_items, refItem);
+
+     UInt64 packSize = currentPackSize;
+
+     // packedPos += item.PackSize;
+     // unpackedPos += 0;
+
+     CMyComPtr<ISequentialInStream> inStream;
+
+     if (item.IsEncrypted())
+     {
+        // CMyComPtr<ICryptoSetPassword> cryptoSetPassword;
+
+        if (item.UnPackVersion >= 29)
+        {
+           if (!rar3CryptoDecoder)
+           {
+              rar3CryptoDecoderSpec = new NCrypto::NRar3::CDecoder;
+              rar3CryptoDecoder = rar3CryptoDecoderSpec;
+           }
+           // rar3CryptoDecoderSpec->SetRar350Mode(item.UnPackVersion < 36);
+           /*
+           CMyComPtr<ICompressSetDecoderProperties2> cryptoProperties;
+           RINOK(rar3CryptoDecoder.QueryInterface(IID_ICompressSetDecoderProperties2,
+              &cryptoProperties));
+           */
+           RINOK(rar3CryptoDecoderSpec->SetDecoderProperties2(item.Salt, item.HasSalt() ? sizeof(item.Salt) : 0))
+              filterStreamSpec->Filter = rar3CryptoDecoder;
+        }
+        else if (item.UnPackVersion >= 20)
+        {
+           if (!rar20CryptoDecoder)
+           {
+              rar20CryptoDecoderSpec = new NCrypto::NRar2::CDecoder;
+              rar20CryptoDecoder = rar20CryptoDecoderSpec;
+           }
+           filterStreamSpec->Filter = rar20CryptoDecoder;
+        }
+        else
+        {
+           outStream.Release();
+           RINOK(extractCallback->SetOperationResult(NExtract::NOperationResult::kUnsupportedMethod))
+              continue;
+        }
+
+        // RINOK(filterStreamSpec->Filter.QueryInterface(IID_ICryptoSetPassword, &cryptoSetPassword));
+
+        if (!getTextPassword)
+           extractCallback->QueryInterface(IID_ICryptoGetTextPassword, (void **)&getTextPassword);
+
+        if (!getTextPassword)
+        {
+           outStream.Release();
+           RINOK(extractCallback->SetOperationResult(NExtract::NOperationResult::kUnsupportedMethod))
+              continue;
+        }
+
+        // if (getTextPassword)
+        {
+           CMyComBSTR_Wipe password;
+           RINOK(getTextPassword->CryptoGetTextPassword(&password))
+
+              if (item.UnPackVersion >= 29)
+              {
+                 unsigned len = 0;
+                 if (password)
+                    len = MyStringLen(password);
+                 if (len > kPasswordLen_MAX)
+                    len = kPasswordLen_MAX;
+                 CByteBuffer_Wipe buffer(len * 2);
+                 for (unsigned k = 0; k < len; k++)
+                 {
+                    wchar_t c = password[k];
+                    ((Byte *)buffer)[k * 2] = (Byte)c;
+                    ((Byte *)buffer)[k * 2 + 1] = (Byte)(c >> 8);
+                 }
+                 rar3CryptoDecoderSpec->SetPassword((const Byte *)buffer, len * 2);
+              }
+              else
+              {
+                 AString_Wipe oemPassword;
+                 if (password)
+                 {
+                    UString_Wipe unicode;
+                    unicode.SetFromBstr(password);
+                    if (unicode.Len() > kPasswordLen_MAX)
+                       unicode.DeleteFrom(kPasswordLen_MAX);
+                    UnicodeStringToMultiByte2(oemPassword, unicode, CP_OEMCP);
+                 }
+                 rar20CryptoDecoderSpec->SetPassword((const Byte *)(const char *)oemPassword, oemPassword.Len());
+              }
+        }
+        /*
+        else
+        {
+         RINOK(cryptoSetPassword->CryptoSetPassword(NULL, 0));
+        }
+        */
+
+        filterStreamSpec->SetInStream(volsInStream);
+        filterStreamSpec->SetOutStreamSize(NULL);
+        inStream = filterStream;
+     }
+     else
+     {
+        inStream = volsInStream;
+     }
+
+     CMyComPtr<ICompressCoder> commonCoder;
+
+     switch (item.Method)
+     {
+     case '0':
+     {
+        commonCoder = copyCoder;
+        break;
+     }
+     case '1':
+     case '2':
+     case '3':
+     case '4':
+     case '5':
+     {
+        unsigned m;
+        for (m = 0; m < methodItems.Size(); m++)
+           if (methodItems[m].RarUnPackVersion == item.UnPackVersion)
+              break;
+        if (m == methodItems.Size())
+        {
+           CMethodItem mi;
+           mi.RarUnPackVersion = item.UnPackVersion;
+
+           mi.Coder.Release();
+           if (item.UnPackVersion <= 40)
+           {
+              UInt32 methodID = 0x40300;
+              if (item.UnPackVersion < 20)
+                 methodID += 1;
+              else if (item.UnPackVersion < 29)
+                 methodID += 2;
+              else
+                 methodID += 3;
+              RINOK(CreateCoder_Id(EXTERNAL_CODECS_VARS methodID, false, mi.Coder))
+           }
+
+           if (!mi.Coder)
+           {
+              outStream.Release();
+              RINOK(extractCallback->SetOperationResult(NExtract::NOperationResult::kUnsupportedMethod))
+                 continue;
+           }
+
+           m = methodItems.Add(mi);
+        }
+        CMyComPtr<ICompressCoder> decoder = methodItems[m].Coder;
+
+        CMyComPtr<ICompressSetDecoderProperties2> compressSetDecoderProperties;
+        RINOK(decoder.QueryInterface(IID_ICompressSetDecoderProperties2,
+           &compressSetDecoderProperties))
+
+           Byte isSolid = (Byte)((IsSolid(index) || item.IsSplitBefore()) ? 1 : 0);
+        if (solidStart)
+        {
+           isSolid = 0;
+           solidStart = false;
+        }
+
+
+        RINOK(compressSetDecoderProperties->SetDecoderProperties2(&isSolid, 1))
+
+           commonCoder = decoder;
+        break;
+     }
+     default:
+        outStream.Release();
+        RINOK(extractCallback->SetOperationResult(NExtract::NOperationResult::kUnsupportedMethod))
+           continue;
+     }
+
+     //HRESULT result = commonCoder->Code(inStream, outStream, &packSize, &outSize, progress); // commented by abc321
+     result = commonCoder->Code(inStream, outStream, &packSize, &outSize, progress); // by abc321
+
+     if (item.IsEncrypted())
+        filterStreamSpec->ReleaseInStream();
+
+     // abc321 code \/
+     if (item.IsEncrypted()) {
+        if (result == S_OK || result == S_FALSE) {
+           if (!getNextPassword)
+              extractCallback->QueryInterface(IID_ICryptoGetNextPassword, (void **)&getNextPassword);
+        }
+
+        if (result == S_OK) {
+           if (getNextPassword) {
+              RINOK(getNextPassword->CryptoPasswordValid())
+           }
+        } else if (result == S_FALSE) {
+           if (getNextPassword) {
+              CMyComBSTR_Wipe password;
+              //RINOK(getNextPassword->CryptoGetNextPassword(&password))
+              getNextPassword->CryptoGetNextPassword(&password);
+              //AString_Wipe charPassword;
+
+              if (password)
+                 passwordTested = false;
+           }
+        }
+     }
+
+     }
+     // abc321 code /\~
+
+   if (outSize == (UInt64)(Int64)-1)
       currentUnPackSize = outStreamSpec->GetSize();
 
     int opRes = (volsInStreamSpec->CrcIsOK && outStreamSpec->GetCRC() == lastItem.FileCRC) ?
diff --git a/CPP/7zip/Archive/Zip/ZipHandler.cpp b/CPP/7zip/Archive/Zip/ZipHandler.cpp
index 553ac05..de83c9a 100644
--- a/CPP/7zip/Archive/Zip/ZipHandler.cpp
+++ b/CPP/7zip/Archive/Zip/ZipHandler.cpp
@@ -861,6 +861,7 @@ class CZipDecoder
 
   CMyComPtr2<ISequentialInStream, CFilterCoder> filterStream;
   CMyComPtr<ICryptoGetTextPassword> getTextPassword;
+  CMyComPtr<ICryptoGetNextPassword> getNextPassword; // by abc321
   CObjectVector<CMethodItem> methodItems;
 
   CLzmaDecoder *lzmaDecoderSpec;
@@ -967,7 +968,15 @@ Z7_COM7F_IMF(COutStreamWithPadPKCS7::Write(const void *data, UInt32 size, UInt32
   return result;
 }
 
-
+// by abc321 - coppied from MyCom.h
+/*
+inline HRESULT StringToBstr(LPCOLESTR src, BSTR *bstr)
+{
+   *bstr = ::SysAllocString(src);
+   return (*bstr) ? S_OK : E_OUTOFMEMORY;
+}
+*/
+// by abc321
 
 HRESULT CZipDecoder::Decode(
     DECL_EXTERNAL_CODECS_LOC_VARS
@@ -1251,69 +1260,250 @@ HRESULT CZipDecoder::Decode(
       );
 
   {
-    HRESULT result = S_OK;
-    if (item.IsEncrypted())
-    {
-      if (!filterStream.IsDefined())
-        filterStream.SetFromCls(new CFilterCoder(false));
-     
-      filterReleaser.FilterCoder = filterStream.ClsPtr();
-      filterStream->Filter = cryptoFilter;
-      
-      if (wzAesMode)
-      {
-        result = _wzAesDecoder->ReadHeader(inStream);
-        if (result == S_OK)
-        {
-          if (!_wzAesDecoder->Init_and_CheckPassword())
-          {
-            res = NExtract::NOperationResult::kWrongPassword;
-            return S_OK;
-          }
-        }
-      }
-      else if (pkAesMode)
-      {
-        isFullStreamExpected = false;
-        result = _pkAesDecoder->ReadHeader(inStream, item.Crc, item.Size);
-        if (result == S_OK)
-        {
-          bool passwOK;
-          result = _pkAesDecoder->Init_and_CheckPassword(passwOK);
-          if (result == S_OK && !passwOK)
-          {
-            res = NExtract::NOperationResult::kWrongPassword;
-            return S_OK;
-          }
-        }
-      }
-      else
-      {
-        result = _zipCryptoDecoder->ReadHeader(inStream);
-        if (result == S_OK)
-        {
-          _zipCryptoDecoder->Init_BeforeDecode();
-          
-          /* Info-ZIP modification to ZipCrypto format:
-               if bit 3 of the general purpose bit flag is set,
-               it uses high byte of 16-bit File Time.
-             Info-ZIP code probably writes 2 bytes of File Time.
-             We check only 1 byte. */
-
-          // UInt32 v1 = GetUi16(_zipCryptoDecoder->_header + NCrypto::NZip::kHeaderSize - 2);
-          // UInt32 v2 = (item.HasDescriptor() ? (item.Time & 0xFFFF) : (item.Crc >> 16));
-
-          Byte v1 = _zipCryptoDecoder->_header[NCrypto::NZip::kHeaderSize - 1];
-          Byte v2 = (Byte)(item.HasDescriptor() ? (item.Time >> 8) : (item.Crc >> 24));
-
-          if (v1 != v2)
-          {
-            res = NExtract::NOperationResult::kWrongPassword;
-            return S_OK;
-          }
-        }
-      }
-    }
+     HRESULT result = S_OK;
+
+     // abc321 code \/
+     /*
+     if (true) {
+        CMyComPtr<ICryptoSetPassword> cryptoSetPassword;
+        RINOK(cryptoFilter.QueryInterface(IID_ICryptoSetPassword, &cryptoSetPassword))
+           if (!cryptoSetPassword)
+              return E_FAIL;
+        CMyComBSTR_Wipe password;
+        AString_Wipe charPassword;
+        UString Password = L"1234";
+        StringToBstr((LPCOLESTR)Password, &password);
+
+        if (password) {
+           UnicodeStringToMultiByte2(charPassword, (LPCOLESTR)password, CP_ACP);
+           result =
+              cryptoSetPassword->CryptoSetPassword(
+              (const Byte *)(const char *)charPassword, charPassword.Len());
+           if ((result == E_INVALIDARG) && (charPassword.Len() > 1) && !passwordTested) // abc321 on 20250619
+              result = S_OK; // abc321
+           if (result != S_OK)
+           {
+              res = NExtract::NOperationResult::kWrongPassword;
+              return S_OK;
+           }
+        }
+        else
+        {
+           res = NExtract::NOperationResult::kWrongPassword;
+           return S_OK;
+        }
+     }
+     */
+     bool passwordTested = false;
+     CMyComBSTR_Wipe password;
+     while (!passwordTested) {
+        passwordTested = true;
+        password.Wipe_and_Free();
+        // abc321 code /\~
+
+        if (item.IsEncrypted())
+        {
+           // abc321 code \/
+           if (!getNextPassword)
+              extractCallback->QueryInterface(IID_ICryptoGetNextPassword, (void **)&getNextPassword);
+           // abc321 code /\~
+
+           if (!filterStream.IsDefined())
+              filterStream.SetFromCls(new CFilterCoder(false));
+
+           filterReleaser.FilterCoder = filterStream.ClsPtr();
+           filterStream->Filter = cryptoFilter;
+
+           if (wzAesMode)
+           {
+              result = _wzAesDecoder->ReadHeader(inStream);
+              if (result == S_OK)
+              {
+                 if (!_wzAesDecoder->Init_and_CheckPassword())
+                 {
+                    // abc321 code \/
+                    if (getNextPassword)
+                    {
+                       //RINOK(getNextPassword->CryptoGetNextPassword(&password))
+                       if (getNextPassword->CryptoGetNextPassword(&password) == S_OK) {
+                          if (password && (&password != NULL) && (wcslen(&password[0]) > 0))
+                             passwordTested = false;
+                       }
+                    }
+                    if (passwordTested) {
+                       // abc321 code /\~
+
+                       res = NExtract::NOperationResult::kWrongPassword;
+                       return S_OK;
+
+                       // abc321 code \/
+                    }
+                    // abc321 code /\~
+
+                 }
+              }
+           }
+           else if (pkAesMode)
+           {
+              isFullStreamExpected = false;
+              result = _pkAesDecoder->ReadHeader(inStream, item.Crc, item.Size);
+              if (result == S_OK)
+              {
+                 bool passwOK;
+                 result = _pkAesDecoder->Init_and_CheckPassword(passwOK);
+                 if (result == S_OK && !passwOK)
+                 {
+                    // abc321 code \/
+                    // this part of code has not been tested yet
+                    if (getNextPassword)
+                    {
+                       //RINOK(getNextPassword->CryptoGetNextPassword(&password))
+                       if (getNextPassword->CryptoGetNextPassword(&password) == S_OK) {
+                          if (password && (&password != NULL) && (wcslen(&password[0]) > 0))
+                             passwordTested = false;
+                       }
+                    }
+                    if (passwordTested) {
+                       // abc321 code /\~
+                                           
+                       res = NExtract::NOperationResult::kWrongPassword;
+                       return S_OK;
+
+                    // abc321 code \/
+                    }
+                    // abc321 code /\~
+                                     
+                 }
+              }
+           }
+           else
+           {
+              result = _zipCryptoDecoder->ReadHeader(inStream);
+              if (result == S_OK)
+              {
+                 _zipCryptoDecoder->Init_BeforeDecode();
+
+                 /* Info-ZIP modification to ZipCrypto format:
+                     if bit 3 of the general purpose bit flag is set,
+                     it uses high byte of 16-bit File Time.
+                   Info-ZIP code probably writes 2 bytes of File Time.
+                   We check only 1 byte. */
+
+                   // UInt32 v1 = GetUi16(_zipCryptoDecoder->_header + NCrypto::NZip::kHeaderSize - 2);
+                   // UInt32 v2 = (item.HasDescriptor() ? (item.Time & 0xFFFF) : (item.Crc >> 16));
+
+                 Byte v1 = _zipCryptoDecoder->_header[NCrypto::NZip::kHeaderSize - 1];
+                 Byte v2 = (Byte)(item.HasDescriptor() ? (item.Time >> 8) : (item.Crc >> 24));
+
+                 // abc321 code \/
+                 if (v1 != v2) {
+                    if (getNextPassword)
+                    {
+                       //RINOK(getNextPassword->CryptoGetNextPassword(&password))
+                       if (getNextPassword->CryptoGetNextPassword(&password) == S_OK) {
+                          if (password && (&password != NULL) && (wcslen(&password[0]) > 0))
+                             passwordTested = false;
+                       }
+                    }
+                 }
+                 if (passwordTested)
+                    // abc321 code /\~
+
+                    if (v1 != v2)
+                    {
+                       res = NExtract::NOperationResult::kWrongPassword;
+                       return S_OK;
+                    }
+              }
+           }
+        }
+        // abc321 code \/
+
+        if (!passwordTested) {
+           AString_Wipe charPassword;
+           // abc321 - below is duplicated part of code from the above, need to set position of inStream to the beginning
+           {
+              UInt64 packSize = item.PackSize;
+              if (wzAesMode)
+              {
+                 if (packSize < NCrypto::NWzAes::kMacSize)
+                    return S_OK;
+                 packSize -= NCrypto::NWzAes::kMacSize;
+              }
+              RINOK(archive.GetItemStream(item, true, packStream))
+                 if (!packStream)
+                 {
+                    res = NExtract::NOperationResult::kUnavailable;
+                    return S_OK;
+                 }
+              inStream->SetStream(packStream);
+              inStream->Init(packSize);
+           }
+
+           // abc321 - below is duplicated part of code from the above, though some modifications present
+           CMyComPtr<ICryptoSetPassword> cryptoSetPassword;
+           RINOK(cryptoFilter.QueryInterface(IID_ICryptoSetPassword, &cryptoSetPassword))
+              if (!cryptoSetPassword)
+                 return E_FAIL;
+
+           //if (!getTextPassword)
+           //extractCallback->QueryInterface(IID_ICryptoGetTextPassword, (void **)&getTextPassword);
+
+           //extractCallback->QueryInterface(IID_ICryptoGetTextPassword, (void **)&getTextPassword); // by abc321
+
+           if (password && (&password != NULL) && (wcslen(&password[0]) > 0))
+           {
+#if 0 && defined(_WIN32)
+              // do we need UTF-8 passwords here ?
+              if (item.GetHostOS() == NFileHeader::NHostOS::kUnix // 24.05
+                                                     // || item.IsUtf8() // 22.00
+                 )
+              {
+                 // throw 1;
+                 ConvertUnicodeToUTF8((LPCOLESTR)password, charPassword);
+              }
+              else
+#endif
+              {
+                 UnicodeStringToMultiByte2(charPassword, (LPCOLESTR)password, CP_ACP);
+              }
+              /*
+              if (wzAesMode || pkAesMode)
+              {
+              }
+              else
+              {
+              // PASSWORD encoding for ZipCrypto:
+              // pkzip25 / WinZip / Windows probably use ANSI
+              // 7-Zip <  4.43 creates ZIP archives with OEM encoding in password
+              // 7-Zip >= 4.43 creates ZIP archives only with ASCII characters in password
+              // 7-Zip <  17.00 uses CP_OEMCP for password decoding
+              // 7-Zip >= 17.00 uses CP_ACP   for password decoding
+              }
+              */
+           }
+           //HRESULT
+           result =
+              cryptoSetPassword->CryptoSetPassword(
+              (const Byte *)(const char *)charPassword, charPassword.Len());
+           if (result != S_OK)
+           {
+              res = NExtract::NOperationResult::kWrongPassword;
+              return S_OK;
+           }
+
+        }
+
+
+     }
+
+     if (result == S_OK)
+     {
+        if (getNextPassword) {
+           RINOK(getNextPassword->CryptoPasswordValid())
+        }
+     }
+     // abc321 code /\~
 
     if (result == S_OK)
     {
diff --git a/CPP/7zip/IPassword.h b/CPP/7zip/IPassword.h
index f981b51..6683713 100644
--- a/CPP/7zip/IPassword.h
+++ b/CPP/7zip/IPassword.h
@@ -50,5 +50,12 @@ CryptoGetTextPassword2()
   x(CryptoGetTextPassword2(Int32 *passwordIsDefined, BSTR *password))
 Z7_IFACE_CONSTR_PASSWORD(ICryptoGetTextPassword2, 0x11)
 
+// by abc321 \/
+#define Z7_IFACEM_ICryptoGetNextPassword(x) \
+  x(CryptoGetNextPassword(BSTR *password)) \
+  x(CryptoPasswordValid())
+Z7_IFACE_CONSTR_PASSWORD(ICryptoGetNextPassword, 0x12)
+// by abc321 /\~
+
 Z7_PURE_INTERFACES_END
 #endif
diff --git a/CPP/7zip/UI/Common/ArchiveCommandLine.cpp b/CPP/7zip/UI/Common/ArchiveCommandLine.cpp
index 45baca5..9bcfcec 100644
--- a/CPP/7zip/UI/Common/ArchiveCommandLine.cpp
+++ b/CPP/7zip/UI/Common/ArchiveCommandLine.cpp
@@ -180,7 +180,8 @@ enum Enum
 
   #ifndef Z7_NO_CRYPTO
   , kPassword
+  , kPasswordFile // by abc321
   , kEncKey
   #endif
 
  , kExtrOffsLen
@@ -331,6 +332,7 @@ static const CSwitchForm kSwitchForms[] =
 
   #ifndef Z7_NO_CRYPTO
   , { "p", SWFRM_STRING }
+  , { "fp", SWFRM_STRING }
   , { "ekey", SWFRM_STRING }
   #endif
 
@@ -1430,6 +1432,11 @@ void CArcCmdLineParser::Parse2(CArcCmdLineOptions &options)
       }
     }
   }
+  // by abc321 \/
+  options.PasswordFileEnabled = parser[NKey::kPasswordFile].ThereIs;
+  if (options.PasswordFileEnabled)
+     options.PasswordFile = parser[NKey::kPasswordFile].PostStrings[0];
+  // by abc321 /\~
   #endif
 
   if (parser[NKey::kExtrOffsLen].ThereIs) {
diff --git a/CPP/7zip/UI/Common/ArchiveCommandLine.h b/CPP/7zip/UI/Common/ArchiveCommandLine.h
index 439ee70..1059b85 100644
--- a/CPP/7zip/UI/Common/ArchiveCommandLine.h
+++ b/CPP/7zip/UI/Common/ArchiveCommandLine.h
@@ -89,7 +89,9 @@ struct CArcCmdLineOptions
   #ifndef Z7_NO_CRYPTO
   bool PasswordEnabled;
   UString Password; // Wipe
-  #endif
+  bool PasswordFileEnabled; // by abc321
+  UString PasswordFile; // by abc321
+#endif
 
   UStringVector HashMethods;
   // UString HashFilePath;
diff --git a/CPP/7zip/UI/Common/ArchiveExtractCallback.cpp b/CPP/7zip/UI/Common/ArchiveExtractCallback.cpp
index 4815f4b..23d3083 100644
--- a/CPP/7zip/UI/Common/ArchiveExtractCallback.cpp
+++ b/CPP/7zip/UI/Common/ArchiveExtractCallback.cpp
@@ -2480,5 +2480,31 @@ Z7_COM7F_IMF(CArchiveExtractCallback::CryptoGetTextPassword(BSTR *password))
   COM_TRY_END
 }
+ 
+// by abc321 \/
+Z7_COM7F_IMF(CArchiveExtractCallback::CryptoGetNextPassword(BSTR *password))
+{
+   COM_TRY_BEGIN
+   if (!_cryptoGetNextPassword)
+   {
+      RINOK(_extractCallback2.QueryInterface(IID_ICryptoGetNextPassword,
+         &_cryptoGetNextPassword))
+   }
+   return _cryptoGetNextPassword->CryptoGetNextPassword(password);
+   COM_TRY_END
+}
+
+Z7_COM7F_IMF(CArchiveExtractCallback::CryptoPasswordValid())
+{
+   COM_TRY_BEGIN
+   if (!_cryptoGetNextPassword)
+   {
+      RINOK(_extractCallback2.QueryInterface(IID_ICryptoGetNextPassword,
+         &_cryptoGetNextPassword))
+   }
+   return _cryptoGetNextPassword->CryptoPasswordValid();
+   COM_TRY_END
+}
+// by abc321 /\~
 
 #ifndef Z7_SFX
 
diff --git a/CPP/7zip/UI/Common/ArchiveExtractCallback.h b/CPP/7zip/UI/Common/ArchiveExtractCallback.h
index 969b56a..d72875e 100644
--- a/CPP/7zip/UI/Common/ArchiveExtractCallback.h
+++ b/CPP/7zip/UI/Common/ArchiveExtractCallback.h
@@ -251,6 +251,7 @@ class CArchiveExtractCallback Z7_final:
   public IArchiveExtractCallback,
   public IArchiveExtractCallbackMessage2,
   public ICryptoGetTextPassword,
+  public ICryptoGetNextPassword, // by abc321
   public ICompressProgressInfo,
 #ifndef Z7_SFX
   public IArchiveUpdateCallbackFile,
@@ -262,6 +263,7 @@ class CArchiveExtractCallback Z7_final:
   /* IArchiveExtractCallback, */
   Z7_COM_QI_BEGIN2(IArchiveExtractCallbackMessage2)
   Z7_COM_QI_ENTRY(ICryptoGetTextPassword)
+  Z7_COM_QI_ENTRY(ICryptoGetNextPassword) // by abc321
   Z7_COM_QI_ENTRY(ICompressProgressInfo)
 #ifndef Z7_SFX
   Z7_COM_QI_ENTRY(IArchiveUpdateCallbackFile)
@@ -275,6 +277,7 @@ class CArchiveExtractCallback Z7_final:
   Z7_IFACE_COM7_IMP(IArchiveExtractCallback)
   Z7_IFACE_COM7_IMP(IArchiveExtractCallbackMessage2)
   Z7_IFACE_COM7_IMP(ICryptoGetTextPassword)
+  Z7_IFACE_COM7_IMP(ICryptoGetNextPassword) // by abc321
   Z7_IFACE_COM7_IMP(ICompressProgressInfo)
 #ifndef Z7_SFX
   Z7_IFACE_COM7_IMP(IArchiveUpdateCallbackFile)
@@ -326,6 +329,7 @@ class CArchiveExtractCallback Z7_final:
   // CMyComPtr<IArchiveExtractCallbackMessage2> _callbackMessage;
   CMyComPtr<IFolderArchiveExtractCallback2> _folderArchiveExtractCallback2;
   CMyComPtr<ICryptoGetTextPassword> _cryptoGetTextPassword;
+  CMyComPtr<ICryptoGetNextPassword> _cryptoGetNextPassword; // by abc321
 
   FString _dirPathPrefix;
 public:
diff --git a/CPP/7zip/UI/Common/ArchiveOpenCallback.cpp b/CPP/7zip/UI/Common/ArchiveOpenCallback.cpp
index 882a58b..42f5acc 100644
--- a/CPP/7zip/UI/Common/ArchiveOpenCallback.cpp
+++ b/CPP/7zip/UI/Common/ArchiveOpenCallback.cpp
@@ -384,7 +384,43 @@ Z7_COM7F_IMF(COpenCallbackImp::CryptoGetTextPassword(BSTR *password))
   return Callback->Open_CryptoGetTextPassword(password);
   COM_TRY_END
 }
 
+// by abc321 \/
+Z7_COM7F_IMF(COpenCallbackImp::CryptoGetNextPassword(BSTR *password))
+{
+   COM_TRY_BEGIN
+      if (ReOpenCallback)
+      {
+         Z7_DECL_CMyComPtr_QI_FROM(
+            ICryptoGetNextPassword,
+            getNextPassword, ReOpenCallback)
+            if (getNextPassword)
+               return getNextPassword->CryptoGetNextPassword(password);
+      }
+   if (!Callback)
+      return E_NOTIMPL;
+   PasswordWasAsked = true;
+   return Callback->Open_CryptoGetNextPassword(password);
+   COM_TRY_END
+}
+
+Z7_COM7F_IMF(COpenCallbackImp::CryptoPasswordValid())
+{
+   COM_TRY_BEGIN
+      if (ReOpenCallback)
+      {
+         Z7_DECL_CMyComPtr_QI_FROM(
+            ICryptoGetNextPassword,
+            getNextPassword, ReOpenCallback)
+            if (getNextPassword)
+               return getNextPassword->CryptoPasswordValid();
+      }
+   if (!Callback)
+      return E_NOTIMPL;
+   return Callback->Print_CryptoPasswordValid();
+   COM_TRY_END
+}
+// by abc321 /\~
 Z7_COM7F_IMF(COpenCallbackImp::CryptoGetPasswordIfAny(bool& passwordIsDefined, UString& password))
 {
   COM_TRY_BEGIN
diff --git a/CPP/7zip/UI/Common/ArchiveOpenCallback.h b/CPP/7zip/UI/Common/ArchiveOpenCallback.h
index b589c42..c3cab20 100644
--- a/CPP/7zip/UI/Common/ArchiveOpenCallback.h
+++ b/CPP/7zip/UI/Common/ArchiveOpenCallback.h
@@ -24,6 +24,8 @@ Z7_PURE_INTERFACES_BEGIN
 
 #define Z7_IFACEM_IOpenCallbackUI_Crypto(x) \
   virtual HRESULT Open_CryptoGetTextPassword(BSTR *password) x \
+  virtual HRESULT Open_CryptoGetNextPassword(BSTR *password) x /* by abc321*/ \
+  virtual HRESULT Print_CryptoPasswordValid() x /* by abc321*/ \
   virtual HRESULT Open_GetPasswordIfAny(bool &passwordIsDefined, UString &password) x \
   /* virtual bool Open_WasPasswordAsked() x */ \
   /* virtual void Open_Clear_PasswordWasAsked_Flag() x */  \
@@ -100,7 +102,8 @@ class COpenCallbackImp Z7_final:
   public IArchiveOpenSetSubArchiveName,
  #ifndef Z7_NO_CRYPTO
   public ICryptoGetTextPassword,
- #endif
+  public ICryptoGetNextPassword, // by abc321
+#endif
   public IProgress, // IProgress is used for 7zFM
   public CMyUnknownImp
 {
@@ -109,7 +112,8 @@ class COpenCallbackImp Z7_final:
   Z7_COM_QI_ENTRY(IArchiveOpenSetSubArchiveName)
  #ifndef Z7_NO_CRYPTO
   Z7_COM_QI_ENTRY(ICryptoGetTextPassword)
- #endif
+  Z7_COM_QI_ENTRY(ICryptoGetNextPassword) // by abc321
+#endif
   // Z7_COM_QI_ENTRY(IProgress) // the code doesn't require it
   Z7_COM_QI_END
   Z7_COM_ADDREF_RELEASE
@@ -122,7 +126,8 @@ class COpenCallbackImp Z7_final:
 private:
  #ifndef Z7_NO_CRYPTO
   Z7_IFACE_COM7_IMP(ICryptoGetTextPassword)
- #endif
+  Z7_IFACE_COM7_IMP(ICryptoGetNextPassword) // by abc321
+#endif
 
   bool _subArchiveMode;
 
diff --git a/CPP/7zip/UI/Common/UpdateCallback.h b/CPP/7zip/UI/Common/UpdateCallback.h
index 1987aeb..7bd21f3 100644
--- a/CPP/7zip/UI/Common/UpdateCallback.h
+++ b/CPP/7zip/UI/Common/UpdateCallback.h
@@ -47,6 +47,8 @@ Z7_PURE_INTERFACES_BEGIN
   /* virtual HRESULT SetPassword(const UString &password) x */ \
   virtual HRESULT CryptoGetTextPassword2(Int32 *passwordIsDefined, BSTR *password) x \
   virtual HRESULT CryptoGetTextPassword(BSTR *password) x \
+  virtual HRESULT CryptoGetNextPassword(BSTR *password) x /* by abc321 */ \
+  virtual HRESULT CryptoPasswordValid() x /* by abc321 */ \
   virtual HRESULT CryptoGetPasswordIfAny(bool& passwordIsDefined, UString& password) x \
   virtual HRESULT ShowDeleteFile(const wchar_t *name, bool isDir) x \
 
@@ -84,19 +86,23 @@ class CArchiveUpdateCallback Z7_final:
   public IArchiveGetRootProps,
   public ICryptoGetTextPassword2,
   public ICryptoGetTextPassword,
+  //public ICryptoGetNextPassword, // by abc321
+  //public ICryptoPasswordValid, // by abc321
   public ICompressProgressInfo,
   public IInFileStream_Callback,
   public CMyUnknownImp
 {
   Z7_COM_QI_BEGIN2(IArchiveUpdateCallback2)
-    Z7_COM_QI_ENTRY(IArchiveUpdateCallbackFile)
-    // Z7_COM_QI_ENTRY(IArchiveUpdateCallbackArcProp)
-    Z7_COM_QI_ENTRY(IArchiveExtractCallbackMessage2)
-    Z7_COM_QI_ENTRY(IArchiveGetRawProps)
-    Z7_COM_QI_ENTRY(IArchiveGetRootProps)
-    Z7_COM_QI_ENTRY(ICryptoGetTextPassword2)
-    Z7_COM_QI_ENTRY(ICryptoGetTextPassword)
-    Z7_COM_QI_ENTRY(ICompressProgressInfo)
+  Z7_COM_QI_ENTRY(IArchiveUpdateCallbackFile)
+  // Z7_COM_QI_ENTRY(IArchiveUpdateCallbackArcProp)
+  Z7_COM_QI_ENTRY(IArchiveExtractCallbackMessage2)
+  Z7_COM_QI_ENTRY(IArchiveGetRawProps)
+  Z7_COM_QI_ENTRY(IArchiveGetRootProps)
+  Z7_COM_QI_ENTRY(ICryptoGetTextPassword2)
+  Z7_COM_QI_ENTRY(ICryptoGetTextPassword)
+  //Z7_COM_QI_ENTRY(ICryptoGetNextPassword) // by abc321
+  //Z7_COM_QI_ENTRY(ICryptoPasswordValid) // by abc321
+  Z7_COM_QI_ENTRY(ICompressProgressInfo)
   Z7_COM_QI_END
   Z7_COM_ADDREF_RELEASE
 
@@ -112,7 +118,8 @@ class CArchiveUpdateCallback Z7_final:
   Z7_IFACE_COM7_IMP(IArchiveGetRootProps)
   Z7_IFACE_COM7_IMP(ICryptoGetTextPassword2)
   Z7_IFACE_COM7_IMP(ICryptoGetTextPassword)
-
+  //Z7_IFACE_COM7_IMP(ICryptoGetNextPassword) // by abc321
+  //Z7_IFACE_COM7_IMP(ICryptoPasswordValid) // by abc321
 
   void UpdateProcessedItemStatus(unsigned dirIndex);
 
diff --git a/CPP/7zip/UI/Console/ExtractCallbackConsole.cpp b/CPP/7zip/UI/Console/ExtractCallbackConsole.cpp
index fddbc1b..c284c59 100644
--- a/CPP/7zip/UI/Console/ExtractCallbackConsole.cpp
+++ b/CPP/7zip/UI/Console/ExtractCallbackConsole.cpp
@@ -531,6 +531,24 @@ Z7_COM7F_IMF(CExtractCallbackConsole::CryptoGetTextPassword(BSTR *password))
   COM_TRY_END
 }
 
+// by abc321 \/
+Z7_COM7F_IMF(CExtractCallbackConsole::CryptoGetNextPassword(BSTR *password))
+{
+   COM_TRY_BEGIN
+   MT_LOCK
+   return Open_CryptoGetNextPassword(password);
+   COM_TRY_END
+}
+
+Z7_COM7F_IMF(CExtractCallbackConsole::CryptoPasswordValid())
+{
+   ClosePercents_for_so();
+   COM_TRY_BEGIN
+   MT_LOCK
+   return Print_CryptoPasswordValid();
+   COM_TRY_END
+}
+// by abc321 /\~
 #endif
 
 
diff --git a/CPP/7zip/UI/Console/ExtractCallbackConsole.h b/CPP/7zip/UI/Console/ExtractCallbackConsole.h
index 4c26939..91f4e04 100644
--- a/CPP/7zip/UI/Console/ExtractCallbackConsole.h
+++ b/CPP/7zip/UI/Console/ExtractCallbackConsole.h
@@ -91,6 +91,7 @@ class CExtractCallbackConsole Z7_final:
   public IFolderArchiveExtractCallback2,
  #ifndef Z7_NO_CRYPTO
   public ICryptoGetTextPassword,
+  public ICryptoGetNextPassword, // by abc321
  #endif
  #ifndef Z7_SFX
   public IArchiveRequestMemoryUseCallback,
@@ -104,6 +105,7 @@ class CExtractCallbackConsole Z7_final:
   Z7_COM_QI_ENTRY(IFolderArchiveExtractCallback2)
  #ifndef Z7_NO_CRYPTO
   Z7_COM_QI_ENTRY(ICryptoGetTextPassword)
+  Z7_COM_QI_ENTRY(ICryptoGetNextPassword) // by abc321
  #endif
  #ifndef Z7_SFX
   Z7_COM_QI_ENTRY(IArchiveRequestMemoryUseCallback)
@@ -119,6 +121,7 @@ class CExtractCallbackConsole Z7_final:
   Z7_IFACE_COM7_IMP(IFolderArchiveExtractCallback2)
  #ifndef Z7_NO_CRYPTO
   Z7_IFACE_COM7_IMP(ICryptoGetTextPassword)
+  Z7_IFACE_COM7_IMP(ICryptoGetNextPassword) // by abc321
  #endif
  #ifndef Z7_SFX
   Z7_IFACE_COM7_IMP(IArchiveRequestMemoryUseCallback)
diff --git a/CPP/7zip/UI/Console/Main.cpp b/CPP/7zip/UI/Console/Main.cpp
index 4fa5c35..6faffdf 100644
--- a/CPP/7zip/UI/Console/Main.cpp
+++ b/CPP/7zip/UI/Console/Main.cpp
@@ -163,7 +163,8 @@ static const char * const kHelpString =
     "  -o{Directory} : set Output directory\n"
     #ifndef Z7_NO_CRYPTO
     "  -p{Password} : set Password\n"
-    #endif
+   "  -fp{FileWithPassword[s]} : set FileWithPassword[s]\n" // by abc321
+#endif
     "  -r[-|0] : Recurse subdirectories for name search\n"
     "  -sa{a|e|s} : set Archive name mode\n"
     "  -scc{UTF-8|WIN|DOS} : set charset for console input/output\n"
@@ -1327,8 +1328,90 @@ int Main2(
       CExtractCallbackConsole *ecs = new CExtractCallbackConsole;
       CMyComPtr<IFolderArchiveExtractCallback> extractCallback = ecs;
 
+     // by abc321 \/
+      #ifndef Z7_NO_CRYPTO
+     if (options.PasswordFileEnabled) {
+        HRESULT res;
+        CExtractScanConsole scan;
+        scan.Init(options.EnableHeaders ? g_StdStream : NULL,
+           g_ErrStream, percentsStream,
+           options.DisablePercents);
+        scan.SetWindowWidth(consoleWidth);
+
+        if (g_StdStream && options.EnableHeaders)
+           *g_StdStream << "Scanning the drive for file with passwords:" << endl;
+
+        scan.StartScanning();
+
+        FStringVector paths;
+        UStringVector fullPaths;
+        CDirItemsStat st;
+        {
+           CDirItems dirItems;
+           dirItems.Callback = &scan; // NULL;
+
+           {
+              NWildcard::CCensor arcCensor;
+              arcCensor.AddPreItem_NoWildcard(options.PasswordFile);
+              arcCensor.AddPathsToCensor(NWildcard::k_RelatPath);
+
+              res = EnumerateItems(
+                 arcCensor,
+                 NWildcard::k_RelatPath,
+                 UString(), // addPathPrefix
+                 dirItems
+              );
+              st = dirItems.Stat;
+              //RINOK(res)
+           }
+
+           FOR_VECTOR(i, dirItems.Items)
+           {
+              const CDirItem &dirItem = dirItems.Items[i];
+              if (!dirItem.IsDir())
+                 paths.Add(dirItems.GetPhyPath(i));
+           }
+        }
+
+        if (paths.Size() > 0) {
+           unsigned i;
+
+           for (i = 0; i < paths.Size(); i++)
+           {
+              FString fullPath;
+              NFile::NDir::MyGetFullPathName(paths[i], fullPath);
+              fullPaths.Add(fs2us(fullPath));
+           }
+        }
+
+        scan.CloseScanning();
+        if (res == S_OK)
+        {
+           if (fullPaths.Size() > 0) {
+              if (options.EnableHeaders)
+                 scan.PrintStat(st);
+           }
+
+           options.PasswordFile = fullPaths[0];
+           ecs->PasswordReader = new CPasswordReader(options.PasswordFile);
+           if (!options.PasswordEnabled) {
+              ecs->PasswordReader->GetNextPassword(&options.Password);
+              if (wcslen(options.Password) > 0) {
+                 options.PasswordEnabled = true;
+                 ecs->PasswordBruteforced = true;
+              }
+           }
+        }
+        else {
+           options.PasswordFileEnabled = false;
+           options.PasswordFile = "";
+        }
+     }
+      #endif
+     // by abc321 /\~
+
       #ifndef Z7_NO_CRYPTO
-      ecs->PasswordIsDefined = options.PasswordEnabled;
+     ecs->PasswordIsDefined = options.PasswordEnabled;
       ecs->Password = options.Password;
       #endif
 
diff --git a/CPP/7zip/UI/Console/MainAr.cpp b/CPP/7zip/UI/Console/MainAr.cpp
index 8cc3cac..fbc89d6 100644
--- a/CPP/7zip/UI/Console/MainAr.cpp
+++ b/CPP/7zip/UI/Console/MainAr.cpp
@@ -147,7 +147,7 @@ int Z7_CDECL main
 */
   catch(const CMessagePathException &e)
   {
-    PrintError(kException_CmdLine_Error_Message);
+     PrintError(kException_CmdLine_Error_Message);
     if (g_ErrStream)
       *g_ErrStream << e << endl;
     return (NExitCode::kUserError);
diff --git a/CPP/7zip/UI/Console/OpenCallbackConsole.cpp b/CPP/7zip/UI/Console/OpenCallbackConsole.cpp
index 12b3483..277410d 100644
--- a/CPP/7zip/UI/Console/OpenCallbackConsole.cpp
+++ b/CPP/7zip/UI/Console/OpenCallbackConsole.cpp
@@ -93,6 +93,42 @@ HRESULT COpenCallbackConsole::Open_CryptoGetTextPassword(BSTR *password)
   return StringToBstr(Password, password);
 }
 
+// by abc321 \/
+HRESULT COpenCallbackConsole::Open_CryptoGetNextPassword(BSTR *password)
+{
+   *password = NULL;
+   RINOK(CheckBreak2())
+
+   if (PasswordReader) {
+      ClosePercents();
+      Password = "";
+      PasswordBruteforced = false;
+      //RINOK(PasswordReader->GetNextPassword(&Password));
+      if (PasswordReader->GetNextPassword(&Password) == S_OK) {
+         if (wcslen(Password) > 0)
+            PasswordBruteforced = true;
+         return StringToBstr(Password, password);
+      }
+   }
+
+   return S_FALSE;
+}
+
+HRESULT COpenCallbackConsole::Print_CryptoPasswordValid()
+{
+   RINOK(CheckBreak2())
+
+      if (PasswordReader) {
+         if (_so && PasswordBruteforced && !PasswordPrinted && wcslen(Password) > 0) {
+            // Encoding to CP866 should implemented if needed
+            *_so << "Password '" << Password << "' is valid for archive" << endl;
+            PasswordPrinted = true;
+         }
+      }
+
+   return S_OK;
+}
+// by abc321 /\~
 
 HRESULT COpenCallbackConsole::Open_GetPasswordIfAny(bool &passwordIsDefined, UString &password)
 {
diff --git a/CPP/7zip/UI/Console/OpenCallbackConsole.h b/CPP/7zip/UI/Console/OpenCallbackConsole.h
index 0afdabc..7fc9eb8 100644
--- a/CPP/7zip/UI/Console/OpenCallbackConsole.h
+++ b/CPP/7zip/UI/Console/OpenCallbackConsole.h
@@ -1,4 +1,4 @@
-// OpenCallbackConsole.h
+// OpenCallbackConsole.h
 
 #ifndef ZIP7_INC_OPEN_CALLBACK_CONSOLE_H
 #define ZIP7_INC_OPEN_CALLBACK_CONSOLE_H
@@ -9,6 +9,140 @@
 
 #include "PercentPrinter.h"
 
+// by abc321 \/
+#ifndef Z7_NO_CRYPTO
+// by abc321 /\~
+
+#include <iostream>
+#include <fstream>
+#include <string>
+
+// by abc321 \/
+#include <locale>
+#include <codecvt>
+#include <cstdlib>
+
+class CPasswordReader
+{
+private:
+#ifndef Z7_ASCII_PASSWORD_FILE
+   std::wifstream PasswordFile;
+#else
+   std::ifstream PasswordFile;  // ASCII file
+   //std::basic_ifstream<char32_t> PasswordFile;
+#endif
+public:
+   CPasswordReader(UString PasswordFileName) {
+#ifndef Z7_ASCII_PASSWORD_FILE
+#ifdef _MSC_VER
+      const std::locale empty_locale = std::locale::empty();
+#else
+      const std::locale empty_locale = std::locale();
+#endif
+      typedef std::codecvt_utf8_utf16<wchar_t> converter_type;
+      const converter_type* converter = new converter_type;
+      const std::locale utf8_utf16_locale = std::locale(empty_locale, converter);
+#ifdef _MSC_VER
+      PasswordFile.open(PasswordFileName);
+#else
+      std::wstring wFileName(PasswordFileName);
+      std::string fileName(wFileName.begin(), wFileName.end());
+      PasswordFile.open(fileName);
+#endif
+      if (PasswordFile.is_open())
+         PasswordFile.imbue(utf8_utf16_locale);
+#else
+      PasswordFile.open(PasswordFileName); // ASCII file
+      //PasswordFile.open(PasswordFileName, std::ios::in | std::ios::binary);
+#endif
+   }
+
+   ~CPasswordReader() {
+      if (PasswordFile)
+         if (PasswordFile.is_open())
+            PasswordFile.close();
+   }
+
+   HRESULT GetNextPassword(UString *Password) {
+#ifndef Z7_ASCII_PASSWORD_FILE
+      /*if (auto f = std::wofstream(L"C:\\Users\\ADMINI~1.YSE\\DOCUME~1\\VISUAL~1\\Projects\\7Z2407~1\\_test\\125.txt")) {
+         f.imbue(std::locale(std::locale(),
+            new std::codecvt_utf8_utf16<wchar_t>)); // assumes wchar_t is UTF-16
+         f << L" \n";
+         f << L"/\n";
+      }*/
+
+      std::wstring line;
+      *Password = "";
+      if (PasswordFile.is_open()) {
+         unsigned i = 0;
+         while (i == 0) {
+            if (std::getline(PasswordFile, line)) {
+               for (i = 0; ((line[i] != 0) && (line[i] != U'\r')); i++);
+               if ((i > 0) && (line[i] == U'\r')) {
+                  line[i] = 0;
+                  i--;
+               }
+               if (i > 0) {
+                  wchar_t  *ws = &line[0]; // line.c_str();
+                  *Password = ws;
+               }
+
+            }
+            else {
+#ifdef _MSC_VER
+               return ERROR_END_OF_MEDIA;
+#else
+               return SZ_ERROR_FAIL;
+#endif
+            }
+         }
+      }
+      else {
+#ifdef _MSC_VER
+         return ERROR_FILE_INVALID;
+#else
+         return ERROR_FILE_NOT_FOUND;
+#endif
+      }
+      return S_OK;
+#else
+      std::string line;
+      //std::u32string line{};
+      char buffer[2500];
+      *Password = "";
+      if (PasswordFile.is_open()) {
+         int i = 0;
+         while (i == 0) {
+            if (PasswordFile.getline(buffer, sizeof(buffer), U'\n')) {
+               for (i = 0; (i < sizeof(buffer)) && (buffer[i] != 0) && (buffer[i] != U'\r'); i++) {}
+               if (i > 0) {
+                  *Password = buffer;
+               }
+            }
+            else {
+#ifdef _MSC_VER
+               return ERROR_END_OF_MEDIA;
+#else
+               return SZ_ERROR_FAIL;
+#endif
+            }
+         }
+      }
+      else {
+#ifdef _MSC_VER
+         return ERROR_FILE_INVALID;
+#else
+         return ERROR_FILE_NOT_FOUND;
+#endif
+      }
+      return S_OK;
+#endif
+   };
+};
+#endif
+// by abc321 /\~
+
 class COpenCallbackConsole: public IOpenCallbackUI
 {
 protected:
@@ -43,6 +177,9 @@ class COpenCallbackConsole: public IOpenCallbackUI
       #ifndef Z7_NO_CRYPTO
       , PasswordIsDefined(false)
       // , PasswordWasAsked(false)
+     , PasswordReader(NULL) // by abc321
+     , PasswordBruteforced(false) // by abc321
+     , PasswordPrinted(false) // by abc321
       #endif
       
       {}
@@ -67,6 +204,9 @@ class COpenCallbackConsole: public IOpenCallbackUI
   bool PasswordIsDefined;
   // bool PasswordWasAsked;
   UString Password;
+  CPasswordReader *PasswordReader; // by abc321
+  bool PasswordBruteforced; // by abc321
+  bool PasswordPrinted; // by abc321
   #endif
 };
 
diff --git a/CPP/7zip/UI/Console/UpdateCallbackConsole.cpp b/CPP/7zip/UI/Console/UpdateCallbackConsole.cpp
index 4d7dbe6..474a612 100644
--- a/CPP/7zip/UI/Console/UpdateCallbackConsole.cpp
+++ b/CPP/7zip/UI/Console/UpdateCallbackConsole.cpp
@@ -754,6 +754,49 @@ HRESULT CUpdateCallbackConsole::CryptoGetTextPassword(BSTR *password)
   COM_TRY_END
 }
 
+// by abc321 \/
+HRESULT CUpdateCallbackConsole::CryptoGetNextPassword(BSTR *password)
+{
+   COM_TRY_BEGIN
+
+   *password = NULL;
+
+#ifdef Z7_NO_CRYPTO
+
+   return E_NOTIMPL;
+
+#else
+
+   if (!PasswordIsDefined)
+   {
+      {
+         RINOK(GetPassword_HRESULT(_so, Password))
+         PasswordIsDefined = true;
+      }
+   }
+   return StringToBstr(Password, password);
+
+#endif
+   COM_TRY_END
+}
+
+HRESULT CUpdateCallbackConsole::CryptoPasswordValid()
+{
+   COM_TRY_BEGIN
+
+#ifdef Z7_NO_CRYPTO
+
+   return E_NOTIMPL;
+
+#else
+
+   return S_OK;
+
+#endif
+   COM_TRY_END
+}
+// by abc321 /\~
+
 HRESULT CUpdateCallbackConsole::ShowDeleteFile(const wchar_t *name, bool isDir)
 {
   if (StdOutMode)
