From 290476992a05e87b24bdeef2abe28980b1041d1e Mon Sep 17 00:00:00 2001
From: ironyman <ironyman13@gmail.com>
Date: Thu, 4 Jan 2024 01:57:41 -0800
Subject: [PATCH] Add Ctrl F to fzf

---
 .vscode/launch.json                    |   1 +
 .vscode/settings.json                  |  72 ++++-
 CPP/7zip/UI/FileManager/App.h          |   5 +
 CPP/7zip/UI/FileManager/FM.cpp         |   6 +
 CPP/7zip/UI/FileManager/FM.mak         |   2 +-
 CPP/7zip/UI/FileManager/MultiPanel.cpp |  20 +-
 CPP/7zip/UI/FileManager/Panel.cpp      |   5 +
 CPP/7zip/UI/FileManager/Panel.h        |   1 +
 CPP/7zip/UI/FileManager/PanelKey.cpp   |  47 +++
 CPP/Common/MyString.h                  |  32 ++
 CPP/Common/MyVector.h                  |  11 +
 CPP/Windows/ProcessUtils.cpp           | 400 ++++++++++++++++++++++++-
 CPP/Windows/ProcessUtils.h             |  49 ++-
 13 files changed, 618 insertions(+), 33 deletions(-)

diff --git a/.vscode/launch.json b/.vscode/launch.json
index 955e766..8b1a481 100644
--- a/.vscode/launch.json
+++ b/.vscode/launch.json
@@ -14,6 +14,7 @@
             "preLaunchTask": "build 7zfm"
         },
         {
+            // $err in debug console to gle
             "name": "(Windows) Launch",
             "type": "cppvsdbg",
             "request": "launch",
diff --git a/.vscode/settings.json b/.vscode/settings.json
index b20858e..a6401b5 100644
--- a/.vscode/settings.json
+++ b/.vscode/settings.json
@@ -38,6 +38,76 @@
     },
     "files.associations": {
         "xstring": "cpp",
-        "xtr1common": "cpp"
+        "xtr1common": "cpp",
+        "algorithm": "cpp",
+        "array": "cpp",
+        "atomic": "cpp",
+        "bit": "cpp",
+        "bitset": "cpp",
+        "cctype": "cpp",
+        "charconv": "cpp",
+        "clocale": "cpp",
+        "cmath": "cpp",
+        "compare": "cpp",
+        "concepts": "cpp",
+        "cstddef": "cpp",
+        "cstdint": "cpp",
+        "cstdio": "cpp",
+        "cstdlib": "cpp",
+        "cstring": "cpp",
+        "ctime": "cpp",
+        "cwchar": "cpp",
+        "deque": "cpp",
+        "exception": "cpp",
+        "format": "cpp",
+        "fstream": "cpp",
+        "functional": "cpp",
+        "initializer_list": "cpp",
+        "ios": "cpp",
+        "iosfwd": "cpp",
+        "iostream": "cpp",
+        "istream": "cpp",
+        "iterator": "cpp",
+        "limits": "cpp",
+        "list": "cpp",
+        "locale": "cpp",
+        "map": "cpp",
+        "memory": "cpp",
+        "new": "cpp",
+        "numeric": "cpp",
+        "optional": "cpp",
+        "ostream": "cpp",
+        "queue": "cpp",
+        "ranges": "cpp",
+        "ratio": "cpp",
+        "set": "cpp",
+        "span": "cpp",
+        "sstream": "cpp",
+        "stack": "cpp",
+        "stdexcept": "cpp",
+        "stop_token": "cpp",
+        "streambuf": "cpp",
+        "string": "cpp",
+        "system_error": "cpp",
+        "thread": "cpp",
+        "tuple": "cpp",
+        "type_traits": "cpp",
+        "typeinfo": "cpp",
+        "unordered_map": "cpp",
+        "utility": "cpp",
+        "vector": "cpp",
+        "xfacet": "cpp",
+        "xhash": "cpp",
+        "xiosbase": "cpp",
+        "xlocale": "cpp",
+        "xlocbuf": "cpp",
+        "xlocinfo": "cpp",
+        "xlocmes": "cpp",
+        "xlocmon": "cpp",
+        "xlocnum": "cpp",
+        "xloctime": "cpp",
+        "xmemory": "cpp",
+        "xtree": "cpp",
+        "xutility": "cpp"
     }
 }
\ No newline at end of file
diff --git a/CPP/7zip/UI/FileManager/App.h b/CPP/7zip/UI/FileManager/App.h
index 35cb403..f10a696 100644
--- a/CPP/7zip/UI/FileManager/App.h
+++ b/CPP/7zip/UI/FileManager/App.h
@@ -321,4 +321,9 @@ class CApp
   HRESULT SyncMultiPanel();
 };
 
+
+enum MyAppMessages
+{
+  kOpenPath = WM_USER + 1,
+};
 #endif
diff --git a/CPP/7zip/UI/FileManager/FM.cpp b/CPP/7zip/UI/FileManager/FM.cpp
index 6ab6219..f2b636c 100644
--- a/CPP/7zip/UI/FileManager/FM.cpp
+++ b/CPP/7zip/UI/FileManager/FM.cpp
@@ -1049,6 +1049,12 @@ LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
       break;
     }
 
+    case kOpenPath:
+    {
+      UString *path = reinterpret_cast<UString *>(wParam);
+      g_App.Panels[g_App.LastFocusedPanel].NavigatePath(*path);
+      break;
+    }
     /*
     case WM_DROPFILES:
     {
diff --git a/CPP/7zip/UI/FileManager/FM.mak b/CPP/7zip/UI/FileManager/FM.mak
index 5e8675a..6d293e2 100644
--- a/CPP/7zip/UI/FileManager/FM.mak
+++ b/CPP/7zip/UI/FileManager/FM.mak
@@ -4,7 +4,7 @@ CFLAGS = $(CFLAGS) \
 !IFDEF UNDER_CE
 LIBS = $(LIBS) ceshell.lib Commctrl.lib
 !ELSE
-LIBS = $(LIBS) comctl32.lib htmlhelp.lib comdlg32.lib Mpr.lib Gdi32.lib shlwapi.lib
+LIBS = $(LIBS) comctl32.lib htmlhelp.lib comdlg32.lib Mpr.lib Gdi32.lib shlwapi.lib Pathcch.lib
 CFLAGS = $(CFLAGS) -DZ7_LONG_PATH -DZ7_DEVICE_FILE /std:c++20
 LFLAGS = $(LFLAGS) /DELAYLOAD:mpr.dll
 LIBS = $(LIBS) delayimp.lib
diff --git a/CPP/7zip/UI/FileManager/MultiPanel.cpp b/CPP/7zip/UI/FileManager/MultiPanel.cpp
index b2bdc5d..c33e878 100644
--- a/CPP/7zip/UI/FileManager/MultiPanel.cpp
+++ b/CPP/7zip/UI/FileManager/MultiPanel.cpp
@@ -238,23 +238,7 @@ UString CPanelCallbackImp::OnSetComboText(UString const& text)
   }
 
   // The second and third panel should only display the file name.
-  int slashPos = text.ReverseFind_PathSepar();
-  if (slashPos >= 0 && slashPos == text.Len() - 1)
-  {
-    slashPos = text.Left(slashPos).ReverseFind_PathSepar();
-  }
-
-  if (slashPos >= 0)
-  {
-    UString filename = UString(text);
-    filename.DeleteFrontal((unsigned)(slashPos + 1));
-    if (filename[filename.Len() - 1] == WCHAR_PATH_SEPARATOR)
-    {
-      filename.DeleteBack();
-    }
-
-    return filename;
-  }
+  return text.GetFileName();
 
-  return UString();
+  // _app->Panels[1].SetFocusToList();
 }
diff --git a/CPP/7zip/UI/FileManager/Panel.cpp b/CPP/7zip/UI/FileManager/Panel.cpp
index d077de3..3d708d2 100644
--- a/CPP/7zip/UI/FileManager/Panel.cpp
+++ b/CPP/7zip/UI/FileManager/Panel.cpp
@@ -1194,3 +1194,8 @@ void CPanel::TestArchives()
   }
   ::TestArchives(paths);
 }
+
+void CPanel::NavigatePath(UString const& path)
+{
+  OnNotifyComboBoxEnter(path);
+}
diff --git a/CPP/7zip/UI/FileManager/Panel.h b/CPP/7zip/UI/FileManager/Panel.h
index b74875a..dbeee1f 100644
--- a/CPP/7zip/UI/FileManager/Panel.h
+++ b/CPP/7zip/UI/FileManager/Panel.h
@@ -368,6 +368,7 @@ class CPanel Z7_final: public NWindows::NControl::CWindow2
   void CreateFile();
   bool CorrectFsPath(const UString &path, UString &result);
   // bool IsPathForPlugin(const UString &path);
+  void NavigatePath(UString const& path);
 
 private:
 
diff --git a/CPP/7zip/UI/FileManager/PanelKey.cpp b/CPP/7zip/UI/FileManager/PanelKey.cpp
index 7f28d96..3ea1c9b 100644
--- a/CPP/7zip/UI/FileManager/PanelKey.cpp
+++ b/CPP/7zip/UI/FileManager/PanelKey.cpp
@@ -7,6 +7,9 @@
 
 #include "../../PropID.h"
 #include "App.h"
+#include "../../../Windows/ProcessUtils.h"
+
+#include <shlwapi.h>
 
 using namespace NWindows;
 
@@ -366,6 +369,50 @@ bool CPanel::OnKeyDown(LPNMLVKEYDOWN keyDownInfo, LRESULT &result)
         FoldersHistory();
         return true;
       }
+    case 'F':
+      if (ctrl)
+      {
+        auto cwd = GetFsPath();
+        auto findProc = new CProcess();
+        findProc->_overlapWindow = TRUE;
+        findProc->_readStdout = TRUE;
+        findProc->Create(L"fzf", L"", cwd);
+        // findProc->Create(L"conhost", L"fzf.exe", cwd);
+        // findProc->Create(L"conhost", L"powershell -noexit -command fzf.exe", cwd);
+
+        auto that = this;
+        if (findProc->WaitAndRun([that, cwd](UString path)
+          {
+            path.Insert(0, cwd.Ptr());
+            if (!PathIsDirectory(path))
+            {
+              path = path.GetDirectory();
+            }
+
+            // Actually don't even need the SendMessage(..., kOpenPath, ...)
+            if (IsGUIThread(TRUE))
+            {
+              that->OnNotifyComboBoxEnter(path);
+            }
+            else
+            {
+              // SendMessage(g_HWND, kOpenPath, (WPARAM)&path, NULL);
+            }
+          }) != 0
+        )
+        {
+          delete findProc;
+        }
+
+        // auto path = findProc.WaitRead();
+
+        // if (!PathIsDirectory(path))
+        // {
+        //   path = path.GetDirectory();
+        // }
+        // OnNotifyComboBoxEnter(path);
+        return true;
+      }
   }
   return false;
 }
diff --git a/CPP/Common/MyString.h b/CPP/Common/MyString.h
index 5775a7c..e2be300 100644
--- a/CPP/Common/MyString.h
+++ b/CPP/Common/MyString.h
@@ -14,7 +14,9 @@
 #include "MyWindows.h"
 #include "MyTypes.h"
 #include "MyVector.h"
+#include <pathcch.h>
 
+// #pragma comment(lib, "pathcch.lib")
 
 /* if (DEBUG_FSTRING_INHERITS_ASTRING is defined), then
      FString inherits from AString, so we can find bugs related to FString at compile time.
@@ -779,6 +781,36 @@ class UString
       memset(_chars, 0, (_limit + 1) * sizeof(*_chars));
       _len = 0;
     }
+
+  }
+
+  UString GetFileName() const
+  {
+    int slashPos = this->ReverseFind_PathSepar();
+    if (slashPos >= 0 && (unsigned int)slashPos == this->Len() - 1)
+    {
+      slashPos = this->Left(slashPos).ReverseFind_PathSepar();
+    }
+
+    if (slashPos >= 0)
+    {
+      UString filename = UString(*this);
+      filename.DeleteFrontal((unsigned)(slashPos + 1));
+      if (filename[filename.Len() - 1] == WCHAR_PATH_SEPARATOR)
+      {
+        filename.DeleteBack();
+      }
+
+      return filename;
+    }
+    return L"";
+  }
+
+  UString GetDirectory() const
+  {
+    auto copy = UString(*this);
+    PathCchRemoveFileSpec(copy._chars, copy._len);
+    return copy;
   }
 };
 
diff --git a/CPP/Common/MyVector.h b/CPP/Common/MyVector.h
index d631ceb..7db20cb 100644
--- a/CPP/Common/MyVector.h
+++ b/CPP/Common/MyVector.h
@@ -65,6 +65,17 @@ class CRecordVector
     }
   }
 
+  template <class _Iter, std::enable_if_t<std::_Is_iterator_v<_Iter>, int> = 0>
+  CRecordVector(_Iter start, _Iter end): _items(NULL), _size(0), _capacity(0)
+  {
+    CRecordVector();
+    // Reserve(1);
+    while (start != end)
+    {
+      Add(*start++);
+    }
+  }
+
   unsigned Size() const { return _size; }
   bool IsEmpty() const { return _size == 0; }
 
diff --git a/CPP/Windows/ProcessUtils.cpp b/CPP/Windows/ProcessUtils.cpp
index 2770b4c..8c4c476 100644
--- a/CPP/Windows/ProcessUtils.cpp
+++ b/CPP/Windows/ProcessUtils.cpp
@@ -3,15 +3,132 @@
 #include "StdAfx.h"
 
 #include "../Common/StringConvert.h"
+#include "Thread.h"
 
 #include "ProcessUtils.h"
+#include <shlwapi.h>
+#include <cstdio>
 
 #ifndef _UNICODE
 extern bool g_IsNT;
 #endif
 
+#include "../7zip/UI/FileManager/App.h"
+
 namespace NWindows {
 
+static volatile long PipeSerialNumber;
+
+BOOL
+APIENTRY
+MyCreatePipeEx(
+    OUT LPHANDLE lpReadPipe,
+    OUT LPHANDLE lpWritePipe,
+    IN LPSECURITY_ATTRIBUTES lpPipeAttributes,
+    IN DWORD nSize,
+    DWORD dwReadMode,
+    DWORD dwWriteMode
+    )
+
+/*++
+Routine Description:
+    The CreatePipeEx API is used to create an anonymous pipe I/O device.
+    Unlike CreatePipe FILE_FLAG_OVERLAPPED may be specified for one or
+    both handles.
+    Two handles to the device are created.  One handle is opened for
+    reading and the other is opened for writing.  These handles may be
+    used in subsequent calls to ReadFile and WriteFile to transmit data
+    through the pipe.
+Arguments:
+    lpReadPipe - Returns a handle to the read side of the pipe.  Data
+        may be read from the pipe by specifying this handle value in a
+        subsequent call to ReadFile.
+    lpWritePipe - Returns a handle to the write side of the pipe.  Data
+        may be written to the pipe by specifying this handle value in a
+        subsequent call to WriteFile.
+    lpPipeAttributes - An optional parameter that may be used to specify
+        the attributes of the new pipe.  If the parameter is not
+        specified, then the pipe is created without a security
+        descriptor, and the resulting handles are not inherited on
+        process creation.  Otherwise, the optional security attributes
+        are used on the pipe, and the inherit handles flag effects both
+        pipe handles.
+    nSize - Supplies the requested buffer size for the pipe.  This is
+        only a suggestion and is used by the operating system to
+        calculate an appropriate buffering mechanism.  A value of zero
+        indicates that the system is to choose the default buffering
+        scheme.
+Return Value:
+    TRUE - The operation was successful.
+    FALSE/NULL - The operation failed. Extended error status is available
+        using GetLastError.
+--*/
+
+{
+  HANDLE ReadPipeHandle, WritePipeHandle;
+  DWORD dwError;
+  CHAR PipeNameBuffer[ MAX_PATH ];
+
+  //
+  // Only one valid OpenMode flag - FILE_FLAG_OVERLAPPED
+  //
+
+  if ((dwReadMode | dwWriteMode) & (~FILE_FLAG_OVERLAPPED)) {
+    SetLastError(ERROR_INVALID_PARAMETER);
+    return FALSE;
+  }
+
+  //
+  //  Set the default timeout to 120 seconds
+  //
+
+  if (nSize == 0) {
+    nSize = 4096;
+  }
+
+  snprintf( PipeNameBuffer, 256,
+           "\\\\.\\Pipe\\RemoteExeAnon.%08lx.%08lx",
+           GetCurrentProcessId(),
+           InterlockedIncrement(&PipeSerialNumber)
+         );
+
+  ReadPipeHandle = CreateNamedPipeA(
+                       PipeNameBuffer,
+                       PIPE_ACCESS_INBOUND | dwReadMode,
+                       PIPE_TYPE_BYTE | PIPE_WAIT,
+                       1,             // Number of pipes
+                       nSize,         // Out buffer size
+                       nSize,         // In buffer size
+                       120 * 1000,    // Timeout in ms
+                       lpPipeAttributes
+                       );
+
+  if (! ReadPipeHandle) {
+    return FALSE;
+  }
+
+  WritePipeHandle = CreateFileA(
+                      PipeNameBuffer,
+                      GENERIC_WRITE,
+                      0,                         // No sharing
+                      lpPipeAttributes,
+                      OPEN_EXISTING,
+                      FILE_ATTRIBUTE_NORMAL | dwWriteMode,
+                      NULL                       // Template file
+                    );
+
+  if (INVALID_HANDLE_VALUE == WritePipeHandle) {
+    dwError = GetLastError();
+    CloseHandle( ReadPipeHandle );
+    SetLastError(dwError);
+    return FALSE;
+  }
+
+  *lpReadPipe = ReadPipeHandle;
+  *lpWritePipe = WritePipeHandle;
+  return( TRUE );
+}
+
 #ifndef UNDER_CE
 static UString GetQuotedString(const UString &s)
 {
@@ -63,7 +180,7 @@ WRes CProcess::Create(LPCWSTR imageName, const UString &params, LPCWSTR curDir)
     si.dwFlags = 0;
     si.cbReserved2 = 0;
     si.lpReserved2 = NULL;
-    
+
     CSysString curDirA;
     if (curDir != 0)
       curDirA = GetSystemString(curDir);
@@ -74,22 +191,70 @@ WRes CProcess::Create(LPCWSTR imageName, const UString &params, LPCWSTR curDir)
   else
   #endif
   {
-    STARTUPINFOW si;
+    SECURITY_ATTRIBUTES sa {
+      sizeof(SECURITY_ATTRIBUTES), NULL, TRUE
+    };
+
+
+    STARTUPINFOW si{};
     si.cb = sizeof(si);
-    si.lpReserved = NULL;
-    si.lpDesktop = NULL;
-    si.lpTitle = NULL;
-    si.dwFlags = 0;
-    si.cbReserved2 = 0;
-    si.lpReserved2 = NULL;
-    
+
+    if (_readStdout)
+    {
+      // if (!CreatePipe(&_hStdoutRead, &_hStdoutWrite, &sa, 0))
+      // {
+      //   return (WRes)-1;
+      // }
+
+      // NOTE: uncomment this if you want to use WaitAndRunOverlapped, but it has issues.
+      if (!MyCreatePipeEx(
+          &_hStdoutRead, &_hStdoutWrite, &sa, 0,
+          FILE_FLAG_OVERLAPPED, 0)
+      )
+      {
+        return (WRes)-1;
+      }
+      si.hStdOutput = _hStdoutWrite;
+      si.hStdError = _hStdoutWrite;
+      si.dwFlags |= STARTF_USESTDHANDLES;
+    }
+
+    if (_overlapWindow)
+    {
+      RECT rc;
+      g_App._window.GetWindowRect(&rc);
+      si.dwX = rc.left;
+      si.dwY = rc.top;
+
+      // size doesn't work for some reason
+      si.dwXSize = rc.right - rc.left;
+      si.dwYSize = rc.bottom - rc.top;
+      si.dwFlags |= STARTF_USEPOSITION | STARTF_USESIZE;
+    }
+
+    if (!PathIsDirectory(curDir))
+    {
+      curDir = NULL;
+    }
+
     result = CreateProcessW(imageName, params2.Ptr_non_const(),
-        NULL, NULL, FALSE, 0, NULL, curDir, &si, &pi);
+        NULL, NULL, _readStdout, _readStdout ? CREATE_NEW_CONSOLE : 0, NULL, curDir, &si, &pi);
+
+    // Child process will have this handle, we don't need it. When child process
+    // exits they will close their instance of this handle and our _hStdoutRead
+    // will be signalled.
+    if (_hStdoutWrite)
+    {
+      CloseHandle(_hStdoutWrite);
+      _hStdoutWrite = NULL;
+    }
   }
-  if (result == 0)
-    return ::GetLastError();
+
   ::CloseHandle(pi.hThread);
   _handle = pi.hProcess;
+
+  if (result == 0)
+    return ::GetLastError();
   return 0;
 }
 
@@ -99,4 +264,215 @@ WRes MyCreateProcess(LPCWSTR imageName, const UString &params)
   return process.Create(imageName, params, NULL);
 }
 
+UString CProcess::WaitRead()
+{
+  DWORD dwRead;
+  CHAR chBuf[4096];
+  BOOL bSuccess = FALSE;
+
+  for (;;)
+  {
+    bSuccess = ReadFile(_hStdoutRead, chBuf, sizeof(chBuf), &dwRead, NULL);
+    if (dwRead != 0)
+    {
+      _readBuffer += CByteVector((unsigned char *)chBuf, (unsigned char *)chBuf + dwRead);
+    }
+
+    if (!bSuccess || dwRead == 0)
+      break;
+  }
+
+  _readBuffer.Add(0);
+
+  UString result{};
+  MultiByteToUnicodeString2(result, AString((char *)_readBuffer.begin()), CP_UTF8);
+  return result;
+}
+
+// Must be constructed with new since it deletes itself.
+struct CThreadProcessWaitSync
+{
+  CHAR chBuf[4096];
+  DWORD dwRead{};
+  HANDLE _hFile{}; // non owning
+  CByteVector _readBuffer;
+  std::function<void(UString)> _fn;
+  CProcess *owner{};
+
+  CThreadProcessWaitSync() {}
+  virtual ~CThreadProcessWaitSync()
+  {
+    if (owner)
+    {
+      delete owner;
+      owner = nullptr;
+    }
+  }
+
+  HRESULT Initialize(HANDLE hFile, std::function<void(UString)> const& fn)
+  {
+    _fn = fn;
+    _hFile = hFile;
+    return S_OK;
+  }
+  void Process()
+  {
+    CHAR chBuf[4096];
+    BOOL bSuccess = FALSE;
+
+    for (;;)
+    {
+      bSuccess = ReadFile(_hFile, chBuf, sizeof(chBuf), &dwRead, NULL);
+      if (dwRead != 0)
+      {
+        _readBuffer += CByteVector((unsigned char *)chBuf, (unsigned char *)chBuf + dwRead);
+      }
+
+      if (!bSuccess || dwRead == 0)
+        break;
+    }
+
+    _readBuffer.Add(0);
+
+    UString resultString{};
+    MultiByteToUnicodeString2(resultString, AString((char *)_readBuffer.begin()), CP_UTF8);
+    _fn(resultString);
+  }
+
+  static THREAD_FUNC_DECL MyThreadFunction(void *param)
+  {
+    ((CThreadProcessWaitSync *)param)->Process();
+    delete static_cast<CThreadProcessWaitSync *>(param);
+    return 0;
+  }
+};
+
+
+// To call this, always allocate CProcess with new.
+// If this function succeeds with return value 0, then this object will delete itself.
+// Otherwise caller must delete.
+WRes CProcess::WaitAndRun(std::function<void(UString)> const& fn)
+{
+  auto waiter = new CThreadProcessWaitSync();
+  HRESULT result = waiter->Initialize(_hStdoutRead, fn);
+
+  if (FAILED(result))
+  {
+    delete waiter;
+    return (WRes)-1;
+  }
+
+  NWindows::CThread thread;
+  waiter->owner = this;
+  const WRes wres = thread.Create(CThreadProcessWaitSync::MyThreadFunction, waiter);
+  _deleteSelf = TRUE;
+  return wres;
+}
+
+
+// Must be constructed with new since it deletes itself.
+struct CThreadProcessWaitOverlapped
+{
+  OVERLAPPED overlapped{};
+  CHAR chBuf[4096];
+  DWORD dwRead{};
+  HANDLE _hFile{}; // non owning
+  CByteVector _readBuffer;
+  std::function<void(UString)> _fn;
+  CProcess *owner{};
+
+  CThreadProcessWaitOverlapped(OVERLAPPED overlapped) : overlapped(overlapped) {}
+  CThreadProcessWaitOverlapped() {}
+  virtual ~CThreadProcessWaitOverlapped()
+  {
+    if (overlapped.hEvent != NULL)
+    {
+      CloseHandle(overlapped.hEvent);
+      overlapped.hEvent = NULL;
+    }
+
+    if (owner)
+    {
+      delete owner;
+      owner = nullptr;
+    }
+  }
+
+  HRESULT Initialize(HANDLE hFile, std::function<void(UString)> const& fn)
+  {
+    memset(&overlapped, 0, sizeof(overlapped));
+    overlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
+    _fn = fn;
+    _hFile = hFile;
+
+    // _readBuffer = CByteVector{};
+
+    if (overlapped.hEvent == NULL)
+    {
+      return E_FAIL;
+    }
+    return S_OK;
+  }
+  void Process()
+  {
+    try
+    {
+      BOOL bSuccess = FALSE;
+      bSuccess = GetOverlappedResult(_hFile,
+                              &overlapped,
+                              &dwRead,
+                              TRUE) ;
+      if (bSuccess && dwRead != 0)
+      {
+        // _readBuffer.Reserve(1);
+        _readBuffer += CByteVector((unsigned char *)chBuf, (unsigned char *)chBuf + dwRead);
+      }
+
+      _readBuffer.Add(0);
+
+      UString resultString{};
+      MultiByteToUnicodeString2(resultString, AString((char *)_readBuffer.begin()), CP_UTF8);
+      _fn(resultString);
+    }
+    catch(...) { }
+  }
+
+  static THREAD_FUNC_DECL MyThreadFunction(void *param)
+  {
+    ((CThreadProcessWaitOverlapped *)param)->Process();
+    delete static_cast<CThreadProcessWaitOverlapped *>(param);
+    return 0;
+  }
+};
+
+// To call this, always allocate CProcess with new.
+// If this function succeeds with return value 0, then this object will delete itself.
+// Otherwise caller must delete.
+WRes CProcess::WaitAndRunOverlapped(std::function<void(UString)> const& fn)
+{
+  auto waiter = new CThreadProcessWaitOverlapped();
+  HRESULT result = waiter->Initialize(_hStdoutRead, fn);
+
+  if (FAILED(result))
+  {
+    delete waiter;
+    return (WRes)-1;
+  }
+
+  BOOL bSuccess = ReadFile(_hStdoutRead, waiter->chBuf, sizeof(waiter->chBuf), &waiter->dwRead, &waiter->overlapped);
+  if (!bSuccess && GetLastError() == ERROR_IO_PENDING)
+  {
+    NWindows::CThread thread;
+    waiter->owner = this;
+    const WRes wres = thread.Create(CThreadProcessWaitOverlapped::MyThreadFunction, waiter);
+    _deleteSelf = TRUE;
+    return wres;
+  }
+  else
+  {
+    // Could happen but not for fzf.
+    delete waiter;
+    return (WRes)-1;
+  }
+}
 }
diff --git a/CPP/Windows/ProcessUtils.h b/CPP/Windows/ProcessUtils.h
index 8054eef..e146954 100644
--- a/CPP/Windows/ProcessUtils.h
+++ b/CPP/Windows/ProcessUtils.h
@@ -4,6 +4,11 @@
 #define ZIP7_INC_WINDOWS_PROCESS_UTILS_H
 
 #include "../Common/MyWindows.h"
+#include "../Common/MyVector.h"
+#include "../Common/MyString.h"
+#include "../Common/StringConvert.h"
+
+#include <functional>
 
 #ifndef Z7_OLD_WIN_SDK
 
@@ -44,9 +49,43 @@ typedef PROCESS_MEMORY_COUNTERS *PPROCESS_MEMORY_COUNTERS;
 
 namespace NWindows {
 
+
+BOOL
+APIENTRY
+MyCreatePipeEx(
+    OUT LPHANDLE lpReadPipe,
+    OUT LPHANDLE lpWritePipe,
+    IN LPSECURITY_ATTRIBUTES lpPipeAttributes,
+    IN DWORD nSize,
+    DWORD dwReadMode,
+    DWORD dwWriteMode
+    );
+
 class CProcess: public CHandle
 {
 public:
+  HANDLE _hStdoutRead, _hStdoutWrite;
+  CByteVector _readBuffer;
+  BOOL _deleteSelf{};
+  BOOL _overlapWindow{};
+  BOOL _readStdout{};
+
+  CProcess() : _hStdoutRead(NULL), _hStdoutWrite(NULL) {}
+  virtual ~CProcess()
+  {
+    if (_hStdoutRead != NULL)
+    {
+      CloseHandle(_hStdoutRead);
+      _hStdoutRead = NULL;
+    }
+
+    if (_hStdoutWrite != NULL)
+    {
+      CloseHandle(_hStdoutWrite);
+      _hStdoutWrite = NULL;
+    }
+  }
+
   bool Open(DWORD desiredAccess, bool inheritHandle, DWORD processId)
   {
     _handle = ::OpenProcess(desiredAccess, inheritHandle, processId);
@@ -128,7 +167,15 @@ class CProcess: public CHandle
 
   WRes Create(LPCWSTR imageName, const UString &params, LPCWSTR curDir);
 
-  DWORD Wait() { return ::WaitForSingleObject(_handle, INFINITE); }
+  DWORD Wait()
+  {
+    DWORD result = ::WaitForSingleObject(_handle, INFINITE);
+    return result;
+  }
+
+  UString WaitRead();
+  WRes WaitAndRun(std::function<void(UString)> const& fn);
+  WRes WaitAndRunOverlapped(std::function<void(UString)> const& fn);
 };
 
 WRes MyCreateProcess(LPCWSTR imageName, const UString &params);
