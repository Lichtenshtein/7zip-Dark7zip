From 0c1f91a3d78d387850f896ceebc52a0756671a29 Mon Sep 17 00:00:00 2001
From: ironyman <ironyman13@gmail.com>
Date: Sat, 7 Jan 2023 10:51:11 -0800
Subject: [PATCH] Fix environment block, can't add null terminators to UString

---
 CPP/7zip/UI/FileManager/PanelKey.cpp |   9 +-
 CPP/Windows/ProcessUtils.cpp         | 142 ++++++++++++++++++++++++++-
 2 files changed, 147 insertions(+), 4 deletions(-)

diff --git a/CPP/7zip/UI/FileManager/PanelKey.cpp b/CPP/7zip/UI/FileManager/PanelKey.cpp
index 8cc9184..c57ca6f 100644
--- a/CPP/7zip/UI/FileManager/PanelKey.cpp
+++ b/CPP/7zip/UI/FileManager/PanelKey.cpp
@@ -380,8 +380,13 @@ bool CPanel::OnKeyDown(LPNMLVKEYDOWN keyDownInfo, LRESULT &result)
         // Doubly null terminated string, last null is for list of null terminated strings.
         // If you're setting this in shell it would be
         // $env:FZF_DEFAULT_COMMAND = 'rg --hidden --no-ignore -l --max-depth 5 ""'
-        UString env = L"FZF_DEFAULT_COMMAND=rg --hidden --no-ignore -l --max-depth 5 \"\"\0\0";
-        findProc->Create(L"fzf.exe", L"", cwd, (LPVOID)env.Ptr());
+        UString envStr = L"FZF_DEFAULT_COMMAND=rg --hidden --no-ignore -l --max-depth 5 \"\"";
+        auto env = CRecordVector<WCHAR>(envStr.Ptr(), envStr.Ptr() + envStr.Len() + 1); // Include null terminator
+        env.Add(0);
+
+        findProc->Create(L"fzf.exe", L"", cwd, (LPVOID)env.begin());
+        // findProc->Create(L"conhost", L"cmd /c fzf.exe", cwd, (LPVOID)env.begin());
+
         // to test
         // findProc->Create(L"cmd.exe", L"", cwd, (LPVOID)env.Ptr());
         // findProc->Create(L"conhost", L"fzf.exe", cwd);
diff --git a/CPP/Windows/ProcessUtils.cpp b/CPP/Windows/ProcessUtils.cpp
index aea7ee7..fe7574f 100644
--- a/CPP/Windows/ProcessUtils.cpp
+++ b/CPP/Windows/ProcessUtils.cpp
@@ -129,6 +129,132 @@ Return Value:
   return( TRUE );
 }
 
+
+void __cdecl DbgPrintA(const char *format, ...)
+{
+char    buf[4096], *p = buf;
+va_list args;
+int     n;
+
+        va_start(args, format);
+        n = _vsnprintf_s(p, ARRAYSIZE(buf), sizeof buf, format, args);
+        // n = _vsnprintf_s(p, ARRAYSIZE(buf), sizeof buf - 3, format, args); // buf-3 is room for CR/LF/NUL
+        va_end(args);
+
+        // p += (n < 0) ? sizeof buf - 3 : n;
+
+        // while ( p > buf  &&  isspace(p[-1]) )
+        //         *--p = '\0';
+
+        // *p++ = '\r';
+        // *p++ = '\n';
+        // *p   = '\0';
+
+        OutputDebugStringA(buf);
+}
+
+VOID
+DbgDumpHex(PBYTE pbData, SIZE_T cbData)
+{
+    ULONG i;
+    SIZE_T count;
+    CHAR digits[]="0123456789abcdef";
+    CHAR pbLine[256];
+    ULONG cbLine, cbHeader = 0;
+    ULONG_PTR address;
+
+    if(pbData == NULL && cbData != 0)
+    {
+        // strcat_s(pbLine, RTL_NUMBER_OF(pbLine), "<null> buffer!!!\n");
+        fprintf(stderr, "<null> buffer!!!\n");
+        return;
+    }
+
+    for(; cbData ; cbData -= count, pbData += count)
+    {
+        count = (cbData > 16) ? 16:cbData;
+
+        cbLine = cbHeader;
+
+        address = (ULONG_PTR)pbData;
+
+#if UINTPTR_MAX == 0xFFFFFFFFFFFFFFFFu
+        // 64 bit addresses.
+        pbLine[cbLine++] = digits[(address >> 0x3c) & 0x0f];
+        pbLine[cbLine++] = digits[(address >> 0x38) & 0x0f];
+        pbLine[cbLine++] = digits[(address >> 0x34) & 0x0f];
+        pbLine[cbLine++] = digits[(address >> 0x30) & 0x0f];
+        pbLine[cbLine++] = digits[(address >> 0x2c) & 0x0f];
+        pbLine[cbLine++] = digits[(address >> 0x28) & 0x0f];
+        pbLine[cbLine++] = digits[(address >> 0x24) & 0x0f];
+        pbLine[cbLine++] = digits[(address >> 0x20) & 0x0f];
+#endif
+        pbLine[cbLine++] = digits[(address >> 0x1c) & 0x0f];
+        pbLine[cbLine++] = digits[(address >> 0x18) & 0x0f];
+        pbLine[cbLine++] = digits[(address >> 0x14) & 0x0f];
+        pbLine[cbLine++] = digits[(address >> 0x10) & 0x0f];
+        pbLine[cbLine++] = digits[(address >> 0x0c) & 0x0f];
+        pbLine[cbLine++] = digits[(address >> 0x08) & 0x0f];
+        pbLine[cbLine++] = digits[(address >> 0x04) & 0x0f];
+        pbLine[cbLine++] = digits[(address        ) & 0x0f];
+        pbLine[cbLine++] = ' ';
+        pbLine[cbLine++] = ' ';
+
+        for(i = 0; i < count; i++)
+        {
+            pbLine[cbLine++] = digits[pbData[i]>>4];
+            pbLine[cbLine++] = digits[pbData[i]&0x0f];
+            if(i == 7)
+            {
+                pbLine[cbLine++] = ':';
+            }
+            else
+            {
+                pbLine[cbLine++] = ' ';
+            }
+        }
+
+        for(; i < 16; i++)
+        {
+            pbLine[cbLine++] = ' ';
+            pbLine[cbLine++] = ' ';
+            pbLine[cbLine++] = ' ';
+        }
+
+        pbLine[cbLine++] = ' ';
+
+        for(i = 0; i < count; i++)
+        {
+            if(pbData[i] < 32 || pbData[i] > 126)
+            {
+                pbLine[cbLine++] = '.';
+            }
+            else
+            {
+                pbLine[cbLine++] = pbData[i];
+            }
+        }
+
+        pbLine[cbLine++] = 0;
+
+        DbgPrintA("%s\n", pbLine);
+    }
+}
+
+void DbgDumpRange(PVOID begin, PVOID end, PCSTR format, ...)
+{
+  DbgPrintA("[CProcess::Create] ");
+  va_list args;
+
+  va_start(args, format);
+  DbgPrintA(format, args);
+  va_end(args);
+
+  SIZE_T size = (SIZE_T)end - (SIZE_T)begin;
+  DbgPrintA(" len(%lu): 0x%p - 0x%p\n", size, begin, end);
+  DbgDumpHex((PBYTE)begin, size);
+}
+
 #ifndef UNDER_CE
 static UString GetQuotedString(const UString &s)
 {
@@ -253,10 +379,14 @@ WRes CProcess::Create(LPCWSTR imageName, const UString &params, LPCWSTR curDir,
       {
         additionalEnvVarEnd += wcslen(additionalEnvVarEnd) + 1;
       }
-      ++additionalEnvVarEnd;
 
       env = CRecordVector<WCHAR>(envBlock, envBlockEnd);
+
+      // DbgDumpRange(env.begin(), env.end(), "env after adding envBlock");
+      // DbgDumpRange(additionalEnvVar, additionalEnvVarEnd, "additionalEnvVar");
       env += CRecordVector<WCHAR>((PWCHAR)additionalEnvVar, additionalEnvVarEnd);
+      // DbgDumpRange(env.begin(), env.end(), "env after adding temp");
+      env.Add(0);
     }
 
     result = CreateProcessW(imageName, params2.Ptr_non_const(),
@@ -272,13 +402,21 @@ WRes CProcess::Create(LPCWSTR imageName, const UString &params, LPCWSTR curDir,
       CloseHandle(_hStdoutWrite);
       _hStdoutWrite = NULL;
     }
+
+      if (result == 0)
+      {
+        DbgDumpRange(env.begin(), env.end(), "CreateProcessW failed with GLE %x, dumping env", GetLastError());
+      }
   }
 
   ::CloseHandle(pi.hThread);
   _handle = pi.hProcess;
 
   if (result == 0)
+  {
+    MessageBoxW(g_HWND, L"CreateProcessW failed", L"Failed with error", MB_ICONERROR | MB_OK);
     return ::GetLastError();
+  }
   return 0;
 }
 
@@ -356,7 +494,7 @@ struct CThreadProcessWaitSync
     }
 
     _readBuffer.Add(0);
-
+    DbgDumpRange(_readBuffer.begin(), _readBuffer.end(), "_readBuffer");
     UString resultString{};
     MultiByteToUnicodeString2(resultString, AString((char *)_readBuffer.begin()), CP_UTF8);
     _fn(resultString);
