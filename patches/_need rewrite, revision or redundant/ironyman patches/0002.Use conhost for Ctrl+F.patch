From 08997781df5d9eee133589b63d336c2229394ad3 Mon Sep 17 00:00:00 2001
From: ironyman <ironyman13@gmail.com>
Date: Sun, 8 Jan 2023 11:21:41 -0800
Subject: [PATCH] Use conhost for Ctrl+F

---
 CPP/7zip/UI/FileManager/PanelKey.cpp |  40 ++++-
 CPP/7zip/UI/FileManager/makefile     |   1 +
 CPP/Common/Common.h                  |   5 +
 CPP/Common/Debug.cpp                 | 128 ++++++++++++++
 CPP/Windows/ProcessUtils.cpp         | 254 +++++++++------------------
 CPP/Windows/ProcessUtils.h           |   4 +-
 test/pipe.cpp                        | 211 ++++++++++++++++++++++
 7 files changed, 470 insertions(+), 173 deletions(-)
 create mode 100644 CPP/Common/Debug.cpp
 create mode 100644 test/pipe.cpp

diff --git a/CPP/7zip/UI/FileManager/PanelKey.cpp b/CPP/7zip/UI/FileManager/PanelKey.cpp
index c57ca6f..a9791f7 100644
--- a/CPP/7zip/UI/FileManager/PanelKey.cpp
+++ b/CPP/7zip/UI/FileManager/PanelKey.cpp
@@ -375,7 +375,7 @@ bool CPanel::OnKeyDown(LPNMLVKEYDOWN keyDownInfo, LRESULT &result)
         auto cwd = GetFsPath();
         auto findProc = new CProcess();
         findProc->_overlapWindow = TRUE;
-        findProc->_readStdout = TRUE;
+        findProc->_readOutput = TRUE;
 
         // Doubly null terminated string, last null is for list of null terminated strings.
         // If you're setting this in shell it would be
@@ -384,13 +384,47 @@ bool CPanel::OnKeyDown(LPNMLVKEYDOWN keyDownInfo, LRESULT &result)
         auto env = CRecordVector<WCHAR>(envStr.Ptr(), envStr.Ptr() + envStr.Len() + 1); // Include null terminator
         env.Add(0);
 
-        findProc->Create(L"fzf.exe", L"", cwd, (LPVOID)env.begin());
-        // findProc->Create(L"conhost", L"cmd /c fzf.exe", cwd, (LPVOID)env.begin());
+        UString pipeName = MyGetNextPipeName();
+        int backSlash = pipeName.ReverseFind_PathSepar();
+        constexpr WCHAR cmdTemplate[] = LR"(
+powershell -command " & { $output = fzf;
+$pipeName = '%s';
+$npipeClient = new-object System.IO.Pipes.NamedPipeClientStream('.', $pipeName, [System.IO.Pipes.PipeDirection]::Out,
+  [System.IO.Pipes.PipeOptions]::None,
+	[System.Security.Principal.TokenImpersonationLevel]::Impersonation);
+$npipeClient.Connect();
+$script:pipeWriter = new-object System.IO.StreamWriter($npipeClient);
+$pipeWriter.AutoFlush = $true;
+$pipeWriter.WriteLine($output);
+$pipeWriter.Close(); }"
+        )";
+        WCHAR cmd[4096]{};
+        #pragma warning (disable : 4774 )
+        _snwprintf_s(cmd, ARRAYSIZE(cmd), ARRAYSIZE(cmd), cmdTemplate, pipeName.Ptr() + backSlash + 1);
+
+        // No newlines allowed.
+        for (auto & ch : cmd)
+        {
+          if (ch == '\n')
+          {
+            ch = ' ';
+          }
+        }
+
+
+        // Use conhost, it's faster.
+        findProc->_createPipeOnly = TRUE;
+        findProc->Create(L"conhost", cmd, cwd, (LPVOID)env.begin());
+
+        // Use default terminal, need to set
+        // findProc->_createPipeOnly = FALSE
+        // findProc->Create(L"fzf.exe", L"", cwd, (LPVOID)env.begin());
 
         // to test
         // findProc->Create(L"cmd.exe", L"", cwd, (LPVOID)env.Ptr());
         // findProc->Create(L"conhost", L"fzf.exe", cwd);
         // findProc->Create(L"conhost", L"powershell -noexit -command fzf.exe", cwd);
+        // findProc->Create(L"conhost", L"powershell -command \" & { $output = fzf; [Console]::Error.WriteLine($output) }\"", cwd, (LPVOID)env.begin());
 
         auto that = this;
         if (findProc->WaitAndRun([that, cwd](UString path)
diff --git a/CPP/7zip/UI/FileManager/makefile b/CPP/7zip/UI/FileManager/makefile
index 52cc56f..91a47d0 100644
--- a/CPP/7zip/UI/FileManager/makefile
+++ b/CPP/7zip/UI/FileManager/makefile
@@ -18,6 +18,7 @@ COMMON_OBJS = \
   $O\StringToInt.obj \
   $O\UTFConvert.obj \
   $O\Wildcard.obj \
+  $O\Debug.obj
 
 WIN_OBJS = $(WIN_OBJS) \
   $O\Clipboard.obj \
diff --git a/CPP/Common/Common.h b/CPP/Common/Common.h
index c0000dd..e23c6f3 100644
--- a/CPP/Common/Common.h
+++ b/CPP/Common/Common.h
@@ -311,3 +311,8 @@ _Pragma("GCC diagnostic pop")
 
 // for precompiler:
 #include "MyWindows.h"
+
+void __cdecl Z7DbgPrintA(const char *format, ...);
+VOID
+DbgDumpHex(PBYTE pbData, SIZE_T cbData);
+void DbgDumpRange(PVOID begin, PVOID end, PCSTR format, ...);
\ No newline at end of file
diff --git a/CPP/Common/Debug.cpp b/CPP/Common/Debug.cpp
new file mode 100644
index 0000000..3fd314d
--- /dev/null
+++ b/CPP/Common/Debug.cpp
@@ -0,0 +1,128 @@
+#include <StdAfx.h>
+#include <cstdarg>
+#include <cstdio>
+
+void __cdecl Z7DbgPrintA(const char *format, ...)
+{
+  char    buf[4096], *p = buf;
+  va_list args;
+  int     n;
+
+  va_start(args, format);
+  n = _vsnprintf_s(p, ARRAYSIZE(buf), sizeof buf, format, args);
+  // n = _vsnprintf_s(p, ARRAYSIZE(buf), sizeof buf - 3, format, args); // buf-3 is room for CR/LF/NUL
+  va_end(args);
+
+  // p += (n < 0) ? sizeof buf - 3 : n;
+
+  // while ( p > buf  &&  isspace(p[-1]) )
+  //         *--p = '\0';
+
+  // *p++ = '\r';
+  // *p++ = '\n';
+  // *p   = '\0';
+
+  OutputDebugStringA(buf);
+}
+
+VOID
+DbgDumpHex(PBYTE pbData, SIZE_T cbData)
+{
+    ULONG i;
+    SIZE_T count;
+    CHAR digits[]="0123456789abcdef";
+    CHAR pbLine[256];
+    ULONG cbLine, cbHeader = 0;
+    ULONG_PTR address;
+
+    if(pbData == NULL && cbData != 0)
+    {
+        // strcat_s(pbLine, RTL_NUMBER_OF(pbLine), "<null> buffer!!!\n");
+        fprintf(stderr, "<null> buffer!!!\n");
+        return;
+    }
+
+    for(; cbData ; cbData -= count, pbData += count)
+    {
+        count = (cbData > 16) ? 16:cbData;
+
+        cbLine = cbHeader;
+
+        address = (ULONG_PTR)pbData;
+
+#if UINTPTR_MAX == 0xFFFFFFFFFFFFFFFFu
+        // 64 bit addresses.
+        pbLine[cbLine++] = digits[(address >> 0x3c) & 0x0f];
+        pbLine[cbLine++] = digits[(address >> 0x38) & 0x0f];
+        pbLine[cbLine++] = digits[(address >> 0x34) & 0x0f];
+        pbLine[cbLine++] = digits[(address >> 0x30) & 0x0f];
+        pbLine[cbLine++] = digits[(address >> 0x2c) & 0x0f];
+        pbLine[cbLine++] = digits[(address >> 0x28) & 0x0f];
+        pbLine[cbLine++] = digits[(address >> 0x24) & 0x0f];
+        pbLine[cbLine++] = digits[(address >> 0x20) & 0x0f];
+#endif
+        pbLine[cbLine++] = digits[(address >> 0x1c) & 0x0f];
+        pbLine[cbLine++] = digits[(address >> 0x18) & 0x0f];
+        pbLine[cbLine++] = digits[(address >> 0x14) & 0x0f];
+        pbLine[cbLine++] = digits[(address >> 0x10) & 0x0f];
+        pbLine[cbLine++] = digits[(address >> 0x0c) & 0x0f];
+        pbLine[cbLine++] = digits[(address >> 0x08) & 0x0f];
+        pbLine[cbLine++] = digits[(address >> 0x04) & 0x0f];
+        pbLine[cbLine++] = digits[(address        ) & 0x0f];
+        pbLine[cbLine++] = ' ';
+        pbLine[cbLine++] = ' ';
+
+        for(i = 0; i < count; i++)
+        {
+            pbLine[cbLine++] = digits[pbData[i]>>4];
+            pbLine[cbLine++] = digits[pbData[i]&0x0f];
+            if(i == 7)
+            {
+                pbLine[cbLine++] = ':';
+            }
+            else
+            {
+                pbLine[cbLine++] = ' ';
+            }
+        }
+
+        for(; i < 16; i++)
+        {
+            pbLine[cbLine++] = ' ';
+            pbLine[cbLine++] = ' ';
+            pbLine[cbLine++] = ' ';
+        }
+
+        pbLine[cbLine++] = ' ';
+
+        for(i = 0; i < count; i++)
+        {
+            if(pbData[i] < 32 || pbData[i] > 126)
+            {
+                pbLine[cbLine++] = '.';
+            }
+            else
+            {
+                pbLine[cbLine++] = pbData[i];
+            }
+        }
+
+        pbLine[cbLine++] = 0;
+
+        Z7DbgPrintA("%s\n", pbLine);
+    }
+}
+
+void DbgDumpRange(PVOID begin, PVOID end, PCSTR format, ...)
+{
+  Z7DbgPrintA("[CProcess::Create] ");
+  va_list args;
+
+  va_start(args, format);
+  Z7DbgPrintA(format, args);
+  va_end(args);
+
+  SIZE_T size = (SIZE_T)end - (SIZE_T)begin;
+  Z7DbgPrintA(" len(%lu): 0x%p - 0x%p\n", size, begin, end);
+  DbgDumpHex((PBYTE)begin, size);
+}
\ No newline at end of file
diff --git a/CPP/Windows/ProcessUtils.cpp b/CPP/Windows/ProcessUtils.cpp
index fe7574f..6c68297 100644
--- a/CPP/Windows/ProcessUtils.cpp
+++ b/CPP/Windows/ProcessUtils.cpp
@@ -19,6 +19,18 @@ namespace NWindows {
 
 static volatile long PipeSerialNumber;
 
+
+UString MyGetNextPipeName()
+{
+  CHAR PipeNameBuffer[ MAX_PATH ];
+  snprintf( PipeNameBuffer, MAX_PATH,
+           "\\\\.\\Pipe\\7zFMPipe.%08lx.%08lx",
+           GetCurrentProcessId(),
+           PipeSerialNumber + 1
+         );
+  return UString(PipeNameBuffer);
+}
+
 BOOL
 APIENTRY
 MyCreatePipeEx(
@@ -29,7 +41,6 @@ MyCreatePipeEx(
     DWORD dwReadMode,
     DWORD dwWriteMode
     )
-
 /*++
 Routine Description:
     The CreatePipeEx API is used to create an anonymous pipe I/O device.
@@ -63,9 +74,8 @@ Return Value:
     FALSE/NULL - The operation failed. Extended error status is available
         using GetLastError.
 --*/
-
 {
-  HANDLE ReadPipeHandle, WritePipeHandle;
+  HANDLE ReadPipeHandle = NULL, WritePipeHandle = NULL;
   DWORD dwError;
   CHAR PipeNameBuffer[ MAX_PATH ];
 
@@ -87,173 +97,57 @@ Return Value:
   }
 
   snprintf( PipeNameBuffer, 256,
-           "\\\\.\\Pipe\\RemoteExeAnon.%08lx.%08lx",
+           "\\\\.\\pipe\\7zFMPipe.%08lx.%08lx",
            GetCurrentProcessId(),
            InterlockedIncrement(&PipeSerialNumber)
          );
 
+  // For PIPE_ACCESS_INBOUND, the writer must open with GENERIC_WRITE
+  // or [System.IO.Pipes.PipeDirection]::Out.
+  // If you create with PIPE_ACCESS_DUPLEX then
+  // you can open with GENERIC_ALL or [System.IO.Pipes.PipeDirection]::InOut.
   ReadPipeHandle = CreateNamedPipeA(
-                       PipeNameBuffer,
-                       PIPE_ACCESS_INBOUND | dwReadMode,
-                       PIPE_TYPE_BYTE | PIPE_WAIT,
-                       1,             // Number of pipes
-                       nSize,         // Out buffer size
-                       nSize,         // In buffer size
-                       120 * 1000,    // Timeout in ms
-                       lpPipeAttributes
-                       );
+          PipeNameBuffer,             // pipe name
+          PIPE_ACCESS_INBOUND | dwReadMode,       // read/write access
+          PIPE_TYPE_MESSAGE |       // message type pipe
+          PIPE_READMODE_MESSAGE |   // message-read mode
+          PIPE_WAIT,                // blocking mode
+          PIPE_UNLIMITED_INSTANCES, // max. instances
+          nSize,                  // output buffer size
+          nSize,                  // input buffer size
+          0,                        // client time-out
+          NULL);                    // default security attribute
 
   if (! ReadPipeHandle) {
     return FALSE;
   }
 
-  WritePipeHandle = CreateFileA(
-                      PipeNameBuffer,
-                      GENERIC_WRITE,
-                      0,                         // No sharing
-                      lpPipeAttributes,
-                      OPEN_EXISTING,
-                      FILE_ATTRIBUTE_NORMAL | dwWriteMode,
-                      NULL                       // Template file
-                    );
-
-  if (INVALID_HANDLE_VALUE == WritePipeHandle) {
-    dwError = GetLastError();
-    CloseHandle( ReadPipeHandle );
-    SetLastError(dwError);
-    return FALSE;
-  }
-
   *lpReadPipe = ReadPipeHandle;
-  *lpWritePipe = WritePipeHandle;
-  return( TRUE );
-}
 
-
-void __cdecl DbgPrintA(const char *format, ...)
-{
-char    buf[4096], *p = buf;
-va_list args;
-int     n;
-
-        va_start(args, format);
-        n = _vsnprintf_s(p, ARRAYSIZE(buf), sizeof buf, format, args);
-        // n = _vsnprintf_s(p, ARRAYSIZE(buf), sizeof buf - 3, format, args); // buf-3 is room for CR/LF/NUL
-        va_end(args);
-
-        // p += (n < 0) ? sizeof buf - 3 : n;
-
-        // while ( p > buf  &&  isspace(p[-1]) )
-        //         *--p = '\0';
-
-        // *p++ = '\r';
-        // *p++ = '\n';
-        // *p   = '\0';
-
-        OutputDebugStringA(buf);
-}
-
-VOID
-DbgDumpHex(PBYTE pbData, SIZE_T cbData)
-{
-    ULONG i;
-    SIZE_T count;
-    CHAR digits[]="0123456789abcdef";
-    CHAR pbLine[256];
-    ULONG cbLine, cbHeader = 0;
-    ULONG_PTR address;
-
-    if(pbData == NULL && cbData != 0)
-    {
-        // strcat_s(pbLine, RTL_NUMBER_OF(pbLine), "<null> buffer!!!\n");
-        fprintf(stderr, "<null> buffer!!!\n");
-        return;
+  if (lpWritePipe != NULL)
+  {
+    WritePipeHandle = CreateFileA(
+                        PipeNameBuffer,
+                        GENERIC_WRITE,
+                        FILE_SHARE_WRITE | FILE_SHARE_READ,
+                        lpPipeAttributes,
+                        OPEN_EXISTING,
+                        FILE_ATTRIBUTE_NORMAL | dwWriteMode,
+                        NULL                       // Template file
+                      );
+
+    if (INVALID_HANDLE_VALUE == WritePipeHandle) {
+      dwError = GetLastError();
+      CloseHandle( ReadPipeHandle );
+      SetLastError(dwError);
+      return FALSE;
     }
+    *lpWritePipe = WritePipeHandle;
+  }
 
-    for(; cbData ; cbData -= count, pbData += count)
-    {
-        count = (cbData > 16) ? 16:cbData;
-
-        cbLine = cbHeader;
-
-        address = (ULONG_PTR)pbData;
-
-#if UINTPTR_MAX == 0xFFFFFFFFFFFFFFFFu
-        // 64 bit addresses.
-        pbLine[cbLine++] = digits[(address >> 0x3c) & 0x0f];
-        pbLine[cbLine++] = digits[(address >> 0x38) & 0x0f];
-        pbLine[cbLine++] = digits[(address >> 0x34) & 0x0f];
-        pbLine[cbLine++] = digits[(address >> 0x30) & 0x0f];
-        pbLine[cbLine++] = digits[(address >> 0x2c) & 0x0f];
-        pbLine[cbLine++] = digits[(address >> 0x28) & 0x0f];
-        pbLine[cbLine++] = digits[(address >> 0x24) & 0x0f];
-        pbLine[cbLine++] = digits[(address >> 0x20) & 0x0f];
-#endif
-        pbLine[cbLine++] = digits[(address >> 0x1c) & 0x0f];
-        pbLine[cbLine++] = digits[(address >> 0x18) & 0x0f];
-        pbLine[cbLine++] = digits[(address >> 0x14) & 0x0f];
-        pbLine[cbLine++] = digits[(address >> 0x10) & 0x0f];
-        pbLine[cbLine++] = digits[(address >> 0x0c) & 0x0f];
-        pbLine[cbLine++] = digits[(address >> 0x08) & 0x0f];
-        pbLine[cbLine++] = digits[(address >> 0x04) & 0x0f];
-        pbLine[cbLine++] = digits[(address        ) & 0x0f];
-        pbLine[cbLine++] = ' ';
-        pbLine[cbLine++] = ' ';
-
-        for(i = 0; i < count; i++)
-        {
-            pbLine[cbLine++] = digits[pbData[i]>>4];
-            pbLine[cbLine++] = digits[pbData[i]&0x0f];
-            if(i == 7)
-            {
-                pbLine[cbLine++] = ':';
-            }
-            else
-            {
-                pbLine[cbLine++] = ' ';
-            }
-        }
-
-        for(; i < 16; i++)
-        {
-            pbLine[cbLine++] = ' ';
-            pbLine[cbLine++] = ' ';
-            pbLine[cbLine++] = ' ';
-        }
-
-        pbLine[cbLine++] = ' ';
-
-        for(i = 0; i < count; i++)
-        {
-            if(pbData[i] < 32 || pbData[i] > 126)
-            {
-                pbLine[cbLine++] = '.';
-            }
-            else
-            {
-                pbLine[cbLine++] = pbData[i];
-            }
-        }
-
-        pbLine[cbLine++] = 0;
-
-        DbgPrintA("%s\n", pbLine);
-    }
+  return( TRUE );
 }
 
-void DbgDumpRange(PVOID begin, PVOID end, PCSTR format, ...)
-{
-  DbgPrintA("[CProcess::Create] ");
-  va_list args;
-
-  va_start(args, format);
-  DbgPrintA(format, args);
-  va_end(args);
-
-  SIZE_T size = (SIZE_T)end - (SIZE_T)begin;
-  DbgPrintA(" len(%lu): 0x%p - 0x%p\n", size, begin, end);
-  DbgDumpHex((PBYTE)begin, size);
-}
 
 #ifndef UNDER_CE
 static UString GetQuotedString(const UString &s)
@@ -317,6 +211,7 @@ WRes CProcess::Create(LPCWSTR imageName, const UString &params, LPCWSTR curDir,
   else
   #endif
   {
+    // Need to allow inheritance for child process to access pipe.
     SECURITY_ATTRIBUTES sa {
       sizeof(SECURITY_ATTRIBUTES), NULL, TRUE
     };
@@ -325,24 +220,27 @@ WRes CProcess::Create(LPCWSTR imageName, const UString &params, LPCWSTR curDir,
     STARTUPINFOW si{};
     si.cb = sizeof(si);
 
-    if (_readStdout)
+    if (_readOutput)
     {
       // if (!CreatePipe(&_hStdoutRead, &_hStdoutWrite, &sa, 0))
       // {
       //   return (WRes)-1;
       // }
 
-      // NOTE: uncomment this if you want to use WaitAndRunOverlapped, but it has issues.
+      // NOTE: uncomment this and use previous if you want to use WaitAndRunOverlapped, but it has issues.
       if (!MyCreatePipeEx(
-          &_hStdoutRead, &_hStdoutWrite, &sa, 0,
-          FILE_FLAG_OVERLAPPED, 0)
+          &_hStdoutRead, _createPipeOnly == TRUE ? NULL : &_hStdoutWrite, &sa, 0,
+          0, 0)
       )
       {
         return (WRes)-1;
       }
-      si.hStdOutput = _hStdoutWrite;
-      si.hStdError = _hStdoutWrite;
-      si.dwFlags |= STARTF_USESTDHANDLES;
+      if (!_createPipeOnly)
+      {
+        si.hStdOutput = _hStdoutWrite;
+        si.hStdError = _hStdoutWrite;
+        si.dwFlags |= STARTF_USESTDHANDLES;
+      }
     }
 
     if (_overlapWindow)
@@ -390,23 +288,23 @@ WRes CProcess::Create(LPCWSTR imageName, const UString &params, LPCWSTR curDir,
     }
 
     result = CreateProcessW(imageName, params2.Ptr_non_const(),
-        NULL, NULL, _readStdout, CREATE_UNICODE_ENVIRONMENT,
+        NULL, NULL, _readOutput && !_createPipeOnly, CREATE_UNICODE_ENVIRONMENT,
         additionalEnvVar != NULL ? (LPVOID)env.begin() : NULL,
         curDir, &si, &pi);
 
     // Child process will have this handle, we don't need it. When child process
     // exits they will close their instance of this handle and our _hStdoutRead
     // will be signalled.
-    if (_hStdoutWrite)
+    if (_hStdoutWrite != NULL)
     {
       CloseHandle(_hStdoutWrite);
       _hStdoutWrite = NULL;
     }
 
-      if (result == 0)
-      {
-        DbgDumpRange(env.begin(), env.end(), "CreateProcessW failed with GLE %x, dumping env", GetLastError());
-      }
+    if (result == 0)
+    {
+      DbgDumpRange(env.begin(), env.end(), "CreateProcessW failed with GLE %x, dumping env", GetLastError());
+    }
   }
 
   ::CloseHandle(pi.hThread);
@@ -481,6 +379,17 @@ struct CThreadProcessWaitSync
   {
     BOOL bSuccess = FALSE;
 
+    if (owner != nullptr && owner->_createPipeOnly)
+    {
+      BOOL fConnected = ConnectNamedPipe(_hFile, NULL) ?
+          TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);
+      if (!fConnected)
+      {
+        Z7DbgPrintA("ConnectNamedPipe failed\n");
+        return;
+      }
+    }
+
     for (;;)
     {
       bSuccess = ReadFile(_hFile, chBuf, sizeof(chBuf), &dwRead, NULL);
@@ -502,8 +411,15 @@ struct CThreadProcessWaitSync
 
   static THREAD_FUNC_DECL MyThreadFunction(void *param)
   {
-    ((CThreadProcessWaitSync *)param)->Process();
-    delete static_cast<CThreadProcessWaitSync *>(param);
+    try
+    {
+      ((CThreadProcessWaitSync *)param)->Process();
+      delete static_cast<CThreadProcessWaitSync *>(param);
+    }
+    catch (...)
+    {
+      std::exception_ptr p = std::current_exception();
+    }
     return 0;
   }
 };
diff --git a/CPP/Windows/ProcessUtils.h b/CPP/Windows/ProcessUtils.h
index 93a770b..683c8a1 100644
--- a/CPP/Windows/ProcessUtils.h
+++ b/CPP/Windows/ProcessUtils.h
@@ -68,7 +68,8 @@ class CProcess: public CHandle
   CByteVector _readBuffer;
   BOOL _deleteSelf{};
   BOOL _overlapWindow{};
-  BOOL _readStdout{};
+  BOOL _readOutput{};
+  BOOL _createPipeOnly{};
 
   CProcess() : _hStdoutRead(NULL), _hStdoutWrite(NULL) {}
   virtual ~CProcess()
@@ -178,6 +179,7 @@ class CProcess: public CHandle
   WRes WaitAndRunOverlapped(std::function<void(UString)> const& fn);
 };
 
+UString MyGetNextPipeName();
 WRes MyCreateProcess(LPCWSTR imageName, const UString &params);
 
 }
diff --git a/test/pipe.cpp b/test/pipe.cpp
new file mode 100644
index 0000000..74cb17d
--- /dev/null
+++ b/test/pipe.cpp
@@ -0,0 +1,211 @@
+#include <windows.h>
+#include <stdio.h>
+#include <tchar.h>
+#include <strsafe.h>
+
+#define BUFSIZE 512
+
+DWORD WINAPI InstanceThread(LPVOID);
+VOID GetAnswerToRequest(LPTSTR, LPTSTR, LPDWORD);
+
+int _tmain(VOID)
+{
+   BOOL   fConnected = FALSE;
+   DWORD  dwThreadId = 0;
+   HANDLE hPipe = INVALID_HANDLE_VALUE, hThread = NULL;
+   LPCTSTR lpszPipename = TEXT("\\\\.\\pipe\\mynamedpipe");
+
+// The main loop creates an instance of the named pipe and
+// then waits for a client to connect to it. When the client
+// connects, a thread is created to handle communications
+// with that client, and this loop is free to wait for the
+// next client connect request. It is an infinite loop.
+
+   for (;;)
+   {
+      _tprintf( TEXT("\nPipe Server: Main thread awaiting client connection on %s\n"), lpszPipename);
+      hPipe = CreateNamedPipe(
+          lpszPipename,             // pipe name
+          PIPE_ACCESS_DUPLEX,       // read/write access
+          PIPE_TYPE_MESSAGE |       // message type pipe
+          PIPE_READMODE_MESSAGE |   // message-read mode
+          PIPE_WAIT,                // blocking mode
+          PIPE_UNLIMITED_INSTANCES, // max. instances
+          BUFSIZE,                  // output buffer size
+          BUFSIZE,                  // input buffer size
+          0,                        // client time-out
+          NULL);                    // default security attribute
+
+      if (hPipe == INVALID_HANDLE_VALUE)
+      {
+          _tprintf(TEXT("CreateNamedPipe failed, GLE=%d.\n"), GetLastError());
+          return -1;
+      }
+
+      // Wait for the client to connect; if it succeeds,
+      // the function returns a nonzero value. If the function
+      // returns zero, GetLastError returns ERROR_PIPE_CONNECTED.
+
+      fConnected = ConnectNamedPipe(hPipe, NULL) ?
+         TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);
+
+      if (fConnected)
+      {
+         printf("Client connected, creating a processing thread.\n");
+
+         // Create a thread for this client.
+         hThread = CreateThread(
+            NULL,              // no security attribute
+            0,                 // default stack size
+            InstanceThread,    // thread proc
+            (LPVOID) hPipe,    // thread parameter
+            0,                 // not suspended
+            &dwThreadId);      // returns thread ID
+
+         if (hThread == NULL)
+         {
+            _tprintf(TEXT("CreateThread failed, GLE=%d.\n"), GetLastError());
+            return -1;
+         }
+         else CloseHandle(hThread);
+       }
+      else
+        // The client could not connect, so close the pipe.
+         CloseHandle(hPipe);
+   }
+
+   return 0;
+}
+
+DWORD WINAPI InstanceThread(LPVOID lpvParam)
+// This routine is a thread processing function to read from and reply to a client
+// via the open pipe connection passed from the main loop. Note this allows
+// the main loop to continue executing, potentially creating more threads of
+// of this procedure to run concurrently, depending on the number of incoming
+// client connections.
+{
+   HANDLE hHeap      = GetProcessHeap();
+   TCHAR* pchRequest = (TCHAR*)HeapAlloc(hHeap, 0, BUFSIZE*sizeof(TCHAR));
+   TCHAR* pchReply   = (TCHAR*)HeapAlloc(hHeap, 0, BUFSIZE*sizeof(TCHAR));
+
+   DWORD cbBytesRead = 0, cbReplyBytes = 0, cbWritten = 0;
+   BOOL fSuccess = FALSE;
+   HANDLE hPipe  = NULL;
+
+   // Do some extra error checking since the app will keep running even if this
+   // thread fails.
+
+   if (lpvParam == NULL)
+   {
+       printf( "\nERROR - Pipe Server Failure:\n");
+       printf( "   InstanceThread got an unexpected NULL value in lpvParam.\n");
+       printf( "   InstanceThread exitting.\n");
+       if (pchReply != NULL) HeapFree(hHeap, 0, pchReply);
+       if (pchRequest != NULL) HeapFree(hHeap, 0, pchRequest);
+       return (DWORD)-1;
+   }
+
+   if (pchRequest == NULL)
+   {
+       printf( "\nERROR - Pipe Server Failure:\n");
+       printf( "   InstanceThread got an unexpected NULL heap allocation.\n");
+       printf( "   InstanceThread exitting.\n");
+       if (pchReply != NULL) HeapFree(hHeap, 0, pchReply);
+       return (DWORD)-1;
+   }
+
+   if (pchReply == NULL)
+   {
+       printf( "\nERROR - Pipe Server Failure:\n");
+       printf( "   InstanceThread got an unexpected NULL heap allocation.\n");
+       printf( "   InstanceThread exitting.\n");
+       if (pchRequest != NULL) HeapFree(hHeap, 0, pchRequest);
+       return (DWORD)-1;
+   }
+
+   // Print verbose messages. In production code, this should be for debugging only.
+   printf("InstanceThread created, receiving and processing messages.\n");
+
+// The thread's parameter is a handle to a pipe object instance.
+
+   hPipe = (HANDLE) lpvParam;
+
+// Loop until done reading
+   while (1)
+   {
+   // Read client requests from the pipe. This simplistic code only allows messages
+   // up to BUFSIZE characters in length.
+      fSuccess = ReadFile(
+         hPipe,        // handle to pipe
+         pchRequest,    // buffer to receive data
+         BUFSIZE*sizeof(TCHAR), // size of buffer
+         &cbBytesRead, // number of bytes read
+         NULL);        // not overlapped I/O
+
+      if (!fSuccess || cbBytesRead == 0)
+      {
+          if (GetLastError() == ERROR_BROKEN_PIPE)
+          {
+              _tprintf(TEXT("InstanceThread: client disconnected.\n"));
+          }
+          else
+          {
+              _tprintf(TEXT("InstanceThread ReadFile failed, GLE=%d.\n"), GetLastError());
+          }
+          break;
+      }
+
+   // Process the incoming message.
+      GetAnswerToRequest(pchRequest, pchReply, &cbReplyBytes);
+
+   // Write the reply to the pipe.
+      fSuccess = WriteFile(
+         hPipe,        // handle to pipe
+         pchReply,     // buffer to write from
+         cbReplyBytes, // number of bytes to write
+         &cbWritten,   // number of bytes written
+         NULL);        // not overlapped I/O
+
+      if (!fSuccess || cbReplyBytes != cbWritten)
+      {
+          _tprintf(TEXT("InstanceThread WriteFile failed, GLE=%d.\n"), GetLastError());
+          break;
+      }
+  }
+
+// Flush the pipe to allow the client to read the pipe's contents
+// before disconnecting. Then disconnect the pipe, and close the
+// handle to this pipe instance.
+
+   FlushFileBuffers(hPipe);
+   DisconnectNamedPipe(hPipe);
+   CloseHandle(hPipe);
+
+   HeapFree(hHeap, 0, pchRequest);
+   HeapFree(hHeap, 0, pchReply);
+
+   printf("InstanceThread exiting.\n");
+   return 1;
+}
+
+VOID GetAnswerToRequest( LPTSTR pchRequest,
+                         LPTSTR pchReply,
+                         LPDWORD pchBytes )
+// This routine is a simple function to print the client request to the console
+// and populate the reply buffer with a default data string. This is where you
+// would put the actual client request processing code that runs in the context
+// of an instance thread. Keep in mind the main thread will continue to wait for
+// and receive other client connections while the instance thread is working.
+{
+    _tprintf( TEXT("Client Request String:\"%s\"\n"), pchRequest );
+
+    // Check the outgoing message to make sure it's not too long for the buffer.
+    if (FAILED(StringCchCopy( pchReply, BUFSIZE, TEXT("default answer from server") )))
+    {
+        *pchBytes = 0;
+        pchReply[0] = 0;
+        printf("StringCchCopy failed, no outgoing message.\n");
+        return;
+    }
+    *pchBytes = (lstrlen(pchReply)+1)*sizeof(TCHAR);
+}
