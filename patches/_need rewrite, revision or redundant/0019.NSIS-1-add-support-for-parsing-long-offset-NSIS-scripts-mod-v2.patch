From 6abf3e1e12285e86f193c7f1527550dd04440d52 Mon Sep 17 00:00:00 2001
From: BeneficialCode <3123132899@qq.com>
Date: Fri, 26 Jul 2024 18:01:36 +0800
Subject: [PATCH] Added support for parsing long offset NSIS scripts and for
 debug builds.

---
 CPP/7zip/Archive/Nsis/NsisIn.cpp    | 100 +++++++++++++++++++---------
 CPP/7zip/Archive/Nsis/NsisIn.h      |   5 +-
 CPP/7zip/UI/FileManager/resource.rc |   4 +-
 CPP/Build.mak                       |  12 ++--
 4 files changed, 80 insertions(+), 41 deletions(-)

diff --git a/CPP/7zip/Archive/Nsis/NsisIn.cpp b/CPP/7zip/Archive/Nsis/NsisIn.cpp
index c9e2c014d..0c4aff169 100644
--- a/CPP/7zip/Archive/Nsis/NsisIn.cpp
+++ b/CPP/7zip/Archive/Nsis/NsisIn.cpp
@@ -11,6 +11,7 @@
 
 #define Get16(p) GetUi16(p)
 #define Get32(p) GetUi32(p)
+#define Get64(p) GetUi64(p)
 
 // #define NUM_SPEED_TESTS 1000
 
@@ -21,6 +22,7 @@ static const size_t kInputBufSize = 1 << 20;
 
 const Byte kSignature[kSignatureSize] = NSIS_SIGNATURE;
 static const UInt32 kMask_IsCompressed = (UInt32)1 << 31;
+static const UInt64 kMask_IsCompressed64 = ((UInt64)1 << 63);
 
 static const unsigned kNumCommandParams = 6;
 static const unsigned kCmdSize = 4 + kNumCommandParams * 4;
@@ -113,19 +115,20 @@ enum
   EW_FOPEN,             // FileOpen
   EW_FPUTS,             // FileWrite, FileWriteByte
   EW_FGETS,             // FileRead, FileReadByte
+  EW_FSEEK,             // FileSeek
 
   // Park
   // EW_FPUTWS,            // FileWriteUTF16LE, FileWriteWord
   // EW_FGETWS,            // FileReadUTF16LE, FileReadWord
   
-  EW_FSEEK,             // FileSeek
+
   EW_FINDCLOSE,         // FindClose
   EW_FINDNEXT,          // FindNext
   EW_FINDFIRST,         // FindFirst
   EW_WRITEUNINSTALLER,  // WriteUninstaller
   
   // Park : since 2.46.3 the log is enabled in main Park version
-  // EW_LOG,               // LogSet, LogText
+  EW_LOG,               // LogSet, LogText
 
   EW_SECTIONSET,        // Get*, Set*
   EW_INSTTYPESET,       // InstTypeSetText, InstTypeGetText, SetCurInstType, GetCurInstType
@@ -147,17 +150,12 @@ enum
   EW_FPUTWS,            // FileWriteUTF16LE, FileWriteWord
   EW_FGETWS,            // FileReadUTF16LE, FileReadWord
 
-  /*
   // since v3.06 the fllowing IDs codes was moved here:
   // Opcodes listed here are not actually used in exehead. No exehead opcodes should be present after these!
   EW_GETLABELADDR,      // --> EW_ASSIGNVAR
   EW_GETFUNCTIONADDR,   // --> EW_ASSIGNVAR
-  */
-
-  // The following IDs are not IDs in real order.
-  // We just need some IDs to translate eny extended layout to main layout.
+ 
 
-  EW_LOG,               // LogSet, LogText
 
   // Park
   EW_FINDPROC,          // FindProc
@@ -5765,8 +5763,13 @@ HRESULT CInArchive::Open2(const Byte *sig, size_t size)
   #ifdef NSIS_SCRIPT
   AfterHeaderSize = 0;
   #endif
-
-  UInt32 compressedHeaderSize = Get32(sig);
+  Int64 compressedHeaderSize = 0;
+  bool isLongOffset = (FirstHeader.Flags & NFlags::k_BI_LongOffset) != 0;
+  if (isLongOffset) {
+      compressedHeaderSize = Get64(sig);
+  }
+  else
+      compressedHeaderSize = Get32(sig);
   
 
   /*
@@ -5792,12 +5795,15 @@ HRESULT CInArchive::Open2(const Byte *sig, size_t size)
   }
   else if (IsLZMA(sig, DictionarySize, FilterFlag))
     Method = NMethodType::kLZMA;
-  else if (sig[3] == 0x80)
+  else if (sig[3] == 0x80 || sig[7] == 0x80)
   {
+    int offset = 4;
+    if (isLongOffset)
+        offset = 8;
     IsSolid = false;
-    if (IsLZMA(sig + 4, DictionarySize, FilterFlag) && sig[3] == 0x80)
+    if (IsLZMA(sig + offset, DictionarySize, FilterFlag))
       Method = NMethodType::kLZMA;
-    else if (IsBZip2(sig + 4))
+    else if (IsBZip2(sig + offset))
       Method = NMethodType::kBZip2;
     else
       Method = NMethodType::kDeflate;
@@ -5813,10 +5819,20 @@ HRESULT CInArchive::Open2(const Byte *sig, size_t size)
   }
   else
   {
-    _headerIsCompressed = ((compressedHeaderSize & kMask_IsCompressed) != 0);
-    compressedHeaderSize &= ~kMask_IsCompressed;
-    _nonSolidStartOffset = compressedHeaderSize;
-    RINOK(SeekTo(DataStreamOffset + 4))
+    if (isLongOffset)
+    {
+        _headerIsCompressed = ((compressedHeaderSize & kMask_IsCompressed64) != 0);
+        compressedHeaderSize &= ~kMask_IsCompressed64;
+        _nonSolidStartOffset = compressedHeaderSize;
+        RINOK(SeekTo(DataStreamOffset + 8))
+	}
+	else
+	{
+        _headerIsCompressed = ((compressedHeaderSize & kMask_IsCompressed) != 0);
+        compressedHeaderSize &= ~kMask_IsCompressed;
+        _nonSolidStartOffset = compressedHeaderSize;
+        RINOK(SeekTo(DataStreamOffset + 4))
+	}
   }
 
   if (FirstHeader.HeaderSize == 0)
@@ -5832,7 +5848,11 @@ HRESULT CInArchive::Open2(const Byte *sig, size_t size)
   Decoder.IsNsisDeflate = true; // we need some smart check that NSIS is not NSIS3 here.
   
   Decoder.InputStream = _stream;
-  Decoder.Buffer.Alloc(kInputBufSize);
+  size_t allocSize = kInputBufSize;
+  if (allocSize < FirstHeader.HeaderSize) {
+      allocSize = FirstHeader.HeaderSize;
+  }
+  Decoder.Buffer.Alloc(allocSize);
   Decoder.StreamPos = 0;
 
   if (_headerIsCompressed)
@@ -5845,8 +5865,9 @@ HRESULT CInArchive::Open2(const Byte *sig, size_t size)
       RINOK(Decoder.Read(buf, &processedSize))
       if (processedSize != 4)
         return S_FALSE;
-      if (Get32((const Byte *)buf) != FirstHeader.HeaderSize)
-        return S_FALSE;
+      UINT32 realSize = Get32((const Byte*)buf);
+      if (realSize != FirstHeader.HeaderSize)
+          return S_FALSE;
     }
     {
       size_t processedSize = FirstHeader.HeaderSize;
@@ -5953,10 +5974,14 @@ static bool IsArc_Pe(const Byte *p, size_t size)
 HRESULT CInArchive::Open(IInStream *inStream, const UInt64 *maxCheckStartPosition)
 {
   Clear();
-  
+  UInt64 fileSize = 0;
+  RINOK(InStream_GetSize_SeekToEnd(inStream, fileSize));
+
+  RINOK(InStream_SeekSet(inStream, 0));
+
   RINOK(InStream_GetPos(inStream, StartOffset))
   
-  const UInt32 kStartHeaderSize = 4 * 7;
+  UInt32 startHeaderSize = 4 * 7;
   const unsigned kStep = 512; // nsis start is aligned for 512
   Byte buf[kStep];
   UInt64 pos = StartOffset;
@@ -5967,7 +5992,7 @@ HRESULT CInArchive::Open(IInStream *inStream, const UInt64 *maxCheckStartPositio
   {
     bufSize = kStep;
     RINOK(ReadStream(inStream, buf, &bufSize))
-    if (bufSize < kStartHeaderSize)
+    if (bufSize < startHeaderSize)
       return S_FALSE;
     if (memcmp(buf + 4, kSignature, kSignatureSize) == 0)
       break;
@@ -6013,7 +6038,7 @@ HRESULT CInArchive::Open(IInStream *inStream, const UInt64 *maxCheckStartPositio
     bufSize = kStep;
     RINOK(InStream_SeekSet(inStream, pos))
     RINOK(ReadStream(inStream, buf, &bufSize))
-    if (bufSize < kStartHeaderSize)
+    if (bufSize < startHeaderSize)
       return S_FALSE;
   }
 
@@ -6030,18 +6030,45 @@ HRESULT CInArchive::Open(IInStream *inStream, const UInt64 *maxCheckStartPositio
     }
   }
 
-  DataStreamOffset = pos + kStartHeaderSize;
   FirstHeader.Flags = Get32(buf);
-  if ((FirstHeader.Flags & (~kFlagsMask)) != 0)
+ 
+  // We are checking for FH_FLAGS_EXTERNAL_FILE_SUPPORT here, but unfortunately it's value has changed from 32 to 64 in a minor update so this guess is the best we can do
+  IsNSISBI = (FirstHeader.Flags & (32 | 64)) != 0;
+ 
+  if (IsNSISBI)
   {
-    // return E_NOTIMPL;
-    return S_FALSE;
+    startHeaderSize += 4 * 2; // int datablock_lowpart, int datablock_highpart
+    kNumCommandParams = 8;
+    kCmdSize = 4 + kNumCommandParams * 4;
+  }
+ 
+  DataStreamOffset = pos + startHeaderSize;
+ 
+  if ((FirstHeader.Flags & NFlags::k_BI_LongOffset) != 0) {
+      startHeaderSize = 36;
+  }
+  DataStreamOffset = pos + startHeaderSize;
+ 
+  // if fileSize big than 2GB, we should use kFlagsMask2G
+  if ((FirstHeader.Flags & NFlags::k_BI_LongOffset) != 0)
+  {
+    if ((FirstHeader.Flags & (~kFlagsMask2G)) != 0)
+      {
+        return S_FALSE;
+      }
+   }
+   else
+   {
+    if (!IsNSISBI && (FirstHeader.Flags & (~kFlagsMask)) != 0)
+      {
+        return S_FALSE;
+      }
   }
   IsInstaller = (FirstHeader.Flags & NFlags::kUninstall) == 0;
 
   FirstHeader.HeaderSize = Get32(buf + kSignatureSize + 4);
   FirstHeader.ArcSize = Get32(buf + kSignatureSize + 8);
-  if (FirstHeader.ArcSize <= kStartHeaderSize)
+  if (FirstHeader.ArcSize <= startHeaderSize)
     return S_FALSE;
 
   /*
@@ -6071,7 +6116,7 @@ HRESULT CInArchive::Open(IInStream *inStream, const UInt64 *maxCheckStartPositio
     _limitedStreamSpec->SetStream(inStream);
     _limitedStreamSpec->InitAndSeek(pos, FirstHeader.ArcSize);
     DataStreamOffset -= pos;
-    res = Open2(buf + kStartHeaderSize, bufSize - kStartHeaderSize);
+    res = Open2(buf + startHeaderSize, bufSize - startHeaderSize);
   }
   catch(...)
   {
diff --git a/CPP/7zip/Archive/Nsis/NsisIn.h b/CPP/7zip/Archive/Nsis/NsisIn.h
index 1f8c96755..1a333a5b8 100644
--- a/CPP/7zip/Archive/Nsis/NsisIn.h
+++ b/CPP/7zip/Archive/Nsis/NsisIn.h
@@ -18,7 +18,7 @@
 /* If NSIS_SCRIPT is defined, it will decompile NSIS script to [NSIS].nsi file.
    The code is much larger in that case. */
  
-// #define NSIS_SCRIPT
+#define NSIS_SCRIPT
 
 namespace NArchive {
 namespace NNsis {
@@ -30,6 +30,7 @@ extern const Byte kSignature[kSignatureSize];
 #define NSIS_SIGNATURE { 0xEF, 0xBE, 0xAD, 0xDE, 'N', 'u', 'l', 'l', 's', 'o', 'f', 't', 'I', 'n', 's', 't' }
 
 const UInt32 kFlagsMask = 0xF;
+const UInt32 kFlagsMask2G = 0x1FF;
 namespace NFlags
 {
   const UInt32 kUninstall = 1;
@@ -187,7 +188,7 @@ class CInArchive
   UInt64 _fileSize;
   
   bool _headerIsCompressed;
-  UInt32 _nonSolidStartOffset;
+  UInt64 _nonSolidStartOffset;
 
   #ifdef NSIS_SCRIPT
   
diff --git a/CPP/7zip/UI/FileManager/resource.rc b/CPP/7zip/UI/FileManager/resource.rc
index feeeaf5c9..d869124cf 100644
--- a/CPP/7zip/UI/FileManager/resource.rc
+++ b/CPP/7zip/UI/FileManager/resource.rc
@@ -159,9 +159,7 @@ END
 
 IDI_ICON  ICON  "../../UI/FileManager/FM.ico"
 
-#ifndef UNDER_CE
-1  24  MOVEABLE PURE   "../../UI/FileManager/7zFM.exe.manifest"
-#endif
+
 
 IDB_ADD        BITMAP  "../../UI/FileManager/Add.bmp"
 IDB_EXTRACT    BITMAP  "../../UI/FileManager/Extract.bmp"
 
 