From 2052419e924903ac4f824663da0610888f973745 Mon Sep 17 00:00:00 2001
From: ozone10 <positronix10@gmail.com>
Date: Sat, 31 May 2025 17:44:00 +0200
Subject: [PATCH] Apply dark mode on listview checkboxes on Windows 11

---
 CPP/7zip/UI/FileManager/MenuPage.cpp |   4 +
 DarkMode/DarkMode.cpp                |  69 ++--
 DarkMode/DarkModeSubclass.cpp        | 469 +++++++++++++++++----------
 DarkMode/DarkModeSubclass.h          |  82 +++++
 4 files changed, 417 insertions(+), 207 deletions(-)

diff --git a/CPP/7zip/UI/FileManager/MenuPage.cpp b/CPP/7zip/UI/FileManager/MenuPage.cpp
index e8736b844..7956b0939 100644
--- a/CPP/7zip/UI/FileManager/MenuPage.cpp
+++ b/CPP/7zip/UI/FileManager/MenuPage.cpp
@@ -22,6 +22,8 @@
 #include "MenuPage.h"
 #include "MenuPageRes.h"
 
+#include "../../../../DarkMode/DarkModeSubclass.h"
+
 
 using namespace NWindows;
 using namespace NContextMenuFlags;
@@ -283,6 +285,8 @@ bool CMenuPage::OnInit()
   _listView.SetColumnWidthAuto(0);
   _initMode = false;
 
+  DarkMode::setDarkListviewCheckboxes(_listView);
+
   return CPropertyPage::OnInit();
 }
 
diff --git a/DarkMode/DarkMode.cpp b/DarkMode/DarkMode.cpp
index 07ccdfe5c..e12b8b70c 100644
--- a/DarkMode/DarkMode.cpp
+++ b/DarkMode/DarkMode.cpp
@@ -35,14 +35,6 @@ extern PIMAGE_THUNK_DATA FindDelayLoadThunkInModule(void* moduleBase, const char
 extern PIMAGE_THUNK_DATA FindDelayLoadThunkInModule(void* moduleBase, const char* dllName, uint16_t ordinal);
 #endif
 
-#if defined(__GNUC__) && (__GNUC__ > 8)
-#define WINAPI_LAMBDA_RETURN(return_t) -> return_t WINAPI
-#elif defined(__GNUC__)
-#define WINAPI_LAMBDA_RETURN(return_t) WINAPI -> return_t
-#else
-#define WINAPI_LAMBDA_RETURN(return_t) -> return_t
-#endif
-
 #if defined(_MSC_VER) && _MSC_VER >= 1800
 #pragma warning(disable : 4191)
 #endif
@@ -68,10 +60,17 @@ struct ModuleHandle
 {
 	HMODULE hModule = nullptr;
 
+	ModuleHandle() = delete;
+
 	explicit ModuleHandle(const wchar_t* moduleName)
 		: hModule(LoadLibraryEx(moduleName, nullptr, LOAD_LIBRARY_SEARCH_SYSTEM32))
-	{
-	}
+	{}
+
+	ModuleHandle(const ModuleHandle&) = delete;
+	ModuleHandle& operator=(const ModuleHandle&) = delete;
+
+	ModuleHandle(ModuleHandle&&) = delete;
+	ModuleHandle& operator=(ModuleHandle&&) = delete;
 
 	~ModuleHandle()
 	{
@@ -81,12 +80,6 @@ struct ModuleHandle
 		}
 	}
 
-	ModuleHandle(const ModuleHandle&) = delete;
-	ModuleHandle& operator=(const ModuleHandle&) = delete;
-
-	ModuleHandle(ModuleHandle&&) = delete;
-	ModuleHandle& operator=(ModuleHandle&&) = delete;
-
 	[[nodiscard]] HMODULE get() const
 	{
 		return hModule;
@@ -321,6 +314,19 @@ static bool IsWindowOrParentUsingDarkScrollBar(HWND hwnd)
 	return false;
 }
 
+static HTHEME WINAPI MyOpenNcThemeData(HWND hWnd, LPCWSTR pszClassList)
+{
+	if (wcscmp(pszClassList, WC_SCROLLBAR) == 0)
+	{
+		if (IsWindowOrParentUsingDarkScrollBar(hWnd))
+		{
+			hWnd = nullptr;
+			pszClassList = L"Explorer::ScrollBar";
+		}
+	}
+	return _OpenNcThemeData(hWnd, pszClassList);
+};
+
 static void FixDarkScrollBar()
 {
 	ModuleHandle moduleComctl(L"comctl32.dll");
@@ -332,20 +338,7 @@ static void FixDarkScrollBar()
 			DWORD oldProtect = 0;
 			if ((VirtualProtect(addr, sizeof(IMAGE_THUNK_DATA), PAGE_READWRITE, &oldProtect) == TRUE) && (_OpenNcThemeData != nullptr))
 			{
-				auto MyOpenThemeData = [](HWND hWnd, LPCWSTR classList) WINAPI_LAMBDA_RETURN(HTHEME)
-				{
-					if (wcscmp(classList, WC_SCROLLBAR) == 0)
-					{
-						if (IsWindowOrParentUsingDarkScrollBar(hWnd))
-						{
-							hWnd = nullptr;
-							classList = L"Explorer::ScrollBar";
-						}
-					}
-					return _OpenNcThemeData(hWnd, classList);
-				};
-
-				addr->u1.Function = reinterpret_cast<uintptr_t>(static_cast<fnOpenNcThemeData>(MyOpenThemeData));
+				addr->u1.Function = reinterpret_cast<uintptr_t>(static_cast<fnOpenNcThemeData>(MyOpenNcThemeData));
 				VirtualProtect(addr, sizeof(IMAGE_THUNK_DATA), oldProtect, &oldProtect);
 			}
 		}
@@ -425,13 +418,13 @@ void InitDarkMode()
 #endif
 					ptrFnOrd135NotNullptr = loadFn(hUxtheme, _SetPreferredAppMode, 135);
 
-				if (ptrFnOrd135NotNullptr &&
-					loadFn(hUxtheme, _OpenNcThemeData, 49) &&
-					loadFn(hUxtheme, _RefreshImmersiveColorPolicyState, 104) &&
-					loadFn(hUxtheme, _ShouldAppsUseDarkMode, 132) &&
-					loadFn(hUxtheme, _AllowDarkModeForWindow, 133) &&
-					loadFn(hUxtheme, _FlushMenuThemes, 136) &&
-					loadFn(hUxtheme, _IsDarkModeAllowedForWindow, 137))
+				if (ptrFnOrd135NotNullptr
+					&& loadFn(hUxtheme, _OpenNcThemeData, 49)
+					&& loadFn(hUxtheme, _RefreshImmersiveColorPolicyState, 104)
+					&& loadFn(hUxtheme, _ShouldAppsUseDarkMode, 132)
+					&& loadFn(hUxtheme, _AllowDarkModeForWindow, 133)
+					&& loadFn(hUxtheme, _FlushMenuThemes, 136)
+					&& loadFn(hUxtheme, _IsDarkModeAllowedForWindow, 137))
 				{
 					g_darkModeSupported = true;
 				}
@@ -551,7 +544,7 @@ bool HookSysColor()
 			auto* addr = FindIatThunkInModule(moduleComctl.get(), "user32.dll", "GetSysColor");
 			if (addr != nullptr)
 			{
-				_GetSysColor = ReplaceFunction(addr, static_cast<fnGetSysColor>(MyGetSysColor));
+				_GetSysColor = ReplaceFunction<fnGetSysColor>(addr, MyGetSysColor);
 				g_isGetSysColorHooked = true;
 			}
 			else
diff --git a/DarkMode/DarkModeSubclass.cpp b/DarkMode/DarkModeSubclass.cpp
index 0477c2c57..e4007cafd 100644
--- a/DarkMode/DarkModeSubclass.cpp
+++ b/DarkMode/DarkModeSubclass.cpp
@@ -53,13 +53,8 @@
 #include "Version.h"
 
 #ifdef __GNUC__
-#define WINAPI_LAMBDA WINAPI
-#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE
 #define DWMWA_USE_IMMERSIVE_DARK_MODE 20
-#endif
 constexpr int CP_DROPDOWNITEM = 9; // for some reason mingw use only enum up to 8
-#else
-#define WINAPI_LAMBDA
 #endif
 
 #ifndef WM_DPICHANGED
@@ -98,7 +93,7 @@ static constexpr COLORREF HEXRGB(DWORD rrggbb)
 static std::wstring getWndClassName(HWND hWnd)
 {
 	constexpr int strLen = 32;
-	std::wstring className(strLen, 0);
+	std::wstring className(strLen, L'\0');
 	className.resize(static_cast<size_t>(::GetClassNameW(hWnd, className.data(), strLen)));
 	return className;
 }
@@ -609,7 +604,7 @@ namespace DarkMode
 	}
 
 	static ColorsView darkColorsView{
-		HEXRGB(0x292F34),   // background
+		HEXRGB(0x293134),   // background
 		HEXRGB(0xE0E2E4),   // text
 		HEXRGB(0x646464),   // gridlines
 		HEXRGB(0x202020),   // Header background
@@ -1012,7 +1007,7 @@ namespace DarkMode
 			const bool useDark = g_dmType == DarkModeType::dark;
 			if (useDark)
 			{
-				DarkMode::getTheme()._colors = DarkMode::darkColors;
+				DarkMode::getTheme()._colors = DarkMode::darkCustomizedColors;
 				DarkMode::getThemeView()._clrView = DarkMode::darkColorsView;
 			}
 			else
@@ -1117,7 +1112,7 @@ namespace DarkMode
 		LPCWSTR lpSubKey = L"Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize";
 		LPCWSTR lpValue = L"AppsUseLightTheme";
 
-		auto result = ::RegGetValueW(HKEY_CURRENT_USER, lpSubKey, lpValue, RRF_RT_REG_DWORD, nullptr, &data, &dwBufSize);
+		const auto result = ::RegGetValueW(HKEY_CURRENT_USER, lpSubKey, lpValue, RRF_RT_REG_DWORD, nullptr, &data, &dwBufSize);
 		if (result != ERROR_SUCCESS)
 		{
 			return false;
@@ -1489,7 +1484,8 @@ namespace DarkMode
 		const auto nStyle = ::GetWindowLongPtr(hWnd, GWL_STYLE);
 		const auto nBtnStyle = nStyle & BS_TYPEMASK;
 
-		int iPartID = BP_CHECKBOX;
+		int iPartID = 0;
+		int iStateID = 0;
 
 		switch (nBtnStyle)
 		{
@@ -1499,6 +1495,15 @@ namespace DarkMode
 			case BS_AUTO3STATE:
 			{
 				iPartID = BP_CHECKBOX;
+
+				if (::IsWindowEnabled(hWnd) == FALSE) iStateID = CBS_UNCHECKEDDISABLED;
+				else if ((nState & BST_PUSHED) == BST_PUSHED) iStateID = CBS_UNCHECKEDPRESSED;
+				else if ((nState & BST_HOT) == BST_HOT) iStateID = CBS_UNCHECKEDHOT;
+				else iStateID = CBS_UNCHECKEDNORMAL;
+
+				if ((nState & BST_CHECKED) == BST_CHECKED) iStateID += 4;
+				else if ((nState & BST_INDETERMINATE) == BST_INDETERMINATE) iStateID += 8;
+
 				break;
 			}
 
@@ -1506,25 +1511,26 @@ namespace DarkMode
 			case BS_AUTORADIOBUTTON:
 			{
 				iPartID = BP_RADIOBUTTON;
+
+				if (::IsWindowEnabled(hWnd) == FALSE) iStateID = RBS_UNCHECKEDDISABLED;
+				else if ((nState & BST_PUSHED) == BST_PUSHED) iStateID = RBS_UNCHECKEDPRESSED;
+				else if ((nState & BST_HOT) == BST_HOT) iStateID = RBS_UNCHECKEDHOT;
+				else iStateID = RBS_UNCHECKEDNORMAL;
+
+				if ((nState & BST_CHECKED) == BST_CHECKED) iStateID += 4;
+
 				break;
 			}
 
-			default:
+			default: // should never happen
 			{
+				iPartID = BP_CHECKBOX;
+				iStateID = CBS_UNCHECKEDDISABLED;
 				// assert(false);
 				break;
 			}
 		}
 
-		// states of BP_CHECKBOX and BP_RADIOBUTTON are the same
-		int iStateID = RBS_UNCHECKEDNORMAL;
-
-		if (::IsWindowEnabled(hWnd) == FALSE)           iStateID = RBS_UNCHECKEDDISABLED;
-		else if ((nState & BST_PUSHED) == BST_PUSHED)   iStateID = RBS_UNCHECKEDPRESSED;
-		else if ((nState & BST_HOT) == BST_HOT)         iStateID = RBS_UNCHECKEDHOT;
-
-		if ((nState & BST_CHECKED) == BST_CHECKED)      iStateID += 4;
-
 		if (::BufferedPaintRenderAnimation(hWnd, hdc) == TRUE)
 		{
 			return;
@@ -2112,7 +2118,7 @@ namespace DarkMode
 
 				if (bufferData.ensureBuffer(hdc, rcClient))
 				{
-					int savedState = ::SaveDC(hMemDC);
+					const int savedState = ::SaveDC(hMemDC);
 					::IntersectClipRect(
 						hMemDC,
 						ps.rcPaint.left, ps.rcPaint.top, ps.rcPaint.right, ps.rcPaint.bottom
@@ -2365,7 +2371,7 @@ namespace DarkMode
 				}
 
 				PAINTSTRUCT ps{};
-				auto hdc = ::BeginPaint(hWnd, &ps);
+				HDC hdc = ::BeginPaint(hWnd, &ps);
 
 				if (ps.rcPaint.right <= ps.rcPaint.left || ps.rcPaint.bottom <= ps.rcPaint.top)
 				{
@@ -2378,7 +2384,7 @@ namespace DarkMode
 
 				if (pTabBufferData->ensureBuffer(hdc, rcClient))
 				{
-					int savedState = ::SaveDC(hMemDC);
+					const int savedState = ::SaveDC(hMemDC);
 					::IntersectClipRect(
 						hMemDC,
 						ps.rcPaint.left, ps.rcPaint.top, ps.rcPaint.right, ps.rcPaint.bottom
@@ -2742,7 +2748,7 @@ namespace DarkMode
 
 		HBRUSH hSelectedBrush = isDisabled ? DarkMode::getDlgBackgroundBrush() : (isHot ? DarkMode::getHotBackgroundBrush() : DarkMode::getCtrlBackgroundBrush());
 
-		// CBS_DROPDOWN text is handled by parent by WM_CTLCOLOREDIT
+		// CBS_DROPDOWN and CBS_SIMPLE text is handled by parent by WM_CTLCOLOREDIT
 		if (comboboxData._cbStyle == CBS_DROPDOWNLIST)
 		{
 			// erase background on item change
@@ -2781,7 +2787,7 @@ namespace DarkMode
 				::DrawFocusRect(hdc, &cbi.rcItem);
 			}
 		}
-		else if (comboboxData._cbStyle == CBS_DROPDOWN && cbi.hwndItem != nullptr)
+		else if (cbi.hwndItem != nullptr)
 		{
 			hasFocus = ::GetFocus() == cbi.hwndItem;
 
@@ -2810,22 +2816,34 @@ namespace DarkMode
 		{
 			::ExcludeClipRect(hdc, rcClient.left + 1, rcClient.top + 1, rcClient.right - 1, rcClient.bottom - 1);
 		}
-		else if (comboboxData._cbStyle == CBS_DROPDOWN)
+		else
 		{
-			POINT edge[]{
-				{rcArrow.left - 1, rcArrow.top},
-				{rcArrow.left - 1, rcArrow.bottom}
-			};
-
-			::Polyline(hdc, edge, _countof(edge));
-
 			::ExcludeClipRect(hdc, cbi.rcItem.left, cbi.rcItem.top, cbi.rcItem.right, cbi.rcItem.bottom);
-			::ExcludeClipRect(hdc, rcArrow.left - 1, rcArrow.top, rcArrow.right, rcArrow.bottom);
+
+			if (comboboxData._cbStyle == CBS_SIMPLE && cbi.hwndList != nullptr)
+			{
+				RECT rcItem{ cbi.rcItem };
+				::MapWindowPoints(cbi.hwndItem, hWnd, reinterpret_cast<LPPOINT>(&rcItem), 2);
+				rcClient.bottom = rcItem.bottom;
+			}
 
 			HPEN hPen = ::CreatePen(PS_SOLID, 1, isDisabled ? DarkMode::getDlgBackgroundColor() : DarkMode::getBackgroundColor());
 			RECT rcInner{ rcClient };
 			::InflateRect(&rcInner, -1, -1);
-			rcInner.right = rcArrow.left - 1;
+
+			if (comboboxData._cbStyle == CBS_DROPDOWN)
+			{
+				POINT edge[]{
+					{rcArrow.left - 1, rcArrow.top},
+					{rcArrow.left - 1, rcArrow.bottom}
+				};
+				::Polyline(hdc, edge, _countof(edge));
+
+				::ExcludeClipRect(hdc, rcArrow.left - 1, rcArrow.top, rcArrow.right, rcArrow.bottom);
+
+				rcInner.right = rcArrow.left - 1;
+			}
+
 			DarkMode::paintRoundFrameRect(hdc, rcInner, hPen);
 			::DeleteObject(hPen);
 			::InflateRect(&rcInner, -1, -1);
@@ -2886,7 +2904,7 @@ namespace DarkMode
 				}
 
 				PAINTSTRUCT ps{};
-				auto hdc = ::BeginPaint(hWnd, &ps);
+				HDC hdc = ::BeginPaint(hWnd, &ps);
 
 				if (pComboboxData->_cbStyle != CBS_DROPDOWN)
 				{
@@ -2901,7 +2919,7 @@ namespace DarkMode
 
 					if (bufferData.ensureBuffer(hdc, rcClient))
 					{
-						int savedState = ::SaveDC(hMemDC);
+						const int savedState = ::SaveDC(hMemDC);
 						::IntersectClipRect(
 							hMemDC,
 							ps.rcPaint.left, ps.rcPaint.top, ps.rcPaint.right, ps.rcPaint.bottom
@@ -2974,14 +2992,21 @@ namespace DarkMode
 	{
 		const auto nStyle = ::GetWindowLongPtr(hWnd, GWL_STYLE);
 
-		if ((nStyle & CBS_DROPDOWNLIST) == CBS_DROPDOWNLIST || (nStyle & CBS_DROPDOWN) == CBS_DROPDOWN)
+		if ((nStyle & CBS_DROPDOWNLIST) == CBS_DROPDOWNLIST
+			|| (nStyle & CBS_DROPDOWN) == CBS_DROPDOWN
+			|| (nStyle & CBS_SIMPLE) == CBS_SIMPLE)
 		{
 			COMBOBOXINFO cbi{};
 			cbi.cbSize = sizeof(COMBOBOXINFO);
 			if (::GetComboBoxInfo(hWnd, &cbi) == TRUE)
 			{
-				if (p._theme && cbi.hwndList)
+				if (p._theme && cbi.hwndList != nullptr)
 				{
+					if ((nStyle & CBS_SIMPLE) == CBS_SIMPLE)
+					{
+						DarkMode::replaceClientEdgeWithBorderSafe(cbi.hwndList);
+					}
+
 					//dark scrollbar for listbox of combobox
 					::SetWindowTheme(cbi.hwndList, p._themeClassName, nullptr);
 				}
@@ -3207,6 +3232,7 @@ namespace DarkMode
 			ListView_SetBkColor(hWnd, DarkMode::getViewBackgroundColor());
 
 			DarkMode::setDarkListView(hWnd);
+			DarkMode::setDarkListviewCheckboxes(hWnd);
 			DarkMode::setDarkTooltips(hWnd, DarkMode::ToolTipsType::listview);
 		}
 
@@ -3215,8 +3241,8 @@ namespace DarkMode
 			HWND hHeader = ListView_GetHeader(hWnd);
 			DarkMode::setDarkHeader(hHeader);
 
-			const auto nExStyle = ListView_GetExtendedListViewStyle(hWnd);
-			ListView_SetExtendedListViewStyle(hWnd, nExStyle | LVS_EX_DOUBLEBUFFER);
+			const auto lvExStyle = ListView_GetExtendedListViewStyle(hWnd);
+			ListView_SetExtendedListViewStyle(hWnd, lvExStyle | LVS_EX_DOUBLEBUFFER);
 			DarkMode::setListViewCtrlSubclass(hWnd);
 		}
 	}
@@ -3410,7 +3436,7 @@ namespace DarkMode
 				}
 
 				PAINTSTRUCT ps{};
-				auto hdc = ::BeginPaint(hWnd, &ps);
+				HDC hdc = ::BeginPaint(hWnd, &ps);
 
 				if (ps.rcPaint.right <= ps.rcPaint.left || ps.rcPaint.bottom <= ps.rcPaint.top)
 				{
@@ -3423,7 +3449,7 @@ namespace DarkMode
 
 				if (bufferData.ensureBuffer(hdc, rcClient))
 				{
-					int savedState = ::SaveDC(hMemDC);
+					const int savedState = ::SaveDC(hMemDC);
 					::IntersectClipRect(
 						hMemDC,
 						ps.rcPaint.left, ps.rcPaint.top, ps.rcPaint.right, ps.rcPaint.bottom
@@ -3579,16 +3605,17 @@ namespace DarkMode
 		std::wstring str;
 		RECT rcPart{};
 		RECT rcIntersect{};
+		const int iLastDiv = nParts - (hasSizeGrip ? 1 : 0);
+		const bool drawEdge = (nParts >= 2 || !hasSizeGrip);
 		for (int i = 0; i < nParts; ++i)
 		{
 			::SendMessage(hWnd, SB_GETRECT, static_cast<WPARAM>(i), reinterpret_cast<LPARAM>(&rcPart));
-			if (::IntersectRect(&rcIntersect, &rcPart, &rcClient) == 0)
+			if (::IntersectRect(&rcIntersect, &rcPart, &rcClient) == FALSE)
 			{
 				continue;
 			}
 
-			const int lastDiv = hasSizeGrip ? 1 : 0;
-			if ((i < nParts - lastDiv) && (nParts >= 2 || !hasSizeGrip))
+			if (drawEdge && (i < iLastDiv))
 			{
 				POINT edges[]{
 					{rcPart.right - borders.between, rcPart.top + 1},
@@ -3612,7 +3639,7 @@ namespace DarkMode
 
 			if (ownerDraw)
 			{
-				auto id = static_cast<UINT>(::GetDlgCtrlID(hWnd));
+				const auto id = static_cast<UINT>(::GetDlgCtrlID(hWnd));
 				DRAWITEMSTRUCT dis{
 					0
 					, 0
@@ -3705,7 +3732,7 @@ namespace DarkMode
 				}
 
 				PAINTSTRUCT ps{};
-				auto hdc = ::BeginPaint(hWnd, &ps);
+				HDC hdc = ::BeginPaint(hWnd, &ps);
 
 				if (ps.rcPaint.right <= ps.rcPaint.left || ps.rcPaint.bottom <= ps.rcPaint.top)
 				{
@@ -3718,7 +3745,7 @@ namespace DarkMode
 
 				if (bufferData.ensureBuffer(hdc, rcClient))
 				{
-					int savedState = ::SaveDC(hMemDC);
+					const int savedState = ::SaveDC(hMemDC);
 					::IntersectClipRect(
 						hMemDC,
 						ps.rcPaint.left, ps.rcPaint.top, ps.rcPaint.right, ps.rcPaint.bottom
@@ -3889,7 +3916,7 @@ namespace DarkMode
 				}
 
 				PAINTSTRUCT ps{};
-				auto hdc = ::BeginPaint(hWnd, &ps);
+				HDC hdc = ::BeginPaint(hWnd, &ps);
 
 				if (ps.rcPaint.right <= ps.rcPaint.left || ps.rcPaint.bottom <= ps.rcPaint.top)
 				{
@@ -3902,7 +3929,7 @@ namespace DarkMode
 
 				if (bufferData.ensureBuffer(hdc, rcClient))
 				{
-					int savedState = ::SaveDC(hMemDC);
+					const int savedState = ::SaveDC(hMemDC);
 					::IntersectClipRect(
 						hMemDC,
 						ps.rcPaint.left, ps.rcPaint.top, ps.rcPaint.right, ps.rcPaint.bottom
@@ -4103,137 +4130,144 @@ namespace DarkMode
 		}
 	}
 
-	void setChildCtrlsSubclassAndTheme(HWND hParent, bool subclass, bool theme)
+	static BOOL CALLBACK DarkEnumChildProc(HWND hWnd, LPARAM lParam)
 	{
-		DarkModeParams p{
-			DarkMode::isExperimentalActive() ? L"DarkMode_Explorer" : nullptr
-			, subclass
-			, theme
-		};
+		const auto& p = *reinterpret_cast<DarkModeParams*>(lParam);
+		std::wstring className = getWndClassName(hWnd);
 
-		::EnumChildWindows(hParent, [](HWND hWnd, LPARAM lParam) WINAPI_LAMBDA {
-			const auto& p = *reinterpret_cast<DarkModeParams*>(lParam);
-			std::wstring className = getWndClassName(hWnd);
+		if (className == WC_BUTTON)
+		{
+			DarkMode::setBtnCtrlSubclassAndTheme(hWnd, p);
+			return TRUE;
+		}
 
-			if (className == WC_BUTTON)
-			{
-				DarkMode::setBtnCtrlSubclassAndTheme(hWnd, p);
-				return TRUE;
-			}
+		if (className == WC_STATIC)
+		{
+			DarkMode::setStaticTextCtrlSubclass(hWnd, p);
+			return TRUE;
+		}
 
-			if (className == WC_STATIC)
-			{
-				DarkMode::setStaticTextCtrlSubclass(hWnd, p);
-				return TRUE;
-			}
+		if (className == WC_COMBOBOX)
+		{
+			DarkMode::setComboBoxCtrlSubclassAndTheme(hWnd, p);
+			return TRUE;
+		}
 
-			if (className == WC_COMBOBOX)
-			{
-				DarkMode::setComboBoxCtrlSubclassAndTheme(hWnd, p);
-				return TRUE;
-			}
+		if (className == WC_EDIT)
+		{
+			DarkMode::setCustomBorderForListBoxOrEditCtrlSubclassAndTheme(hWnd, p, false);
+			return TRUE;
+		}
 
-			if (className == WC_EDIT)
-			{
-				DarkMode::setCustomBorderForListBoxOrEditCtrlSubclassAndTheme(hWnd, p, false);
-				return TRUE;
-			}
+		if (className == WC_LISTBOX)
+		{
+			DarkMode::setCustomBorderForListBoxOrEditCtrlSubclassAndTheme(hWnd, p, true);
+			return TRUE;
+		}
 
-			if (className == WC_LISTBOX)
-			{
-				DarkMode::setCustomBorderForListBoxOrEditCtrlSubclassAndTheme(hWnd, p, true);
-				return TRUE;
-			}
+		if (className == WC_LISTVIEW)
+		{
+			DarkMode::setListViewCtrlSubclassAndTheme(hWnd, p);
+			return TRUE;
+		}
 
-			if (className == WC_LISTVIEW)
-			{
-				DarkMode::setListViewCtrlSubclassAndTheme(hWnd, p);
-				return TRUE;
-			}
+		if (className == WC_TREEVIEW)
+		{
+			DarkMode::setTreeViewCtrlTheme(hWnd, p);
+			return TRUE;
+		}
 
-			if (className == WC_TREEVIEW)
-			{
-				DarkMode::setTreeViewCtrlTheme(hWnd, p);
-				return TRUE;
-			}
+		if (className == TOOLBARCLASSNAME)
+		{
+			DarkMode::setToolbarCtrlTheme(hWnd, p);
+			return TRUE;
+		}
 
-			if (className == TOOLBARCLASSNAME)
-			{
-				DarkMode::setToolbarCtrlTheme(hWnd, p);
-				return TRUE;
-			}
+		if (className == UPDOWN_CLASS)
+		{
+			DarkMode::setUpDownCtrlSubclassAndTheme(hWnd, p);
+			return TRUE;
+		}
 
-			if (className == UPDOWN_CLASS)
-			{
-				DarkMode::setUpDownCtrlSubclassAndTheme(hWnd, p);
-				return TRUE;
-			}
+		if (className == WC_TABCONTROL)
+		{
+			DarkMode::setTabCtrlSubclassAndTheme(hWnd, p);
+			return TRUE;
+		}
 
-			if (className == WC_TABCONTROL)
-			{
-				DarkMode::setTabCtrlSubclassAndTheme(hWnd, p);
-				return TRUE;
-			}
+		if (className == STATUSCLASSNAME)
+		{
+			DarkMode::setStatusBarCtrlSubclass(hWnd, p);
+			return TRUE;
+		}
 
-			if (className == STATUSCLASSNAME)
+		if (className == WC_SCROLLBAR)
+		{
+			if (p._theme)
 			{
-				DarkMode::setStatusBarCtrlSubclass(hWnd, p);
-				return TRUE;
+				DarkMode::setDarkScrollBar(hWnd);
 			}
+			return TRUE;
+		}
 
-			if (className == WC_SCROLLBAR)
-			{
-				if (p._theme)
-				{
-					DarkMode::setDarkScrollBar(hWnd);
-				}
-				return TRUE;
-			}
+		if (className == WC_COMBOBOXEX)
+		{
+			DarkMode::setComboBoxExCtrlSubclass(hWnd, p);
+			return TRUE;
+		}
 
-			if (className == WC_COMBOBOXEX)
-			{
-				DarkMode::setComboBoxExCtrlSubclass(hWnd, p);
-				return TRUE;
-			}
+		if (className == PROGRESS_CLASS)
+		{
+			DarkMode::setProgressBarCtrlSubclass(hWnd, p);
+			return TRUE;
+		}
 
-			if (className == PROGRESS_CLASS)
-			{
-				DarkMode::setProgressBarCtrlSubclass(hWnd, p);
-				return TRUE;
-			}
+		if (className == WC_LINK)
+		{
+			DarkMode::enableSysLinkCtrlCtlColor(hWnd, p);
+			return TRUE;
+		}
 
-			if (className == WC_LINK)
-			{
-				DarkMode::enableSysLinkCtrlCtlColor(hWnd, p);
-				return TRUE;
-			}
+		if (className == RICHEDIT_CLASS || className == MSFTEDIT_CLASS)
+		{
+			DarkMode::setRichEditCtrlTheme(hWnd, p);
+			return TRUE;
+		}
 
-			if (className == RICHEDIT_CLASS || className == MSFTEDIT_CLASS)
-			{
-				DarkMode::setRichEditCtrlTheme(hWnd, p);
-				return TRUE;
-			}
+		/*
+		// for debugging
+		if (className == L"#32770")
+		{
+			return TRUE;
+		}
 
-			/*
-			// for debugging
-			if (className == L"#32770")
-			{
-				return TRUE;
-			}
+		if (className == TRACKBAR_CLASS)
+		{
+			return TRUE;
+		}
+		*/
 
-			if (className == TRACKBAR_CLASS)
-			{
-				return TRUE;
-			}
-			*/
+		return TRUE;
+	}
 
-			return TRUE;
-		}, reinterpret_cast<LPARAM>(&p));
+	void setChildCtrlsSubclassAndTheme(HWND hParent, bool subclass, bool theme)
+	{
+		DarkModeParams p{
+			DarkMode::isExperimentalActive() ? L"DarkMode_Explorer" : nullptr
+			, subclass
+			, theme
+		};
+
+		::EnumChildWindows(hParent, DarkMode::DarkEnumChildProc, reinterpret_cast<LPARAM>(&p));
 	}
 
 	void setChildCtrlsTheme(HWND hParent)
 	{
-		setChildCtrlsSubclassAndTheme(hParent, false, DarkMode::isWindows10());
+#if defined(_DARKMODELIB_ALLOW_OLD_OS)
+		DarkMode::setChildCtrlsSubclassAndTheme(hParent, false, true);
+#else
+		DarkMode::setChildCtrlsSubclassAndTheme(hParent, false, DarkMode::isWindows10());
+#endif
 	}
 
 	constexpr auto g_WindowEraseBgSubclassID = static_cast<UINT_PTR>(DarkMode::SubclassID::eraseBg);
@@ -4426,10 +4460,10 @@ namespace DarkMode
 				tbi.dwMask = TBIF_IMAGE | TBIF_STYLE;
 				::SendMessage(lptbcd->nmcd.hdr.hwndFrom, TB_GETBUTTONINFO, lptbcd->nmcd.dwItemSpec, reinterpret_cast<LPARAM>(&tbi));
 				const bool isIcon = tbi.iImage != I_IMAGENONE;
-				const bool isDropDown = (tbi.fsStyle & BTNS_DROPDOWN) == BTNS_DROPDOWN && isIcon;
+				const bool isDropDown = ((tbi.fsStyle & BTNS_DROPDOWN) == BTNS_DROPDOWN) && isIcon;
 				if (isDropDown)
 				{
-					auto idx = ::SendMessage(lptbcd->nmcd.hdr.hwndFrom, TB_COMMANDTOINDEX, lptbcd->nmcd.dwItemSpec, 0);
+					const auto idx = ::SendMessage(lptbcd->nmcd.hdr.hwndFrom, TB_COMMANDTOINDEX, lptbcd->nmcd.dwItemSpec, 0);
 					::SendMessage(lptbcd->nmcd.hdr.hwndFrom, TB_GETITEMDROPDOWNRECT, static_cast<WPARAM>(idx), reinterpret_cast<LPARAM>(&rcDrop));
 
 					rcItem.right = rcDrop.left;
@@ -4500,7 +4534,7 @@ namespace DarkMode
 				auto holdFont = static_cast<HFONT>(::SelectObject(lptbcd->nmcd.hdc, hFont));
 
 				RECT rcArrow{};
-				auto idx = ::SendMessage(lptbcd->nmcd.hdr.hwndFrom, TB_COMMANDTOINDEX, lptbcd->nmcd.dwItemSpec, 0);
+				const auto idx = ::SendMessage(lptbcd->nmcd.hdr.hwndFrom, TB_COMMANDTOINDEX, lptbcd->nmcd.dwItemSpec, 0);
 				::SendMessage(lptbcd->nmcd.hdr.hwndFrom, TB_GETITEMDROPDOWNRECT, static_cast<WPARAM>(idx), reinterpret_cast<LPARAM>(&rcArrow));
 				rcArrow.left += 1;
 				rcArrow.bottom -= 3;
@@ -4521,8 +4555,9 @@ namespace DarkMode
 
 	static void drawListviewItem(LPNMLVCUSTOMDRAW& lplvcd, bool isReport, bool hasGridlines)
 	{
-		HWND& hList = lplvcd->nmcd.hdr.hwndFrom;
-		const auto isSelected = ListView_GetItemState(hList, lplvcd->nmcd.dwItemSpec, LVIS_SELECTED) == LVIS_SELECTED;
+		const auto& hList = lplvcd->nmcd.hdr.hwndFrom;
+		const bool isSelected = ListView_GetItemState(hList, lplvcd->nmcd.dwItemSpec, LVIS_SELECTED) == LVIS_SELECTED;
+		const bool isFocused = ListView_GetItemState(hList, lplvcd->nmcd.dwItemSpec, LVIS_FOCUSED) == LVIS_FOCUSED;
 		const bool isHot = (lplvcd->nmcd.uItemState & CDIS_HOT) == CDIS_HOT;
 
 		if (DarkMode::isEnabled())
@@ -4550,8 +4585,8 @@ namespace DarkMode
 				}
 				else
 				{
-					const auto hHeader = ListView_GetHeader(hList);
-					const auto nCol = Header_GetItemCount(hHeader);
+					HWND hHeader = ListView_GetHeader(hList);
+					const int nCol = Header_GetItemCount(hHeader);
 					const LONG paddingLeft = DarkMode::isThemeDark() ? 1 : 0;
 					const LONG paddingRight = DarkMode::isThemeDark() ? 2 : 1;
 
@@ -4579,7 +4614,7 @@ namespace DarkMode
 			}
 		}
 
-		if (isSelected)
+		if (isFocused)
 		{
 			::DrawFocusRect(lplvcd->nmcd.hdc, &lplvcd->nmcd.rc);
 		}
@@ -4592,7 +4627,7 @@ namespace DarkMode
 	static LRESULT darkListViewNotifyCustomDraw(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
 	{
 		auto* lplvcd = reinterpret_cast<LPNMLVCUSTOMDRAW>(lParam);
-		HWND& hList = lplvcd->nmcd.hdr.hwndFrom;
+		const auto& hList = lplvcd->nmcd.hdr.hwndFrom;
 		const auto lvStyle = ::GetWindowLongPtr(hList, GWL_STYLE) & LVS_TYPEMASK;
 		const bool isReport = (lvStyle == LVS_REPORT);
 		bool hasGridlines = false;
@@ -4672,9 +4707,8 @@ namespace DarkMode
 			{
 				if (DarkMode::isEnabled())
 				{
-					RECT rcFrame = lptvcd->nmcd.rc;
-					rcFrame.left -= 1;
-					rcFrame.right += 1;
+					RECT rcFrame{ lptvcd->nmcd.rc };
+					::InflateRect(&rcFrame, 1, 0);
 
 					if ((lptvcd->nmcd.uItemState & CDIS_HOT) == CDIS_HOT)
 					{
@@ -4913,7 +4947,7 @@ namespace DarkMode
 		rcAnnoyingLine.top--;
 
 
-		auto hdc = ::GetWindowDC(hWnd);
+		HDC hdc = ::GetWindowDC(hWnd);
 		::FillRect(hdc, &rcAnnoyingLine, DarkMode::getDlgBackgroundBrush());
 		::ReleaseDC(hWnd, hdc);
 	}
@@ -5173,7 +5207,7 @@ namespace DarkMode
 		constexpr DWORD win11Mica = 22621;
 		if (DarkMode::getWindowsBuildNumber() >= win10Build2004)
 		{
-			BOOL useDark = DarkMode::isExperimentalActive() ? TRUE : FALSE;
+			const BOOL useDark = DarkMode::isExperimentalActive() ? TRUE : FALSE;
 			::DwmSetWindowAttribute(hWnd, DWMWA_USE_IMMERSIVE_DARK_MODE, &useDark, sizeof(useDark));
 
 			if (win11Features && DarkMode::isWindows11())
@@ -5283,6 +5317,76 @@ namespace DarkMode
 		DarkMode::setDarkThemeExperimental(hWnd, L"Explorer");
 	}
 
+	void setDarkListviewCheckboxes(HWND hWnd)
+	{
+		if (!DarkMode::isWindows11())
+		{
+			return;
+		}
+
+		const auto lvExStyle = ListView_GetExtendedListViewStyle(hWnd);
+		if ((lvExStyle & LVS_EX_CHECKBOXES) != LVS_EX_CHECKBOXES)
+		{
+			return;
+		}
+
+		HDC hdc = ::GetDC(nullptr);
+
+		HTHEME hTheme = ::OpenThemeData(nullptr, DarkMode::isExperimentalActive() ? L"DarkMode_Explorer::Button" : VSCLASS_BUTTON);
+
+		SIZE szBox{};
+		::GetThemePartSize(hTheme, hdc, BP_CHECKBOX, CBS_UNCHECKEDNORMAL, nullptr, TS_DRAW, &szBox);
+
+		RECT rcBox{ 0, 0, szBox.cx, szBox.cy };
+
+		auto hImgList = ListView_GetImageList(hWnd, LVSIL_STATE);
+		if (hImgList == nullptr)
+		{
+			::CloseThemeData(hTheme);
+			::ReleaseDC(nullptr, hdc);
+			return;
+		}
+		::ImageList_RemoveAll(hImgList);
+
+		HDC hBoxDC = ::CreateCompatibleDC(hdc);
+		HBITMAP hBoxBmp = ::CreateCompatibleBitmap(hdc, szBox.cx, szBox.cy);
+		HBITMAP hMaskBmp = ::CreateCompatibleBitmap(hdc, szBox.cx, szBox.cy);
+
+		auto holdBmp = static_cast<HBITMAP>(::SelectObject(hBoxDC, hBoxBmp));
+		::DrawThemeBackground(hTheme, hBoxDC, BP_CHECKBOX, CBS_UNCHECKEDNORMAL, &rcBox, nullptr);
+
+		ICONINFO ii{};
+		ii.fIcon = TRUE;
+		ii.hbmColor = hBoxBmp;
+		ii.hbmMask = hMaskBmp;
+
+		HICON hIcon = ::CreateIconIndirect(&ii);
+		if (hIcon != nullptr)
+		{
+			::ImageList_AddIcon(hImgList, hIcon);
+			::DestroyIcon(hIcon);
+			hIcon = nullptr;
+		}
+
+		::DrawThemeBackground(hTheme, hBoxDC, BP_CHECKBOX, CBS_CHECKEDNORMAL, &rcBox, nullptr);
+		ii.hbmColor = hBoxBmp;
+
+		hIcon = ::CreateIconIndirect(&ii);
+		if (hIcon != nullptr)
+		{
+			::ImageList_AddIcon(hImgList, hIcon);
+			::DestroyIcon(hIcon);
+			hIcon = nullptr;
+		}
+
+		::SelectObject(hBoxDC, holdBmp);
+		::DeleteObject(hMaskBmp);
+		::DeleteObject(hBoxBmp);
+		::DeleteDC(hBoxDC);
+		::CloseThemeData(hTheme);
+		::ReleaseDC(nullptr, hdc);
+	}
+
 	void setDarkThemeExperimental(HWND hWnd, const wchar_t* themeClassName)
 	{
 		if (DarkMode::isExperimentalSupported())
@@ -5523,6 +5627,20 @@ namespace DarkMode
 			DarkMode::redrawWindowFrame(hWnd);
 	}
 
+	void replaceExEdgeWithBorder(HWND hWnd, bool replace, LONG_PTR exStyleFlag)
+	{
+		DarkMode::setWindowExStyle(hWnd, !replace, exStyleFlag);
+		DarkMode::setWindowStyle(hWnd, replace, WS_BORDER);
+	}
+
+	void replaceClientEdgeWithBorderSafe(HWND hWnd)
+	{
+		if (hWnd != nullptr)
+		{
+			DarkMode::replaceExEdgeWithBorder(hWnd, DarkMode::isEnabled(), WS_EX_CLIENTEDGE);
+		}
+	}
+
 	void setProgressBarClassicTheme(HWND hWnd)
 	{
 		DarkMode::setWindowStyle(hWnd, DarkMode::isEnabled(), WS_DLGFRAME);
@@ -5634,6 +5752,19 @@ namespace DarkMode
 		}
 		return DarkMode::onCtlColor(hdc);
 	}
+
+	UINT_PTR CALLBACK HookDlgProc(HWND hWnd, UINT uMsg, WPARAM /*wParam*/, LPARAM /*lParam*/)
+	{
+		switch (uMsg)
+		{
+			case WM_INITDIALOG:
+			{
+				DarkMode::setDarkDlgSafe(hWnd);
+				return TRUE;
+			}
+		}
+		return FALSE;
+	}
 } // namespace DarkMode
 
 #endif // !defined(_DARKMODELIB_NOT_USED)
diff --git a/DarkMode/DarkModeSubclass.h b/DarkMode/DarkModeSubclass.h
index 327aa11e1..f91cbbd77 100644
--- a/DarkMode/DarkModeSubclass.h
+++ b/DarkMode/DarkModeSubclass.h
@@ -292,6 +292,7 @@ namespace DarkMode
 	void setDarkLineAbovePanelToolbar(HWND hWnd);
 	void setDarkHeader(HWND hWnd);
 	void setDarkListView(HWND hWnd);
+	void setDarkListviewCheckboxes(HWND hWnd);
 	void setDarkThemeExperimental(HWND hWnd, const wchar_t* themeClassName = L"Explorer");
 	void setDarkRichEdit(HWND hWnd);
 
@@ -310,6 +311,8 @@ namespace DarkMode
 	inline void redrawWindowFrame(HWND hWnd);
 	void setWindowStyle(HWND hWnd, bool setStyle, LONG_PTR styleFlag);
 	void setWindowExStyle(HWND hWnd, bool setExStyle, LONG_PTR exStyleFlag);
+	void replaceExEdgeWithBorder(HWND hWnd, bool replace, LONG_PTR exStyleFlag);
+	void replaceClientEdgeWithBorderSafe(HWND hWnd);
 	void setProgressBarClassicTheme(HWND hWnd);
 
 	// ctl color
@@ -321,6 +324,85 @@ namespace DarkMode
 	LRESULT onCtlColorDlgStaticText(HDC hdc, bool isTextEnabled);
 	LRESULT onCtlColorDlgLinkText(HDC hdc, bool isTextEnabled = true);
 	LRESULT onCtlColorListbox(WPARAM wParam, LPARAM lParam);
+
+	// hook callback dialog procedure for font, color chooser,... dialogs
+
+	UINT_PTR CALLBACK HookDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
+
+// Below is copy of Windows 7 new choose font dialog template from Font.dlg.
+// Using hook will force ChooseFont function to use older template.
+// Workaround is to use modified template (remove CBS_OWNERDRAWFIXED
+// from size and script comboboxes) copied from Font.dlg. Other comboboxes
+// use custom owner draw, which are needed to show visuals for selected font.
+// Same for "AaBbYyZz" text which has NOT WS_VISIBLE.
+// This workaround will however remove automatic system translation for caption
+// and static texts.
+//
+// Usage example:
+
+//#define IDD_DARK_FONT_DIALOG 1000 // usually in resource.h or other header
+
+//CHOOSEFONT cf{};
+//// some user code
+//cf.Flags |= CF_ENABLEHOOK | CF_ENABLETEMPLATE;
+//cf.lpfnHook = static_cast<LPCFHOOKPROC>(DarkMode::HookDlgProc);
+//cf.hInstance = GetModuleHandle(nullptr);
+//cf.lpTemplateName = MAKEINTRESOURCE(IDD_DARK_FONT_DIALOG);
+
+// in rc file
+
+//IDD_DARK_FONT_DIALOG DIALOG 13, 54, 243, 234
+//STYLE DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU |
+//      DS_3DLOOK
+//CAPTION "Font"
+//FONT 9, "Segoe UI"
+//BEGIN
+//    LTEXT           "&Font:", stc1, 7, 7, 98, 9
+//    COMBOBOX        cmb1, 7, 16, 98, 76,
+//                    CBS_SIMPLE | CBS_AUTOHSCROLL | CBS_DISABLENOSCROLL |
+//                    CBS_SORT | WS_VSCROLL | WS_TABSTOP | CBS_HASSTRINGS |
+//                    CBS_OWNERDRAWFIXED
+//
+//    LTEXT           "Font st&yle:", stc2, 114, 7, 74, 9
+//    COMBOBOX        cmb2, 114, 16, 74, 76,
+//                    CBS_SIMPLE | CBS_AUTOHSCROLL | CBS_DISABLENOSCROLL |
+//                    WS_VSCROLL | WS_TABSTOP | CBS_HASSTRINGS |
+//                    CBS_OWNERDRAWFIXED
+//
+//    LTEXT           "&Size:", stc3, 198, 7, 36, 9
+//    COMBOBOX        cmb3, 198, 16, 36, 76,
+//                    CBS_SIMPLE | CBS_AUTOHSCROLL | CBS_DISABLENOSCROLL |
+//                    CBS_SORT | WS_VSCROLL | WS_TABSTOP | CBS_HASSTRINGS |
+//                    CBS_OWNERDRAWFIXED // remove CBS_OWNERDRAWFIXED
+//
+//    GROUPBOX        "Effects", grp1, 7, 97, 98, 76, WS_GROUP
+//    AUTOCHECKBOX    "Stri&keout", chx1, 13, 111, 90, 10, WS_TABSTOP
+//    AUTOCHECKBOX    "&Underline", chx2, 13, 127, 90, 10
+//
+//    LTEXT           "&Color:", stc4, 13, 144, 89, 9
+//    COMBOBOX        cmb4, 13, 155, 85, 100,
+//                    CBS_DROPDOWNLIST | CBS_OWNERDRAWFIXED | CBS_AUTOHSCROLL |
+//                    CBS_HASSTRINGS | WS_BORDER | WS_VSCROLL | WS_TABSTOP
+//
+//    GROUPBOX        "Sample", grp2, 114, 97, 120, 43, WS_GROUP
+//    CTEXT           "AaBbYyZz", stc5, 116, 106, 117, 33,
+//                    SS_NOPREFIX | NOT WS_VISIBLE
+//    LTEXT           "", stc6, 7, 178, 227, 20, SS_NOPREFIX | NOT WS_GROUP
+//
+//    LTEXT           "Sc&ript:", stc7, 114, 145, 118, 9
+//    COMBOBOX        cmb5, 114, 155, 120, 30, CBS_DROPDOWNLIST |
+//                    CBS_OWNERDRAWFIXED | CBS_AUTOHSCROLL | CBS_HASSTRINGS | // remove CBS_OWNERDRAWFIXED
+//                    WS_BORDER | WS_VSCROLL | WS_TABSTOP
+//    
+//    CONTROL         "<A>Show more fonts</A>", IDC_MANAGE_LINK, "SysLink", 
+//                    WS_TABSTOP, 7, 199, 227, 9 
+//
+//    DEFPUSHBUTTON   "OK", IDOK, 141, 215, 45, 14, WS_GROUP
+//    PUSHBUTTON      "Cancel", IDCANCEL, 190, 215, 45, 14, WS_GROUP
+//    PUSHBUTTON      "&Apply", psh3, 92, 215, 45, 14, WS_GROUP
+//    PUSHBUTTON      "&Help", pshHelp, 43, 215, 45, 14, WS_GROUP
+//
+//END
 } // namespace DarkMode
 
 #else
