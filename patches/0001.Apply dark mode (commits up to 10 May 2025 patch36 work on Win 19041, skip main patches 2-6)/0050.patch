From 3549f30708a0f0a653bc952f9c574ca4f09d3db6 Mon Sep 17 00:00:00 2001
From: ozone10 <positronix10@gmail.com>
Date: Sat, 5 Jul 2025 15:50:34 +0200
Subject: [PATCH] Update darkmodelib files

- make licensing more clear
- add option to colorize title bar on Windows 11
---
 CPP/7zip/7zip.mak                         |    4 +-
 CPP/7zip/UI/FileManager/AboutDialog.rc    |    2 +-
 CPP/7zip/UI/FileManager/App.cpp           |    6 +-
 CPP/7zip/UI/FileManager/MenuPage.cpp      |    2 +-
 CPP/Windows/Control/Dialog.cpp            |    4 +-
 CPP/Windows/Control/PropertyPage.cpp      |    7 +-
 CPP/Windows/Shell.cpp                     |    4 +-
 DarkMode/{ => 7zRes}/7zDark.ini           |    2 +
 DarkMode/{ => 7zRes}/7zFM-fluentIcons.res |  Bin
 DarkMode/{ => 7zRes}/icons/Add.bmp        |  Bin
 DarkMode/{ => 7zRes}/icons/Add2.bmp       |  Bin
 DarkMode/{ => 7zRes}/icons/Copy.bmp       |  Bin
 DarkMode/{ => 7zRes}/icons/Copy2.bmp      |  Bin
 DarkMode/{ => 7zRes}/icons/Delete.bmp     |  Bin
 DarkMode/{ => 7zRes}/icons/Delete2.bmp    |  Bin
 DarkMode/{ => 7zRes}/icons/Extract.bmp    |  Bin
 DarkMode/{ => 7zRes}/icons/Extract2.bmp   |  Bin
 DarkMode/{ => 7zRes}/icons/Info.bmp       |  Bin
 DarkMode/{ => 7zRes}/icons/Info2.bmp      |  Bin
 DarkMode/{ => 7zRes}/icons/Move.bmp       |  Bin
 DarkMode/{ => 7zRes}/icons/Move2.bmp      |  Bin
 DarkMode/{ => 7zRes}/icons/Test.bmp       |  Bin
 DarkMode/{ => 7zRes}/icons/Test2.bmp      |  Bin
 DarkMode/DarkModeSubclass.h               |  424 ---
 LICENSE-MIT.md => DarkMode/LICENSE-MIT.md |    0
 DarkMode/LICENSE.md                       |  357 +++
 DarkMode/Version.h                        |   25 -
 DarkMode/docs/Dark.ini                    |  166 ++
 DarkMode/docs/LICENSE-PolyHook_2_0.md     |   21 +
 DarkMode/docs/LICENSE-UAHMenuBar.md       |   21 +
 DarkMode/docs/LICENSE-win32-darkmode.md   |   21 +
 DarkMode/{ => src}/DarkMode.cpp           |   27 +-
 DarkMode/{ => src}/DarkMode.h             |   21 +-
 DarkMode/{ => src}/DarkModeSubclass.cpp   | 3279 +++++++++++++++++----
 DarkMode/src/DarkModeSubclass.h           |  655 ++++
 DarkMode/{ => src}/IatHook.h              |    0
 DarkMode/{ => src}/StdAfx.h               |    0
 DarkMode/{ => src}/UAHMenuBar.h           |    0
 DarkMode/src/Version.h                    |   16 +
 LICENSE.md                                |  822 ++----
 README.md                                 |   19 +-
 build.cmd                                 |    8 +-
 42 files changed, 4180 insertions(+), 1733 deletions(-)
 rename DarkMode/{ => 7zRes}/7zDark.ini (96%)
 rename DarkMode/{ => 7zRes}/7zFM-fluentIcons.res (100%)
 rename DarkMode/{ => 7zRes}/icons/Add.bmp (100%)
 rename DarkMode/{ => 7zRes}/icons/Add2.bmp (100%)
 rename DarkMode/{ => 7zRes}/icons/Copy.bmp (100%)
 rename DarkMode/{ => 7zRes}/icons/Copy2.bmp (100%)
 rename DarkMode/{ => 7zRes}/icons/Delete.bmp (100%)
 rename DarkMode/{ => 7zRes}/icons/Delete2.bmp (100%)
 rename DarkMode/{ => 7zRes}/icons/Extract.bmp (100%)
 rename DarkMode/{ => 7zRes}/icons/Extract2.bmp (100%)
 rename DarkMode/{ => 7zRes}/icons/Info.bmp (100%)
 rename DarkMode/{ => 7zRes}/icons/Info2.bmp (100%)
 rename DarkMode/{ => 7zRes}/icons/Move.bmp (100%)
 rename DarkMode/{ => 7zRes}/icons/Move2.bmp (100%)
 rename DarkMode/{ => 7zRes}/icons/Test.bmp (100%)
 rename DarkMode/{ => 7zRes}/icons/Test2.bmp (100%)
 delete mode 100644 DarkMode/DarkModeSubclass.h
 rename LICENSE-MIT.md => DarkMode/LICENSE-MIT.md (100%)
 create mode 100644 DarkMode/LICENSE.md
 delete mode 100644 DarkMode/Version.h
 create mode 100644 DarkMode/docs/Dark.ini
 create mode 100644 DarkMode/docs/LICENSE-PolyHook_2_0.md
 create mode 100644 DarkMode/docs/LICENSE-UAHMenuBar.md
 create mode 100644 DarkMode/docs/LICENSE-win32-darkmode.md
 rename DarkMode/{ => src}/DarkMode.cpp (96%)
 rename DarkMode/{ => src}/DarkMode.h (64%)
 rename DarkMode/{ => src}/DarkModeSubclass.cpp (58%)
 create mode 100644 DarkMode/src/DarkModeSubclass.h
 rename DarkMode/{ => src}/IatHook.h (100%)
 rename DarkMode/{ => src}/StdAfx.h (100%)
 rename DarkMode/{ => src}/UAHMenuBar.h (100%)
 create mode 100644 DarkMode/src/Version.h

diff --git a/CPP/7zip/7zip.mak b/CPP/7zip/7zip.mak
index b3c52d26f..5ccc444a2 100644
--- a/CPP/7zip/7zip.mak
+++ b/CPP/7zip/7zip.mak
@@ -169,7 +169,7 @@ $(GUI_OBJS): ../../UI/GUI/$(*B).cpp
 !ENDIF
 
 !IFDEF DARK_MODE_OBJS
-$(DARK_MODE_OBJS): ../../../../DarkMode/$(*B).cpp
+$(DARK_MODE_OBJS): ../../../../DarkMode/src/$(*B).cpp
 	$(COMPL)
 !ENDIF
 
@@ -241,7 +241,7 @@ $(C_OBJS): ../../../../C/$(*B).c
 {../../../../C}.c{$O}.obj::
 	$(CCOMPLB)
 
-{../../../../DarkMode}.cpp{$O}.obj::
+{../../../../DarkMode/src}.cpp{$O}.obj::
 	$(COMPLB)
 
 !ENDIF
diff --git a/CPP/7zip/UI/FileManager/AboutDialog.rc b/CPP/7zip/UI/FileManager/AboutDialog.rc
index ca2ccd904..0d8160d2a 100644
--- a/CPP/7zip/UI/FileManager/AboutDialog.rc
+++ b/CPP/7zip/UI/FileManager/AboutDialog.rc
@@ -1,7 +1,7 @@
 #include "AboutDialogRes.h"
 #include "../../GuiCommon.rc"
 #include "../../MyVersion.h"
-#include "../../../../DarkMode/Version.h"
+#include "../../../../DarkMode/src/Version.h"
 
 #define xc 144
 #define yc 144
diff --git a/CPP/7zip/UI/FileManager/App.cpp b/CPP/7zip/UI/FileManager/App.cpp
index f8d3f33ac..8ac07c3bb 100644
--- a/CPP/7zip/UI/FileManager/App.cpp
+++ b/CPP/7zip/UI/FileManager/App.cpp
@@ -29,7 +29,7 @@
 
 #include "PropertyNameRes.h"
 
-#include "../../../../DarkMode/DarkModeSubclass.h"
+#include "../../../../DarkMode/src/DarkModeSubclass.h"
 
 using namespace NWindows;
 using namespace NFile;
@@ -356,7 +356,7 @@ HRESULT CApp::Create(HWND hwnd, const UString &mainPath, const UString &arcForma
   }
 
   DarkMode::setWindowEraseBgSubclass(hwnd);
-  DarkMode::setDarkDlgNotifySafe(hwnd, true);
+  DarkMode::setDarkWndNotifySafeEx(hwnd, true, true);
   DarkMode::setWindowMenuBarSubclass(hwnd);
 
   for (i = 0; i < kNumPanelsMax; i++)
@@ -365,7 +365,7 @@ HRESULT CApp::Create(HWND hwnd, const UString &mainPath, const UString &arcForma
     DarkMode::setWindowCtlColorSubclass(Panels[i]);
     DarkMode::setWindowEraseBgSubclass(Panels[i]._headerReBar);
     DarkMode::setWindowCtlColorSubclass(Panels[i]._headerReBar);
-    DarkMode::setWindowNotifyCustomDrawSubclass(Panels[i], false);
+    DarkMode::setWindowNotifyCustomDrawSubclass(Panels[i]);
   }
 
   SetFocusedPanel(LastFocusedPanel);
diff --git a/CPP/7zip/UI/FileManager/MenuPage.cpp b/CPP/7zip/UI/FileManager/MenuPage.cpp
index 6368dc5e1..981e2f5e5 100644
--- a/CPP/7zip/UI/FileManager/MenuPage.cpp
+++ b/CPP/7zip/UI/FileManager/MenuPage.cpp
@@ -22,7 +22,7 @@
 #include "MenuPage.h"
 #include "MenuPageRes.h"
 
-#include "../../../../DarkMode/DarkModeSubclass.h"
+#include "../../../../DarkMode/src/DarkModeSubclass.h"
 
 
 using namespace NWindows;
diff --git a/CPP/Windows/Control/Dialog.cpp b/CPP/Windows/Control/Dialog.cpp
index 9a9a2c888..75ebe2eee 100644
--- a/CPP/Windows/Control/Dialog.cpp
+++ b/CPP/Windows/Control/Dialog.cpp
@@ -10,7 +10,7 @@
 
 #include "Dialog.h"
 
-#include "../../../DarkMode/DarkModeSubclass.h"
+#include "../../../DarkMode/src/DarkModeSubclass.h"
 
 extern HINSTANCE g_hInstance;
 #ifndef _UNICODE
@@ -39,7 +39,7 @@ DialogProcedure(HWND dialogHWND, UINT message, WPARAM wParam, LPARAM lParam)
     {
       dialog->Attach(dialogHWND);
       DarkMode::initDarkMode(L"7zDark");
-      DarkMode::setDarkDlgNotifySafe(*dialog, true);
+      DarkMode::setDarkWndNotifySafeEx(*dialog, true, true);
     }
 
   /* MSDN: The dialog box procedure should return
diff --git a/CPP/Windows/Control/PropertyPage.cpp b/CPP/Windows/Control/PropertyPage.cpp
index a1ddc8ad2..7321c284d 100644
--- a/CPP/Windows/Control/PropertyPage.cpp
+++ b/CPP/Windows/Control/PropertyPage.cpp
@@ -8,7 +8,7 @@
 
 #include "PropertyPage.h"
 
-#include "../../../DarkMode/DarkModeSubclass.h"
+#include "../../../DarkMode/src/DarkModeSubclass.h"
 
 extern HINSTANCE g_hInstance;
 #ifndef _UNICODE
@@ -35,9 +35,10 @@ APIENTRY MyProperyPageProcedure(HWND dialogHWND, UINT message, WPARAM wParam, LP
   if (message == WM_INITDIALOG)
     {
       dialog->Attach(dialogHWND);
-      DarkMode::setDarkDlgNotifySafe(::GetParent(*dialog), true);
+      DarkMode::setDarkWndNotifySafeEx(::GetParent(*dialog), true, true);
       DarkMode::setWindowCtlColorSubclass(*dialog);
-      DarkMode::setWindowNotifyCustomDrawSubclass(*dialog, true);
+      DarkMode::setWindowNotifyCustomDrawSubclass(*dialog);
+      DarkMode::setChildCtrlsSubclassAndTheme(*dialog);
     }
   try { return BoolToBOOL(dialog->OnMessage(message, wParam, lParam)); }
   catch(...) { return TRUE; }
diff --git a/CPP/Windows/Shell.cpp b/CPP/Windows/Shell.cpp
index 4278a643c..1caafc2e0 100644
--- a/CPP/Windows/Shell.cpp
+++ b/CPP/Windows/Shell.cpp
@@ -10,7 +10,7 @@
 #include "MemoryGlobal.h"
 #include "Shell.h"
 
-#include "../../DarkMode/DarkModeSubclass.h"
+#include "../../DarkMode/src/DarkModeSubclass.h"
 
 #ifndef _UNICODE
 extern bool g_IsNT;
@@ -685,7 +685,7 @@ static int CALLBACK BrowseCallbackProc(HWND hwnd, UINT uMsg, LPARAM /* lp */, LP
   {
     case BFFM_INITIALIZED:
     {
-      DarkMode::setDarkDlgSafe(hwnd, false);
+      DarkMode::setDarkWndSafe(hwnd, false);
       SendMessage(hwnd, BFFM_SETSELECTION, TRUE, data);
       break;
     }
diff --git a/DarkMode/7zDark.ini b/DarkMode/7zRes/7zDark.ini
similarity index 96%
rename from DarkMode/7zDark.ini
rename to DarkMode/7zRes/7zDark.ini
index 5e4b98c0d..d9f3b1548 100644
--- a/DarkMode/7zDark.ini
+++ b/DarkMode/7zRes/7zDark.ini
@@ -6,6 +6,7 @@ tone = 0
 roundCorner = 0
 borderColor = "FFFFFF"
 mica = 0
+colorizeTitleBar = 0
 
 [dark.colors]
 background =            "202020"
@@ -32,6 +33,7 @@ edgeHeader =            "646464"
 roundCorner = 0
 borderColor = "FFFFFF"
 mica = 0
+colorizeTitleBar = 0
 
 [light.colors]
 background =            "F0F0F0"
diff --git a/DarkMode/7zFM-fluentIcons.res b/DarkMode/7zRes/7zFM-fluentIcons.res
similarity index 100%
rename from DarkMode/7zFM-fluentIcons.res
rename to DarkMode/7zRes/7zFM-fluentIcons.res
diff --git a/DarkMode/icons/Add.bmp b/DarkMode/7zRes/icons/Add.bmp
similarity index 100%
rename from DarkMode/icons/Add.bmp
rename to DarkMode/7zRes/icons/Add.bmp
diff --git a/DarkMode/icons/Add2.bmp b/DarkMode/7zRes/icons/Add2.bmp
similarity index 100%
rename from DarkMode/icons/Add2.bmp
rename to DarkMode/7zRes/icons/Add2.bmp
diff --git a/DarkMode/icons/Copy.bmp b/DarkMode/7zRes/icons/Copy.bmp
similarity index 100%
rename from DarkMode/icons/Copy.bmp
rename to DarkMode/7zRes/icons/Copy.bmp
diff --git a/DarkMode/icons/Copy2.bmp b/DarkMode/7zRes/icons/Copy2.bmp
similarity index 100%
rename from DarkMode/icons/Copy2.bmp
rename to DarkMode/7zRes/icons/Copy2.bmp
diff --git a/DarkMode/icons/Delete.bmp b/DarkMode/7zRes/icons/Delete.bmp
similarity index 100%
rename from DarkMode/icons/Delete.bmp
rename to DarkMode/7zRes/icons/Delete.bmp
diff --git a/DarkMode/icons/Delete2.bmp b/DarkMode/7zRes/icons/Delete2.bmp
similarity index 100%
rename from DarkMode/icons/Delete2.bmp
rename to DarkMode/7zRes/icons/Delete2.bmp
diff --git a/DarkMode/icons/Extract.bmp b/DarkMode/7zRes/icons/Extract.bmp
similarity index 100%
rename from DarkMode/icons/Extract.bmp
rename to DarkMode/7zRes/icons/Extract.bmp
diff --git a/DarkMode/icons/Extract2.bmp b/DarkMode/7zRes/icons/Extract2.bmp
similarity index 100%
rename from DarkMode/icons/Extract2.bmp
rename to DarkMode/7zRes/icons/Extract2.bmp
diff --git a/DarkMode/icons/Info.bmp b/DarkMode/7zRes/icons/Info.bmp
similarity index 100%
rename from DarkMode/icons/Info.bmp
rename to DarkMode/7zRes/icons/Info.bmp
diff --git a/DarkMode/icons/Info2.bmp b/DarkMode/7zRes/icons/Info2.bmp
similarity index 100%
rename from DarkMode/icons/Info2.bmp
rename to DarkMode/7zRes/icons/Info2.bmp
diff --git a/DarkMode/icons/Move.bmp b/DarkMode/7zRes/icons/Move.bmp
similarity index 100%
rename from DarkMode/icons/Move.bmp
rename to DarkMode/7zRes/icons/Move.bmp
diff --git a/DarkMode/icons/Move2.bmp b/DarkMode/7zRes/icons/Move2.bmp
similarity index 100%
rename from DarkMode/icons/Move2.bmp
rename to DarkMode/7zRes/icons/Move2.bmp
diff --git a/DarkMode/icons/Test.bmp b/DarkMode/7zRes/icons/Test.bmp
similarity index 100%
rename from DarkMode/icons/Test.bmp
rename to DarkMode/7zRes/icons/Test.bmp
diff --git a/DarkMode/icons/Test2.bmp b/DarkMode/7zRes/icons/Test2.bmp
similarity index 100%
rename from DarkMode/icons/Test2.bmp
rename to DarkMode/7zRes/icons/Test2.bmp
diff --git a/DarkMode/DarkModeSubclass.h b/DarkMode/DarkModeSubclass.h
deleted file mode 100644
index 7eab1a616..000000000
--- a/DarkMode/DarkModeSubclass.h
+++ /dev/null
@@ -1,424 +0,0 @@
-// SPDX-License-Identifier: GPL-3.0-or-later
-
-/*
- * Copyright (c) 2024-2025 ozone10
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-// Based on Notepad++ dark mode code, original by adzm / Adam D. Walling
-// with modification from Notepad++ team.
-// Heavily modified by ozone10 (contributor of Notepad++)
-
-
-#pragma once
-
-#include <windows.h>
-
-#if (NTDDI_VERSION >= NTDDI_VISTA) /*\
-	&& (defined(__x86_64__) || defined(_M_X64)\
-	|| defined(__arm64__) || defined(__arm64) || defined(_M_ARM64))*/
-
-#if defined(_MSC_VER)
-#pragma comment(lib, "dwmapi.lib")
-#pragma comment(lib, "uxtheme.lib")
-#pragma comment(lib, "Comctl32.lib")
-#pragma comment(lib, "Gdi32.lib")
-#endif
-
-namespace DarkMode
-{
-	struct Colors
-	{
-		COLORREF background = 0;
-		COLORREF ctrlBackground = 0;
-		COLORREF hotBackground = 0;
-		COLORREF dlgBackground = 0;
-		COLORREF errorBackground = 0;
-		COLORREF text = 0;
-		COLORREF darkerText = 0;
-		COLORREF disabledText = 0;
-		COLORREF linkText = 0;
-		COLORREF edge = 0;
-		COLORREF hotEdge = 0;
-		COLORREF disabledEdge = 0;
-	};
-
-	struct ColorsView
-	{
-		COLORREF background = 0;
-		COLORREF text = 0;
-		COLORREF gridlines = 0;
-		COLORREF headerBackground = 0;
-		COLORREF headerHotBackground = 0;
-		COLORREF headerText = 0;
-		COLORREF headerEdge = 0;
-	};
-
-	enum class ToolTipsType : unsigned char // std::uint8_t
-	{
-		tooltip,
-		toolbar,
-		listview,
-		treeview,
-		tabbar
-	};
-
-	enum class ColorTone : unsigned char // std::uint8_t
-	{
-		black   = 0,
-		red     = 1,
-		green   = 2,
-		blue    = 3,
-		purple  = 4,
-		cyan    = 5,
-		olive   = 6,
-		max     = 7 // don't use, for internal checks
-	};
-
-	enum class TreeViewStyle : unsigned char // std::uint8_t
-	{
-		classic,
-		light,
-		dark
-	};
-
-	enum class LibInfo : unsigned char // std::uint8_t
-	{
-		featureCheck,
-		verMajor,
-		verMinor,
-		verRevision,
-		iathookExternal,
-		iniConfigUsed,
-		allowOldOS,
-		useDlgProcCtl,
-		maxValue // don't use, for internal checks
-	};
-
-	[[nodiscard]] int getLibInfo(LibInfo libInfoType);
-
-	// enum DarkModeType { light = 0, dark = 1, classic = 3 }; values
-	void initDarkModeConfig(UINT dmType);
-	// DWM_WINDOW_CORNER_PREFERENCE values
-	void setRoundCornerConfig(UINT roundCornerStyle);
-	void setBorderColorConfig(COLORREF clr);
-	// DWM_SYSTEMBACKDROP_TYPE values
-	void setMicaConfig(UINT mica);
-	void setMicaExtendedConfig(bool extendMica);
-	// enum DarkModeType { light = 0, dark = 1, classic = 3 }; values
-	void setDarkModeConfig(UINT dmType);
-	void setDarkModeConfig();
-
-	void initDarkMode(const wchar_t* iniName);
-	void initDarkMode();
-
-	[[nodiscard]] bool isEnabled();
-	[[nodiscard]] bool isExperimentalActive();
-	[[nodiscard]] bool isExperimentalSupported();
-
-	[[nodiscard]] bool isWindowsModeEnabled();
-
-	[[nodiscard]] bool isWindows10();
-	[[nodiscard]] bool isWindows11();
-	[[nodiscard]] DWORD getWindowsBuildNumber();
-
-	// handle events
-
-	bool handleSettingChange(LPARAM lParam);
-	[[nodiscard]] bool isDarkModeReg();
-
-	// from DarkMode.h
-
-	void setSysColor(int nIndex, COLORREF color);
-	bool hookSysColor();
-	void unhookSysColor();
-
-	// enhancements to DarkMode.h
-
-	void enableDarkScrollBarForWindowAndChildren(HWND hWnd);
-
-	// colors
-
-	void setToneColors(ColorTone colorTone);
-	[[nodiscard]] ColorTone getColorTone();
-
-	COLORREF setBackgroundColor(COLORREF clrNew);
-	COLORREF setCtrlBackgroundColor(COLORREF clrNew);
-	COLORREF setHotBackgroundColor(COLORREF clrNew);
-	COLORREF setDlgBackgroundColor(COLORREF clrNew);
-	COLORREF setErrorBackgroundColor(COLORREF clrNew);
-
-	COLORREF setTextColor(COLORREF clrNew);
-	COLORREF setDarkerTextColor(COLORREF clrNew);
-	COLORREF setDisabledTextColor(COLORREF clrNew);
-	COLORREF setLinkTextColor(COLORREF clrNew);
-
-	COLORREF setEdgeColor(COLORREF clrNew);
-	COLORREF setHotEdgeColor(COLORREF clrNew);
-	COLORREF setDisabledEdgeColor(COLORREF clrNew);
-
-	void setThemeColors(Colors colors);
-	void updateThemeBrushesAndPens();
-
-	[[nodiscard]] COLORREF getBackgroundColor();
-	[[nodiscard]] COLORREF getCtrlBackgroundColor();
-	[[nodiscard]] COLORREF getHotBackgroundColor();
-	[[nodiscard]] COLORREF getDlgBackgroundColor();
-	[[nodiscard]] COLORREF getErrorBackgroundColor();
-
-	[[nodiscard]] COLORREF getTextColor();
-	[[nodiscard]] COLORREF getDarkerTextColor();
-	[[nodiscard]] COLORREF getDisabledTextColor();
-	[[nodiscard]] COLORREF getLinkTextColor();
-
-	[[nodiscard]] COLORREF getEdgeColor();
-	[[nodiscard]] COLORREF getHotEdgeColor();
-	[[nodiscard]] COLORREF getDisabledEdgeColor();
-
-	[[nodiscard]] HBRUSH getBackgroundBrush();
-	[[nodiscard]] HBRUSH getDlgBackgroundBrush();
-	[[nodiscard]] HBRUSH getCtrlBackgroundBrush();
-	[[nodiscard]] HBRUSH getHotBackgroundBrush();
-	[[nodiscard]] HBRUSH getErrorBackgroundBrush();
-
-	[[nodiscard]] HBRUSH getEdgeBrush();
-	[[nodiscard]] HBRUSH getHotEdgeBrush();
-	[[nodiscard]] HBRUSH getDisabledEdgeBrush();
-
-	[[nodiscard]] HPEN getDarkerTextPen();
-	[[nodiscard]] HPEN getEdgePen();
-	[[nodiscard]] HPEN getHotEdgePen();
-	[[nodiscard]] HPEN getDisabledEdgePen();
-
-	COLORREF setViewBackgroundColor(COLORREF clrNew);
-	COLORREF setViewTextColor(COLORREF clrNew);
-	COLORREF setViewGridlinesColor(COLORREF clrNew);
-
-	COLORREF setHeaderBackgroundColor(COLORREF clrNew);
-	COLORREF setHeaderHotBackgroundColor(COLORREF clrNew);
-	COLORREF setHeaderTextColor(COLORREF clrNew);
-	COLORREF setHeaderEdgeColor(COLORREF clrNew);
-
-	void setViewColors(ColorsView colors);
-	void updateViewBrushesAndPens();
-
-	[[nodiscard]] COLORREF getViewBackgroundColor();
-	[[nodiscard]] COLORREF getViewTextColor();
-	[[nodiscard]] COLORREF getViewGridlinesColor();
-
-	[[nodiscard]] COLORREF getHeaderBackgroundColor();
-	[[nodiscard]] COLORREF getHeaderHotBackgroundColor();
-	[[nodiscard]] COLORREF getHeaderTextColor();
-	[[nodiscard]] COLORREF getHeaderEdgeColor();
-
-	[[nodiscard]] HBRUSH getViewBackgroundBrush();
-	[[nodiscard]] HBRUSH getViewGridlinesBrush();
-
-	[[nodiscard]] HBRUSH getHeaderBackgroundBrush();
-	[[nodiscard]] HBRUSH getHeaderHotBackgroundBrush();
-
-	[[nodiscard]] HPEN getHeaderEdgePen();
-
-	// paint helper
-
-	void paintRoundRect(HDC hdc, const RECT& rect, HPEN hpen, HBRUSH hBrush, int width = 0, int height = 0);
-	void paintRoundFrameRect(HDC hdc, const RECT& rect, HPEN hpen, int width = 0, int height = 0);
-
-	// control subclassing
-
-	void setCheckboxOrRadioBtnCtrlSubclass(HWND hWnd);
-	void removeCheckboxOrRadioBtnCtrlSubclass(HWND hWnd);
-
-	void setGroupboxCtrlSubclass(HWND hWnd);
-	void removeGroupboxCtrlSubclass(HWND hWnd);
-
-	void setUpDownCtrlSubclass(HWND hWnd);
-	void removeUpDownCtrlSubclass(HWND hWnd);
-
-	void setTabCtrlUpDownSubclass(HWND hWnd);
-	void removeTabCtrlUpDownSubclass(HWND hWnd);
-	void setTabCtrlSubclass(HWND hWnd);
-	void removeTabCtrlSubclass(HWND hWnd);
-
-	void setComboBoxCtrlSubclass(HWND hWnd);
-	void removeComboBoxCtrlSubclass(HWND hWnd);
-
-	void setComboBoxExCtrlSubclass(HWND hWnd);
-	void removeComboBoxExCtrlSubclass(HWND hWnd);
-
-	void setListViewCtrlSubclass(HWND hWnd);
-	void removeListViewCtrlSubclass(HWND hWnd);
-
-	void setHeaderCtrlSubclass(HWND hWnd);
-	void removeHeaderCtrlSubclass(HWND hWnd);
-
-	void setStatusBarCtrlSubclass(HWND hWnd);
-	void removeStatusBarCtrlSubclass(HWND hWnd);
-
-	void setProgressBarCtrlSubclass(HWND hWnd);
-	void removeProgressBarCtrlSubclass(HWND hWnd);
-
-	void setStaticTextCtrlSubclass(HWND hWnd);
-	void removeStaticTextCtrlSubclass(HWND hWnd);
-
-	// child subclassing
-
-	void setChildCtrlsSubclassAndTheme(HWND hParent, bool subclass = true, bool theme = true);
-	void setChildCtrlsTheme(HWND hParent);
-
-	// window, parent, and other subclassing
-
-	void setWindowEraseBgSubclass(HWND hWnd);
-	void removeWindowEraseBgSubclass(HWND hWnd);
-
-	void setWindowCtlColorSubclass(HWND hWnd);
-	void removeWindowCtlColorSubclass(HWND hWnd);
-
-	void setWindowNotifyCustomDrawSubclass(HWND hWnd, bool subclassChildren = false);
-	void removeWindowNotifyCustomDrawSubclass(HWND hWnd);
-
-	void setWindowMenuBarSubclass(HWND hWnd);
-	void removeWindowMenuBarSubclass(HWND hWnd);
-
-	void setWindowSettingChangeSubclass(HWND hWnd);
-	void removeWindowSettingChangeSubclass(HWND hWnd);
-
-	// theme and helper
-
-	void enableSysLinkCtrlCtlColor(HWND hWnd);
-
-	void setDarkTitleBarEx(HWND hWnd, bool useWin11Features);
-	void setDarkTitleBar(HWND hWnd);
-	void setDarkExplorerTheme(HWND hWnd);
-	void setDarkScrollBar(HWND hWnd);
-	void setDarkTooltips(HWND hWnd, ToolTipsType type = ToolTipsType::tooltip);
-	void setDarkLineAbovePanelToolbar(HWND hWnd);
-	void setDarkHeader(HWND hWnd);
-	void setDarkListView(HWND hWnd);
-	void setDarkListViewCheckboxes(HWND hWnd);
-	void setDarkThemeExperimental(HWND hWnd, const wchar_t* themeClassName = L"Explorer");
-	void setDarkRichEdit(HWND hWnd);
-
-	void setDarkDlgSafe(HWND hWnd, bool useWin11Features = true);
-	void setDarkDlgNotifySafe(HWND hWnd, bool useWin11Features = true);
-
-	// only if g_dmType == DarkModeType::classic
-	inline void enableThemeDialogTexture(HWND hWnd, bool theme);
-	void disableVisualStyle(HWND hWnd, bool doDisable);
-	[[nodiscard]] double calculatePerceivedLightness(COLORREF clr);
-	void calculateTreeViewStyle();
-	void updatePrevTreeViewStyle();
-	[[nodiscard]] TreeViewStyle getTreeViewStyle();
-	void setTreeViewStyle(HWND hWnd, bool force = false);
-	[[nodiscard]] bool isThemeDark();
-	inline void redrawWindowFrame(HWND hWnd);
-	void setWindowStyle(HWND hWnd, bool setStyle, LONG_PTR styleFlag);
-	void setWindowExStyle(HWND hWnd, bool setExStyle, LONG_PTR exStyleFlag);
-	void replaceExEdgeWithBorder(HWND hWnd, bool replace, LONG_PTR exStyleFlag);
-	void replaceClientEdgeWithBorderSafe(HWND hWnd);
-	void setProgressBarClassicTheme(HWND hWnd);
-
-	// ctl color
-
-	[[nodiscard]] LRESULT onCtlColor(HDC hdc);
-	[[nodiscard]] LRESULT onCtlColorCtrl(HDC hdc);
-	[[nodiscard]] LRESULT onCtlColorDlg(HDC hdc);
-	[[nodiscard]] LRESULT onCtlColorError(HDC hdc);
-	[[nodiscard]] LRESULT onCtlColorDlgStaticText(HDC hdc, bool isTextEnabled);
-	[[nodiscard]] LRESULT onCtlColorDlgLinkText(HDC hdc, bool isTextEnabled = true);
-	[[nodiscard]] LRESULT onCtlColorListbox(WPARAM wParam, LPARAM lParam);
-
-	// hook callback dialog procedure for font, color chooser,... dialogs
-
-	UINT_PTR CALLBACK HookDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
-
-	// Below is copy of Windows 7 new choose font dialog template from Font.dlg.
-	// Using hook will force ChooseFont function to use older template.
-	// Workaround is to use modified template (remove CBS_OWNERDRAWFIXED
-	// from size and script comboboxes) copied from Font.dlg. Other comboboxes
-	// use custom owner draw, which are needed to show visuals for selected font.
-	// Same for "AaBbYyZz" text which has NOT WS_VISIBLE.
-	// This workaround will however remove automatic system translation for caption
-	// and static texts.
-	//
-	// Usage example:
-
-	//#define IDD_DARK_FONT_DIALOG 1000 // usually in resource.h or other header
-
-	//CHOOSEFONT cf{};
-	//// some user code
-	//cf.Flags |= CF_ENABLEHOOK | CF_ENABLETEMPLATE;
-	//cf.lpfnHook = static_cast<LPCFHOOKPROC>(DarkMode::HookDlgProc);
-	//cf.hInstance = GetModuleHandle(nullptr);
-	//cf.lpTemplateName = MAKEINTRESOURCE(IDD_DARK_FONT_DIALOG);
-
-	// in rc file
-
-	//IDD_DARK_FONT_DIALOG DIALOG 13, 54, 243, 234
-	//STYLE DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU |
-	//      DS_3DLOOK
-	//CAPTION "Font"
-	//FONT 9, "Segoe UI"
-	//BEGIN
-	//    LTEXT           "&Font:", stc1, 7, 7, 98, 9
-	//    COMBOBOX        cmb1, 7, 16, 98, 76,
-	//                    CBS_SIMPLE | CBS_AUTOHSCROLL | CBS_DISABLENOSCROLL |
-	//                    CBS_SORT | WS_VSCROLL | WS_TABSTOP | CBS_HASSTRINGS |
-	//                    CBS_OWNERDRAWFIXED
-	//
-	//    LTEXT           "Font st&yle:", stc2, 114, 7, 74, 9
-	//    COMBOBOX        cmb2, 114, 16, 74, 76,
-	//                    CBS_SIMPLE | CBS_AUTOHSCROLL | CBS_DISABLENOSCROLL |
-	//                    WS_VSCROLL | WS_TABSTOP | CBS_HASSTRINGS |
-	//                    CBS_OWNERDRAWFIXED
-	//
-	//    LTEXT           "&Size:", stc3, 198, 7, 36, 9
-	//    COMBOBOX        cmb3, 198, 16, 36, 76,
-	//                    CBS_SIMPLE | CBS_AUTOHSCROLL | CBS_DISABLENOSCROLL |
-	//                    CBS_SORT | WS_VSCROLL | WS_TABSTOP | CBS_HASSTRINGS |
-	//                    CBS_OWNERDRAWFIXED // remove CBS_OWNERDRAWFIXED
-	//
-	//    GROUPBOX        "Effects", grp1, 7, 97, 98, 76, WS_GROUP
-	//    AUTOCHECKBOX    "Stri&keout", chx1, 13, 111, 90, 10, WS_TABSTOP
-	//    AUTOCHECKBOX    "&Underline", chx2, 13, 127, 90, 10
-	//
-	//    LTEXT           "&Color:", stc4, 13, 144, 89, 9
-	//    COMBOBOX        cmb4, 13, 155, 85, 100,
-	//                    CBS_DROPDOWNLIST | CBS_OWNERDRAWFIXED | CBS_AUTOHSCROLL |
-	//                    CBS_HASSTRINGS | WS_BORDER | WS_VSCROLL | WS_TABSTOP
-	//
-	//    GROUPBOX        "Sample", grp2, 114, 97, 120, 43, WS_GROUP
-	//    CTEXT           "AaBbYyZz", stc5, 116, 106, 117, 33,
-	//                    SS_NOPREFIX | NOT WS_VISIBLE
-	//    LTEXT           "", stc6, 7, 178, 227, 20, SS_NOPREFIX | NOT WS_GROUP
-	//
-	//    LTEXT           "Sc&ript:", stc7, 114, 145, 118, 9
-	//    COMBOBOX        cmb5, 114, 155, 120, 30, CBS_DROPDOWNLIST |
-	//                    CBS_OWNERDRAWFIXED | CBS_AUTOHSCROLL | CBS_HASSTRINGS | // remove CBS_OWNERDRAWFIXED
-	//                    WS_BORDER | WS_VSCROLL | WS_TABSTOP
-	//
-	//    CONTROL         "<A>Show more fonts</A>", IDC_MANAGE_LINK, "SysLink",
-	//                    WS_TABSTOP, 7, 199, 227, 9
-	//
-	//    DEFPUSHBUTTON   "OK", IDOK, 141, 215, 45, 14, WS_GROUP
-	//    PUSHBUTTON      "Cancel", IDCANCEL, 190, 215, 45, 14, WS_GROUP
-	//    PUSHBUTTON      "&Apply", psh3, 92, 215, 45, 14, WS_GROUP
-	//    PUSHBUTTON      "&Help", pshHelp, 43, 215, 45, 14, WS_GROUP
-	//
-	//END
-} // namespace DarkMode
-
-#else
-#define _DARKMODELIB_NOT_USED
-#endif // (NTDDI_VERSION >= NTDDI_VISTA) //&& (x64 or arm64)
diff --git a/LICENSE-MIT.md b/DarkMode/LICENSE-MIT.md
similarity index 100%
rename from LICENSE-MIT.md
rename to DarkMode/LICENSE-MIT.md
diff --git a/DarkMode/LICENSE.md b/DarkMode/LICENSE.md
new file mode 100644
index 000000000..ab810efd9
--- /dev/null
+++ b/DarkMode/LICENSE.md
@@ -0,0 +1,357 @@
+Mozilla Public License Version 2.0
+==================================
+
+### 1. Definitions
+
+**1.1. “Contributor”**  
+    means each individual or legal entity that creates, contributes to
+    the creation of, or owns Covered Software.
+
+**1.2. “Contributor Version”**  
+    means the combination of the Contributions of others (if any) used
+    by a Contributor and that particular Contributor's Contribution.
+
+**1.3. “Contribution”**  
+    means Covered Software of a particular Contributor.
+
+**1.4. “Covered Software”**  
+    means Source Code Form to which the initial Contributor has attached
+    the notice in Exhibit A, the Executable Form of such Source Code
+    Form, and Modifications of such Source Code Form, in each case
+    including portions thereof.
+
+**1.5. “Incompatible With Secondary Licenses”**  
+    means
+
+* **(a)** that the initial Contributor has attached the notice described
+    in Exhibit B to the Covered Software; or
+* **(b)** that the Covered Software was made available under the terms of
+    version 1.1 or earlier of the License, but not also under the
+    terms of a Secondary License.
+
+**1.6. “Executable Form”**  
+    means any form of the work other than Source Code Form.
+
+**1.7. “Larger Work”**  
+    means a work that combines Covered Software with other material, in 
+    a separate file or files, that is not Covered Software.
+
+**1.8. “License”**  
+    means this document.
+
+**1.9. “Licensable”**  
+    means having the right to grant, to the maximum extent possible,
+    whether at the time of the initial grant or subsequently, any and
+    all of the rights conveyed by this License.
+
+**1.10. “Modifications”**  
+    means any of the following:
+
+* **(a)** any file in Source Code Form that results from an addition to,
+    deletion from, or modification of the contents of Covered
+    Software; or
+* **(b)** any new file in Source Code Form that contains any Covered
+    Software.
+
+**1.11. “Patent Claims” of a Contributor**  
+    means any patent claim(s), including without limitation, method,
+    process, and apparatus claims, in any patent Licensable by such
+    Contributor that would be infringed, but for the grant of the
+    License, by the making, using, selling, offering for sale, having
+    made, import, or transfer of either its Contributions or its
+    Contributor Version.
+
+**1.12. “Secondary License”**  
+    means either the GNU General Public License, Version 2.0, the GNU
+    Lesser General Public License, Version 2.1, the GNU Affero General
+    Public License, Version 3.0, or any later versions of those
+    licenses.
+
+**1.13. “Source Code Form”**  
+    means the form of the work preferred for making modifications.
+
+**1.14. “You” (or “Your”)**  
+    means an individual or a legal entity exercising rights under this
+    License. For legal entities, “You” includes any entity that
+    controls, is controlled by, or is under common control with You. For
+    purposes of this definition, “control” means **(a)** the power, direct
+    or indirect, to cause the direction or management of such entity,
+    whether by contract or otherwise, or **(b)** ownership of more than
+    fifty percent (50%) of the outstanding shares or beneficial
+    ownership of such entity.
+
+
+### 2. License Grants and Conditions
+
+#### 2.1. Grants
+
+Each Contributor hereby grants You a world-wide, royalty-free,
+non-exclusive license:
+
+* **(a)** under intellectual property rights (other than patent or trademark)
+    Licensable by such Contributor to use, reproduce, make available,
+    modify, display, perform, distribute, and otherwise exploit its
+    Contributions, either on an unmodified basis, with Modifications, or
+    as part of a Larger Work; and
+* **(b)** under Patent Claims of such Contributor to make, use, sell, offer
+    for sale, have made, import, and otherwise transfer either its
+    Contributions or its Contributor Version.
+
+#### 2.2. Effective Date
+
+The licenses granted in Section 2.1 with respect to any Contribution
+become effective for each Contribution on the date the Contributor first
+distributes such Contribution.
+
+#### 2.3. Limitations on Grant Scope
+
+The licenses granted in this Section 2 are the only rights granted under
+this License. No additional rights or licenses will be implied from the
+distribution or licensing of Covered Software under this License.
+Notwithstanding Section 2.1(b) above, no patent license is granted by a
+Contributor:
+
+* **(a)** for any code that a Contributor has removed from Covered Software;
+    or
+* **(b)** for infringements caused by: **(i)** Your and any other third party's
+    modifications of Covered Software, or **(ii)** the combination of its
+    Contributions with other software (except as part of its Contributor
+    Version); or
+* **(c)** under Patent Claims infringed by Covered Software in the absence of
+    its Contributions.
+
+This License does not grant any rights in the trademarks, service marks,
+or logos of any Contributor (except as may be necessary to comply with
+the notice requirements in Section 3.4).
+
+#### 2.4. Subsequent Licenses
+
+No Contributor makes additional grants as a result of Your choice to
+distribute the Covered Software under a subsequent version of this
+License (see Section 10.2) or under the terms of a Secondary License (if
+permitted under the terms of Section 3.3).
+
+#### 2.5. Representation
+
+Each Contributor represents that the Contributor believes its
+Contributions are its original creation(s) or it has sufficient rights
+to grant the rights to its Contributions conveyed by this License.
+
+#### 2.6. Fair Use
+
+This License is not intended to limit any rights You have under
+applicable copyright doctrines of fair use, fair dealing, or other
+equivalents.
+
+#### 2.7. Conditions
+
+Sections 3.1, 3.2, 3.3, and 3.4 are conditions of the licenses granted
+in Section 2.1.
+
+
+### 3. Responsibilities
+
+#### 3.1. Distribution of Source Form
+
+All distribution of Covered Software in Source Code Form, including any
+Modifications that You create or to which You contribute, must be under
+the terms of this License. You must inform recipients that the Source
+Code Form of the Covered Software is governed by the terms of this
+License, and how they can obtain a copy of this License. You may not
+attempt to alter or restrict the recipients' rights in the Source Code
+Form.
+
+#### 3.2. Distribution of Executable Form
+
+If You distribute Covered Software in Executable Form then:
+
+* **(a)** such Covered Software must also be made available in Source Code
+    Form, as described in Section 3.1, and You must inform recipients of
+    the Executable Form how they can obtain a copy of such Source Code
+    Form by reasonable means in a timely manner, at a charge no more
+    than the cost of distribution to the recipient; and
+
+* **(b)** You may distribute such Executable Form under the terms of this
+    License, or sublicense it under different terms, provided that the
+    license for the Executable Form does not attempt to limit or alter
+    the recipients' rights in the Source Code Form under this License.
+
+#### 3.3. Distribution of a Larger Work
+
+You may create and distribute a Larger Work under terms of Your choice,
+provided that You also comply with the requirements of this License for
+the Covered Software. If the Larger Work is a combination of Covered
+Software with a work governed by one or more Secondary Licenses, and the
+Covered Software is not Incompatible With Secondary Licenses, this
+License permits You to additionally distribute such Covered Software
+under the terms of such Secondary License(s), so that the recipient of
+the Larger Work may, at their option, further distribute the Covered
+Software under the terms of either this License or such Secondary
+License(s).
+
+#### 3.4. Notices
+
+You may not remove or alter the substance of any license notices
+(including copyright notices, patent notices, disclaimers of warranty,
+or limitations of liability) contained within the Source Code Form of
+the Covered Software, except that You may alter any license notices to
+the extent required to remedy known factual inaccuracies.
+
+#### 3.5. Application of Additional Terms
+
+You may choose to offer, and to charge a fee for, warranty, support,
+indemnity or liability obligations to one or more recipients of Covered
+Software. However, You may do so only on Your own behalf, and not on
+behalf of any Contributor. You must make it absolutely clear that any
+such warranty, support, indemnity, or liability obligation is offered by
+You alone, and You hereby agree to indemnify every Contributor for any
+liability incurred by such Contributor as a result of warranty, support,
+indemnity or liability terms You offer. You may include additional
+disclaimers of warranty and limitations of liability specific to any
+jurisdiction.
+
+
+### 4. Inability to Comply Due to Statute or Regulation
+
+If it is impossible for You to comply with any of the terms of this
+License with respect to some or all of the Covered Software due to
+statute, judicial order, or regulation then You must: **(a)** comply with
+the terms of this License to the maximum extent possible; and **(b)**
+describe the limitations and the code they affect. Such description must
+be placed in a text file included with all distributions of the Covered
+Software under this License. Except to the extent prohibited by statute
+or regulation, such description must be sufficiently detailed for a
+recipient of ordinary skill to be able to understand it.
+
+
+### 5. Termination
+
+**5.1.** The rights granted under this License will terminate automatically
+if You fail to comply with any of its terms. However, if You become
+compliant, then the rights granted under this License from a particular
+Contributor are reinstated **(a)** provisionally, unless and until such
+Contributor explicitly and finally terminates Your grants, and **(b)** on an
+ongoing basis, if such Contributor fails to notify You of the
+non-compliance by some reasonable means prior to 60 days after You have
+come back into compliance. Moreover, Your grants from a particular
+Contributor are reinstated on an ongoing basis if such Contributor
+notifies You of the non-compliance by some reasonable means, this is the
+first time You have received notice of non-compliance with this License
+from such Contributor, and You become compliant prior to 30 days after
+Your receipt of the notice.
+
+**5.2.** If You initiate litigation against any entity by asserting a patent
+infringement claim (excluding declaratory judgment actions,
+counter-claims, and cross-claims) alleging that a Contributor Version
+directly or indirectly infringes any patent, then the rights granted to
+You by any and all Contributors for the Covered Software under Section
+2.1 of this License shall terminate.
+
+**5.3.** In the event of termination under Sections 5.1 or 5.2 above, all
+end user license agreements (excluding distributors and resellers) which
+have been validly granted by You or Your distributors under this License
+prior to termination shall survive termination.
+
+
+### 6. Disclaimer of Warranty
+
+> Covered Software is provided under this License on an “as is”
+> basis, without warranty of any kind, either expressed, implied, or
+> statutory, including, without limitation, warranties that the
+> Covered Software is free of defects, merchantable, fit for a
+> particular purpose or non-infringing. The entire risk as to the
+> quality and performance of the Covered Software is with You.
+> Should any Covered Software prove defective in any respect, You
+> (not any Contributor) assume the cost of any necessary servicing,
+> repair, or correction. This disclaimer of warranty constitutes an
+> essential part of this License. No use of any Covered Software is
+> authorized under this License except under this disclaimer.
+
+### 7. Limitation of Liability
+
+> Under no circumstances and under no legal theory, whether tort
+> (including negligence), contract, or otherwise, shall any
+> Contributor, or anyone who distributes Covered Software as
+> permitted above, be liable to You for any direct, indirect,
+> special, incidental, or consequential damages of any character
+> including, without limitation, damages for lost profits, loss of
+> goodwill, work stoppage, computer failure or malfunction, or any
+> and all other commercial damages or losses, even if such party
+> shall have been informed of the possibility of such damages. This
+> limitation of liability shall not apply to liability for death or
+> personal injury resulting from such party's negligence to the
+> extent applicable law prohibits such limitation. Some
+> jurisdictions do not allow the exclusion or limitation of
+> incidental or consequential damages, so this exclusion and
+> limitation may not apply to You.
+
+
+### 8. Litigation
+
+Any litigation relating to this License may be brought only in the
+courts of a jurisdiction where the defendant maintains its principal
+place of business and such litigation shall be governed by laws of that
+jurisdiction, without reference to its conflict-of-law provisions.
+Nothing in this Section shall prevent a party's ability to bring
+cross-claims or counter-claims.
+
+
+### 9. Miscellaneous
+
+This License represents the complete agreement concerning the subject
+matter hereof. If any provision of this License is held to be
+unenforceable, such provision shall be reformed only to the extent
+necessary to make it enforceable. Any law or regulation which provides
+that the language of a contract shall be construed against the drafter
+shall not be used to construe this License against a Contributor.
+
+
+### 10. Versions of the License
+
+#### 10.1. New Versions
+
+Mozilla Foundation is the license steward. Except as provided in Section
+10.3, no one other than the license steward has the right to modify or
+publish new versions of this License. Each version will be given a
+distinguishing version number.
+
+#### 10.2. Effect of New Versions
+
+You may distribute the Covered Software under the terms of the version
+of the License under which You originally received the Covered Software,
+or under the terms of any subsequent version published by the license
+steward.
+
+#### 10.3. Modified Versions
+
+If you create software not governed by this License, and you want to
+create a new license for such software, you may create and use a
+modified version of this License if you rename the license and remove
+any references to the name of the license steward (except to note that
+such modified license differs from this License).
+
+#### 10.4. Distributing Source Code Form that is Incompatible With Secondary Licenses
+
+If You choose to distribute Source Code Form that is Incompatible With
+Secondary Licenses under the terms of this version of the License, the
+notice described in Exhibit B of this License must be attached.
+
+## Exhibit A - Source Code Form License Notice
+
+    This Source Code Form is subject to the terms of the Mozilla Public
+    License, v. 2.0. If a copy of the MPL was not distributed with this
+    file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+If it is not possible or desirable to put the notice in a particular
+file, then You may include the notice in a location (such as a LICENSE
+file in a relevant directory) where a recipient would be likely to look
+for such a notice.
+
+You may add additional accurate notices of copyright ownership.
+
+## Exhibit B - “Incompatible With Secondary Licenses” Notice
+
+    This Source Code Form is "Incompatible With Secondary Licenses", as
+    defined by the Mozilla Public License, v. 2.0.
+
+
diff --git a/DarkMode/Version.h b/DarkMode/Version.h
deleted file mode 100644
index 6be74ccd7..000000000
--- a/DarkMode/Version.h
+++ /dev/null
@@ -1,25 +0,0 @@
-// SPDX-License-Identifier: GPL-3.0-or-later
-
-/*
- * Copyright (c) 2024-2025 ozone10
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-
-#define DM_VERSION_MAJOR    0
-#define DM_VERSION_MINOR    9
-#define DM_VERSION_REVISION 0
-
-#define DM_VERSION   "Dark mode v0.9.0"
-#define DM_COPYRIGHT "Copyright (c) 2024-2025 ozone10"
diff --git a/DarkMode/docs/Dark.ini b/DarkMode/docs/Dark.ini
new file mode 100644
index 000000000..90bc88a8c
--- /dev/null
+++ b/DarkMode/docs/Dark.ini
@@ -0,0 +1,166 @@
+; ===============================================
+; Dark.ini - Custom Color and UI Configuration
+; ===============================================
+
+; This is example file, which allows customization of colors and UI styles.
+; Place this file in the same folder as executable,
+; which use darkmodelib for it to take effect.
+; File should have same name as defined in source code of executable.
+; It is defined when not definig preprocessor macro _DARKMODELIB_NO_INI_CONFIG 
+; and using function static void initOptions(const std::wstring& iniName).
+
+; ===============================================
+; [main] - General configuration settings
+; ===============================================
+
+[main]
+; Determines theme and styling.
+; 0 - Use light mode.
+; 1 - Use dark mode (default when dark mode is enabled).
+; 2 - Follow system settings (light mode in system with light enabled).
+; 3 - Use classic style (default in system with light mode enabled).
+; 4 - Follow system settings (classic style in system with light enabled).
+mode = 1
+
+; *Tips: Renaming section will disable all "key=value" pairs of that section
+;        and default values will be used.
+
+; ===============================================
+; [dark] - Dark mode-specific settings
+; ===============================================
+
+[dark]
+; Defines default colors for dark mode.
+; 0 - Black (default).
+; 1 - Red.
+; 2 - Green.
+; 3 - Blue.
+; 4 - Purple.
+; 5 - Cyan.
+; 6 - Olive.
+tone = 0
+
+; Controls rounded corners on Windows 11.
+; 0 - System decides (default).
+; 1 - Never round window corners.
+; 2 - Round corners if appropriate.
+; 3 - Round corners with a small radius.
+roundCorner = 0
+
+; Sets window border color (RGB hex format: RRGGBB) on Windows 11.
+; FFFFFF - Use default system color (default).
+borderColor = "FFFFFF"
+
+; Applies Mica material (Windows 11 22H2 build 22621 required).
+; 0 - System decides (default).
+; 1 - Do not use Mica.
+; 2 - Apply Mica material.
+; 3 - Apply Acrylic effect.
+; 4 - Apply Mica Alt material.
+; *Note: When using mica=1 with Settings -> Personalization > Colors ->
+;        "Show accent color on title bars and window borders" setting on,
+;        turn this Windows setting off to prevent glitches.
+mica = 0
+
+; Expands Mica material across window/dialog (experimental).
+; 0 - Apply Mica only on title bar (default).
+; 1 - Extend Mica to all window/dialog elements.
+; * Note: Use micaExtend=1 only with HDR and ACM disabled to prevent glitches.
+micaExtend = 0
+
+; Should title bar use same colors as dialog background and static text
+; 0 - Use system colors (default).
+; 1 - Use custom colors (backgroundDlg and text).
+; * Note: with micaExtend=1 this option will be disabled.
+colorizeTitleBar = 0
+
+; ===============================================
+; [dark.colors] - Custom colors for dark mode UI
+; ===============================================
+
+[dark.colors]
+; Background color for "read-only" controls.
+background          = "202020"
+; Background color for controls (buttons, input fields).
+backgroundCtrl      = "383838"
+; Background color for hovered (hot) items.
+backgroundHot       = "454545"
+; Background color for dialogs and popups.
+backgroundDlg       = "202020"
+; Background color for error messages or alerts.
+backgroundError     = "B00000"
+; Primary text color for most UI elements.
+text                = "E0E0E0"
+; Low-light text color used as secondary color for some UI components.
+textItem            = "C0C0C0"
+; Text color used for disabled or inactive controls.
+textDisabled        = "808080"
+; Text color used for hyperlinks.
+textLink            = "FFFF00"
+; Border color used for standard UI elements.
+edge                = "646464"
+; Border color used for hovered elements.
+edgeHot             = "9B9B9B"
+; Border color for disabled or inactive elements.
+edgeDisabled        = "484848"
+
+; ===============================================
+; [dark.colors.view] - Colors for list and tree views
+; ===============================================
+
+[dark.colors.view]
+; Background color for list and tree views.
+backgroundView      = "3F3F3F"
+; Text color in list/tree view items.
+textView            = "DCDCDC"
+; Grid line color in list view (when grid lines are enabled).
+gridlines           = "646464"
+; Background color for headers in list/tree view.
+backgroundHeader    = "202020"
+; Background color for hovered headers.
+backgroundHotHeader = "454545"
+; Text color for headers.
+textHeader          = "C0C0C0"
+; Border color for headers.
+edgeHeader          = "646464"
+
+; ===============================================
+; [light] - Light mode-specific settings
+; ===============================================
+
+[light]
+roundCorner = 0
+borderColor  = "FFFFFF"
+mica = 0
+colorizeTitleBar = 0
+
+; ===============================================
+; [light.colors] - Custom colors for light mode UI
+; ===============================================
+
+[light.colors]
+background          = "F0F0F0"
+backgroundCtrl      = "FFFFFF"
+backgroundHot       = "C0DCF3"
+backgroundDlg       = "F0F0F0"
+backgroundError     = "A01000"
+text                = "000000"
+textItem            = "000000"
+textDisabled        = "6D6D6D"
+textLink            = "0078D4"
+edge                = "8D8D8D"
+edgeHot             = "0078D4"
+edgeDisabled        = "6D6D6D"
+
+; ===============================================
+; [light.colors.view] - Colors for list and tree views (light mode)
+; ===============================================
+
+[light.colors.view]
+backgroundView      = "FFFFFF"
+textView            = "000000"
+gridlines           = "F0F0F0"
+backgroundHeader    = "FFFFFF"
+backgroundHotHeader = "D9EBF9"
+textHeader          = "000000"
+edgeHeader          = "E5E5E5"
diff --git a/DarkMode/docs/LICENSE-PolyHook_2_0.md b/DarkMode/docs/LICENSE-PolyHook_2_0.md
new file mode 100644
index 000000000..f76de84c6
--- /dev/null
+++ b/DarkMode/docs/LICENSE-PolyHook_2_0.md
@@ -0,0 +1,21 @@
+MIT License
+
+Copyright (c) 2018 Stephen Eckels
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
diff --git a/DarkMode/docs/LICENSE-UAHMenuBar.md b/DarkMode/docs/LICENSE-UAHMenuBar.md
new file mode 100644
index 000000000..c1f88996d
--- /dev/null
+++ b/DarkMode/docs/LICENSE-UAHMenuBar.md
@@ -0,0 +1,21 @@
+MIT License
+
+Copyright (c) 2021 adzm
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
diff --git a/DarkMode/docs/LICENSE-win32-darkmode.md b/DarkMode/docs/LICENSE-win32-darkmode.md
new file mode 100644
index 000000000..13bdb5355
--- /dev/null
+++ b/DarkMode/docs/LICENSE-win32-darkmode.md
@@ -0,0 +1,21 @@
+MIT License
+
+Copyright (c) 2019 Richard Yu
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
diff --git a/DarkMode/DarkMode.cpp b/DarkMode/src/DarkMode.cpp
similarity index 96%
rename from DarkMode/DarkMode.cpp
rename to DarkMode/src/DarkMode.cpp
index a8530ca56..318be76ff 100644
--- a/DarkMode/DarkMode.cpp
+++ b/DarkMode/src/DarkMode.cpp
@@ -1,12 +1,17 @@
-// SPDX-License-Identifier: MIT
+// SPDX-License-Identifier: MPL-2.0
 
-// Copyright (c) 2024-2025 ozone10
-// MIT license
+/*
+ * Copyright (c) 2025 oZone10
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at https://mozilla.org/MPL/2.0/.
+ *
+ * This file incorporates work from the win32-darkmode project:
+ *  https://github.com/ysc3839/win32-darkmode
+ *  which is covered by the MIT License.
+ *  See LICENSE-win32-darkmode for more information.
+ */
 
-// This file contains parts of code from the win32-darkmode project
-// https://github.com/ysc3839/win32-darkmode
-// which is licensed under the MIT License.
-// See LICENSE-win32-darkmode for more information.
 
 #include "StdAfx.h"
 
@@ -358,11 +363,6 @@ static HTHEME WINAPI MyOpenNcThemeData(HWND hWnd, LPCWSTR pszClassList)
 			hWnd = nullptr;
 			pszClassList = L"Explorer::ScrollBar";
 		}
-		//else if (g_darkModeEnabled)
-		//{
-		//	hWnd = nullptr;
-		//	pszClassList = L"DarkMode_Explorer::ScrollBar";
-		//}
 	}
 	return pfOpenNcThemeData(hWnd, pszClassList);
 }
@@ -492,7 +492,6 @@ void SetDarkMode(bool useDark, bool fixDarkScrollbar)
 	if (g_darkModeSupported)
 	{
 		AllowDarkModeForApp(useDark);
-		//pfRefreshImmersiveColorPolicyState();
 		FlushMenuThemes();
 		if (fixDarkScrollbar)
 		{
@@ -502,7 +501,7 @@ void SetDarkMode(bool useDark, bool fixDarkScrollbar)
 	}
 }
 
-// Hooking GetSysColor for comboboxex listbox
+// Hooking GetSysColor for comboboxex' list box and list view's gridlines
 
 using fnGetSysColor = auto (WINAPI*)(int nIndex) -> DWORD;
 
diff --git a/DarkMode/DarkMode.h b/DarkMode/src/DarkMode.h
similarity index 64%
rename from DarkMode/DarkMode.h
rename to DarkMode/src/DarkMode.h
index 5dfce6ad4..c05daf907 100644
--- a/DarkMode/DarkMode.h
+++ b/DarkMode/src/DarkMode.h
@@ -1,12 +1,17 @@
-// SPDX-License-Identifier: MIT
+// SPDX-License-Identifier: MPL-2.0
+
+/*
+ * Copyright (c) 2025 oZone10
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at https://mozilla.org/MPL/2.0/.
+ *
+ * This file incorporates work from the win32-darkmode project:
+ *  https://github.com/ysc3839/win32-darkmode
+ *  which is covered by the MIT License.
+ *  See LICENSE-win32-darkmode for more information.
+ */
 
-// Copyright (c) 2024-2025 ozone10
-// MIT license
-
-// This file contains parts of code from the win32-darkmode project
-// https://github.com/ysc3839/win32-darkmode
-// which is licensed under the MIT License.
-// See LICENSE-win32-darkmode for more information.
 
 #pragma once
 
diff --git a/DarkMode/DarkModeSubclass.cpp b/DarkMode/src/DarkModeSubclass.cpp
similarity index 58%
rename from DarkMode/DarkModeSubclass.cpp
rename to DarkMode/src/DarkModeSubclass.cpp
index 269d858c7..bed00cd26 100644
--- a/DarkMode/DarkModeSubclass.cpp
+++ b/DarkMode/src/DarkModeSubclass.cpp
@@ -1,25 +1,16 @@
-﻿// SPDX-License-Identifier: GPL-3.0-or-later
+﻿// SPDX-License-Identifier: MPL-2.0
 
 /*
- * Copyright (c) 2024-2025 ozone10
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ * Copyright (c) 2025 oZone10
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at https://mozilla.org/MPL/2.0/.
  */
 
-
-// Based on Notepad++ dark mode code, original by adzm / Adam D. Walling
-// with modification from Notepad++ team.
-// Heavily modified by ozone10 (contributor of Notepad++)
+// Based on the Notepad++ dark mode code licensed under GPLv3.
+// Originally by adzm / Adam D. Walling, with modifications by the Notepad++ team.
+// Heavily modified by oZone10 (Notepad++ contributor).
+// Used with permission to relicense under the Mozilla Public License, v. 2.0.
 
 
 #include "StdAfx.h"
@@ -76,17 +67,28 @@ static constexpr int CP_DROPDOWNITEM = 9; // for some reason mingw use only enum
 //#define WM_GETDPISCALEDSIZE 0x02E4
 //#endif
 
+/// Converts 0xRRGGBB to COLORREF (0xBBGGRR) for GDI usage.
 static constexpr COLORREF HEXRGB(DWORD rrggbb)
 {
-	// from 0xRRGGBB like natural #RRGGBB
-	// to the little-endian 0xBBGGRR
 	return
 		((rrggbb & 0xFF0000) >> 16) |
 		((rrggbb & 0x00FF00)) |
 		((rrggbb & 0x0000FF) << 16);
 }
 
-static std::wstring getWndClassName(HWND hWnd)
+/**
+ * @brief Retrieves the class name of a given window.
+ *
+ * This function wraps the Win32 API `GetClassNameW` to return the class name
+ * of a window as a wide string (`std::wstring`).
+ *
+ * @param hWnd Handle to the target window.
+ * @return The class name of the window as a `std::wstring`.
+ *
+ * @note The maximum length is capped at 32 characters (including the null terminator),
+ *       which suffices for standard Windows window classes.
+ */
+static std::wstring GetWndClassName(HWND hWnd)
 {
 	static constexpr int strLen = 32;
 	std::wstring className(strLen, L'\0');
@@ -94,13 +96,36 @@ static std::wstring getWndClassName(HWND hWnd)
 	return className;
 }
 
-static bool cmpWndClassName(HWND hWnd, const wchar_t* classNameToCmp)
+/**
+ * @brief Compares the class name of a window with a specified string.
+ *
+ * This function retrieves the class name of the given window handle
+ * and compares it to the provided class name.
+ *
+ * @param hWnd Handle to the window whose class name is to be checked.
+ * @param classNameToCmp Pointer to a null-terminated wide string representing the class name to compare against.
+ * @return `true` if the window's class name matches the specified string; otherwise `false`.
+ *
+ * @see GetWndClassName()
+ */
+static bool CmpWndClassName(HWND hWnd, const wchar_t* classNameToCmp)
 {
-	return (getWndClassName(hWnd) == classNameToCmp);
+	return (GetWndClassName(hWnd) == classNameToCmp);
 }
 
 #if !defined(_DARKMODELIB_NO_INI_CONFIG)
-static std::wstring getIniPath(const std::wstring& iniFilename)
+/**
+ * @brief Constructs a full path to an `.ini` file located next to the executable.
+ *
+ * Retrieves the directory of the current module (executable or DLL) and appends
+ * the specified `.ini` filename to it.
+ *
+ * @param iniFilename The base name of the `.ini` file (without path or extension).
+ * @return Full path to the `.ini` file as a wide string, or an empty string on failure.
+ *
+ * @note Returns a path like: `C:\\Path\\To\\Executable\\YourFile.ini`
+ */
+static std::wstring GetIniPath(const std::wstring& iniFilename)
 {
 	std::array<wchar_t, MAX_PATH> buffer{};
 	const auto strLen = static_cast<size_t>(::GetModuleFileNameW(nullptr, buffer.data(), MAX_PATH));
@@ -121,13 +146,35 @@ static std::wstring getIniPath(const std::wstring& iniFilename)
 	return iniPath;
 }
 
-static bool fileExists(const std::wstring& filePath)
+/**
+ * @brief Checks whether a file exists at the specified path.
+ *
+ * Determines if the given file path exists and refers to a regular file.
+ *
+ * @param filePath Path to the file to check.
+ * @return `true` if the file exists and is not a directory, otherwise `false`.
+ */
+static bool FileExists(const std::wstring& filePath)
 {
 	const DWORD dwAttrib = ::GetFileAttributesW(filePath.c_str());
 	return (dwAttrib != INVALID_FILE_ATTRIBUTES && ((dwAttrib & FILE_ATTRIBUTE_DIRECTORY) != FILE_ATTRIBUTE_DIRECTORY));
 }
 
-static bool setClrFromIni(const std::wstring& sectionName, const std::wstring& keyName, const std::wstring& iniFilePath, COLORREF* clr)
+/**
+ * @brief Reads a color value from an `.ini` file and converts it to a `COLORREF`.
+ *
+ * Reads a 6-digit hex color string from the specified section and key, then parses
+ * it as a Windows GDI `COLORREF` value.
+ *
+ * @param sectionName Section within the `.ini` file.
+ * @param keyName Key name containing the hex RGB value (e.g., "E0E2E4").
+ * @param iniFilePath Full path to the `.ini` file.
+ * @param clr Pointer to a `COLORREF` where the parsed color will be stored. **Must not be `nullptr`.**
+ * @return `true` if a valid 6-digit hex color was read and parsed, otherwise `false`.
+ *
+ * @note The value must be exactly 6 hexadecimal digits and represent an RGB color.
+ */
+static bool SetClrFromIni(const std::wstring& sectionName, const std::wstring& keyName, const std::wstring& iniFilePath, COLORREF* clr)
 {
 	static constexpr size_t maxStrLen = 6;
 	std::wstring buffer(maxStrLen + 1, L'\0');
@@ -171,6 +218,23 @@ static bool setClrFromIni(const std::wstring& sectionName, const std::wstring& k
 
 namespace DarkMode
 {
+	/**
+	 * @brief Returns library version information or compile-time feature flags.
+	 *
+	 * Responds to the specified query by returning either:
+	 * - Version numbers (`verMajor`, `verMinor`, `verRevision`)
+	 * - Build configuration flags (returns `TRUE` or `FALSE`)
+	 * - A constant value (`featureCheck`, `maxValue`) used for validation
+	 *
+	 * @param libInfoType Enum value specifying which piece of information to retrieve.
+	 * @return Integer value:
+	 * - Version: as defined by `DM_VERSION_MAJOR`, etc.
+	 * - Boolean flags: `TRUE` (1) if the feature is enabled, `FALSE` (0) otherwise.
+	 * - `featureCheck`, `maxValue`: returns the numeric max enum value.
+	 * - `-1`: for invalid or unhandled enum cases (should not occur in correct usage).
+	 *
+	 * @see LibInfo
+	 */
 	int getLibInfo(LibInfo libInfoType)
 	{
 		switch (libInfoType)
@@ -229,26 +293,34 @@ namespace DarkMode
 				return TRUE;
 #else
 				return FALSE;
+#endif
+			}
+
+			case LibInfo::preferTheme:
+			{
+#if defined(_DARKMODELIB_PREFER_THEME)
+				return TRUE;
+#else
+				return FALSE;
 #endif
 			}
 		}
 		return -1; // should never happen
 	}
 
-	enum class DarkModeType : std::uint8_t
-	{
-		light   = 0,
-		dark    = 1,
-		//windows = 2, // never used
-
-		classic = 3
-	};
-
+	/**
+	 * @brief Describes how the application responds to the system theme.
+	 *
+	 * Used to determine behavior when following the system's light/dark mode setting.
+	 * - `disabled`: Do not follow system; use manually selected appearance.
+	 * - `light`: Follow system mode; apply light theme when system is in light mode.
+	 * - `classic`: Follow system mode; apply classic style when system is in light mode.
+	 */
 	enum class WinMode : std::uint8_t
 	{
-		disabled,
-		light,
-		classic
+		disabled,  ///< Manual — system mode is ignored.
+		light,     ///< Use light theme if system is in light mode.
+		classic    ///< Use classic style if system is in light mode.
 	};
 
 	static constexpr UINT_PTR kButtonSubclassID                 = 42;
@@ -270,6 +342,17 @@ namespace DarkMode
 	static constexpr UINT_PTR kWindowMenuBarSubclassID          = 16;
 	static constexpr UINT_PTR kWindowSettingChangeSubclassID    = 17;
 
+	/**
+	 * @struct DarkModeParams
+	 * @brief Defines theming and subclassing parameters for child controls.
+	 *
+	 * Members:
+	 * - `_themeClassName`: Optional theme class name (e.g. `"DarkMode_Explorer"`), or `nullptr` to skip theming.
+	 * - `_subclass`: Whether to apply custom subclassing for dark-mode painting and behavior.
+	 * - `_theme`: Whether to apply a themed visual style to applicable controls.
+	 *
+	 * Used during enumeration to configure dark mode application on a per-control basis.
+	 */
 	struct DarkModeParams
 	{
 		const wchar_t* _themeClassName = nullptr;
@@ -277,35 +360,37 @@ namespace DarkMode
 		bool _theme = false;
 	};
 
+	/// Base roundness value for various controls, such as toolbar iconic buttons and combo boxes
 	static constexpr int kWin11CornerRoundness = 4;
 
-	static struct
+	/// Threshold range around 50.0 where TreeView uses classic style instead of light/dark.
+	static constexpr double kMiddleGrayRange = 2.0;
+
+	namespace // anonymous
 	{
-		DWM_WINDOW_CORNER_PREFERENCE _roundCorner = DWMWCP_DEFAULT;
-		COLORREF _borderColor = DWMWA_COLOR_DEFAULT;
-		DWM_SYSTEMBACKDROP_TYPE _mica = DWMSBT_AUTO;
-		TreeViewStyle _treeViewStyle = TreeViewStyle::classic;
-		bool _micaExtend = false;
-		DarkModeType _dmType = DarkModeType::dark;
-		WinMode _windowsMode = WinMode::disabled;
-		bool _isInit = false;
-		bool _isInitExperimental = false;
+		/// Global struct
+		struct
+		{
+			DWM_WINDOW_CORNER_PREFERENCE _roundCorner = DWMWCP_DEFAULT;
+			COLORREF _borderColor = DWMWA_COLOR_DEFAULT;
+			DWM_SYSTEMBACKDROP_TYPE _mica = DWMSBT_AUTO;
+			COLORREF _tvBackground = RGB(41, 49, 52);
+			double _lightness = 50.0;
+			TreeViewStyle _tvStylePrev = TreeViewStyle::classic;
+			TreeViewStyle _tvStyle = TreeViewStyle::classic;
+			bool _micaExtend = false;
+			bool _colorizeTitleBar = false;
+			DarkModeType _dmType = DarkModeType::dark;
+			WinMode _windowsMode = WinMode::disabled;
+			bool _isInit = false;
+			bool _isInitExperimental = false;
 
 #if !defined(_DARKMODELIB_NO_INI_CONFIG)
-		bool _isIniNameSet = false;
-		std::wstring _iniName;
+			std::wstring _iniName;
+			bool _isIniNameSet = false;
 #endif
-	} g_dmCfg;
-
-	// range to determine when it should be better to use classic style for tree view
-	static constexpr double MiddleGrayRange = 2.0;
-
-	static struct
-	{
-		double _lightness = 50.0;
-		COLORREF _background = RGB(41, 49, 52);
-		TreeViewStyle _stylePrev = TreeViewStyle::classic;
-	} g_tvCfg;
+		} g_dmCfg;
+	} // anonymous namespace
 
 	struct Brushes
 	{
@@ -418,10 +503,9 @@ namespace DarkMode
 			_hotEdge = ::CreatePen(PS_SOLID, 1, colors.hotEdge);
 			_disabledEdge = ::CreatePen(PS_SOLID, 1, colors.disabledEdge);
 		}
-
 	};
 
-	// black (default)
+	/// Black tone (default)
 	static constexpr Colors darkColors{
 		HEXRGB(0x202020),   // background
 		HEXRGB(0x383838),   // ctrlBackground
@@ -439,7 +523,7 @@ namespace DarkMode
 
 	static constexpr DWORD offsetEdge = HEXRGB(0x1C1C1C);
 
-	// red tone
+	/// Red tone
 	static constexpr DWORD offsetRed = HEXRGB(0x100000);
 	static constexpr Colors darkRedColors{
 		darkColors.background + offsetRed,
@@ -456,7 +540,7 @@ namespace DarkMode
 		darkColors.disabledEdge + offsetRed
 	};
 
-	// green tone
+	/// Green tone
 	static constexpr DWORD offsetGreen = HEXRGB(0x001000);
 	static constexpr Colors darkGreenColors{
 		darkColors.background + offsetGreen,
@@ -473,7 +557,7 @@ namespace DarkMode
 		darkColors.disabledEdge + offsetGreen
 	};
 
-	// blue tone
+	/// Blue tone
 	static constexpr DWORD offsetBlue = HEXRGB(0x000020);
 	static constexpr Colors darkBlueColors{
 		darkColors.background + offsetBlue,
@@ -490,7 +574,7 @@ namespace DarkMode
 		darkColors.disabledEdge + offsetBlue
 	};
 
-	// purple tone
+	/// Purple tone
 	static constexpr DWORD offsetPurple = HEXRGB(0x100020);
 	static constexpr Colors darkPurpleColors{
 		darkColors.background + offsetPurple,
@@ -507,7 +591,7 @@ namespace DarkMode
 		darkColors.disabledEdge + offsetPurple
 	};
 
-	// cyan tone
+	/// Cyan tone
 	static constexpr DWORD offsetCyan = HEXRGB(0x001020);
 	static constexpr Colors darkCyanColors{
 		darkColors.background + offsetCyan,
@@ -524,7 +608,7 @@ namespace DarkMode
 		darkColors.disabledEdge + offsetCyan
 	};
 
-	// olive tone
+	/// Olive tone
 	static constexpr DWORD offsetOlive = HEXRGB(0x101000);
 	static constexpr Colors darkOliveColors{
 		darkColors.background + offsetOlive,
@@ -541,6 +625,7 @@ namespace DarkMode
 		darkColors.disabledEdge + offsetOlive
 	};
 
+	/// Light tone
 	static Colors getLightColors()
 	{
 		const Colors lightColors{
@@ -588,6 +673,49 @@ namespace DarkMode
 			Theme::updateTheme();
 		}
 
+		[[nodiscard]] Colors getToneColors() const
+		{
+			switch (_tone)
+			{
+				case ColorTone::red:
+				{
+					return darkRedColors;
+				}
+
+				case ColorTone::green:
+				{
+					return darkGreenColors;
+				}
+
+				case ColorTone::blue:
+				{
+					return darkBlueColors;
+				}
+
+				case ColorTone::purple:
+				{
+					return darkPurpleColors;
+				}
+
+				case ColorTone::cyan:
+				{
+					return darkCyanColors;
+				}
+
+				case ColorTone::olive:
+				{
+					return darkOliveColors;
+				}
+
+				case ColorTone::black:
+				case ColorTone::max:
+				{
+					break;
+				}
+			}
+			return darkColors;
+		}
+
 		void setToneColors(ColorTone colorTone)
 		{
 			_tone = colorTone;
@@ -641,6 +769,12 @@ namespace DarkMode
 			Theme::updateTheme();
 		}
 
+		void setToneColors()
+		{
+			_colors = Theme::getToneColors();
+			Theme::updateTheme();
+		}
+
 		[[nodiscard]] const Brushes& getBrushes() const
 		{
 			return _brushes;
@@ -664,18 +798,40 @@ namespace DarkMode
 		ColorTone _tone = DarkMode::ColorTone::black;
 	};
 
-	static Theme tMain;
-
 	static Theme& getTheme()
 	{
+		static Theme tMain{};
 		return tMain;
 	}
 
+	/**
+	 * @brief Sets the color tone and its color set for the active theme.
+	 *
+	 * Applies a color tone (e.g. red, blue, olive) its color set.
+	 *
+	 * @param colorTone The tone to apply (see @ref ColorTone enum).
+	 *
+	 * @see DarkMode::getColorTone()
+	 * @see DarkMode::Theme
+	 */
+	void setColorTone(ColorTone colorTone)
+	{
+		DarkMode::getTheme().setToneColors(colorTone);
+	}
+
+	/**
+	 * @brief Retrieves the currently active color tone for the theme.
+	 *
+	 * @return The currently selected @ref ColorTone value.
+	 *
+	 * @see DarkMode::setColorTone()
+	 */
 	ColorTone getColorTone()
 	{
 		return DarkMode::getTheme().getColorTone();
 	}
 
+	/// Dark views colors
 	static constexpr ColorsView darkColorsView{
 		HEXRGB(0x293134),   // background
 		HEXRGB(0xE0E2E4),   // text
@@ -686,6 +842,7 @@ namespace DarkMode
 		HEXRGB(0x646464)    // header divider
 	};
 
+	/// Light views colors
 	static constexpr ColorsView lightColorsView{
 		HEXRGB(0xFFFFFF),   // background
 		HEXRGB(0x000000),   // text
@@ -785,10 +942,9 @@ namespace DarkMode
 		BrushesAndPensView _hbrPnView;
 	};
 
-	static ThemeView tView;
-
 	static ThemeView& getThemeView()
 	{
+		static ThemeView tView{};
 		return tView;
 	}
 
@@ -886,6 +1042,78 @@ namespace DarkMode
 
 	HPEN getHeaderEdgePen()                 { return DarkMode::getThemeView().getViewBrushesAndPens()._headerEdge; }
 
+	/**
+	 * @brief Initializes default color set based on the current mode type.
+	 *
+	 * Sets up control and view colors depending on the active theme:
+	 * - `dark`: Applies dark tone color set and view dark color set.
+	 * - `light`: Applies the predefined light color set and view light color set.
+	 * - `classic`: Applies only system color on views, other controls are not affected
+	 *              by theme colors.
+	 *
+	 * If `updateBrushesAndOther` is `true`, also updates
+	 * brushes, pens, and view styles (unless in classic mode).
+	 *
+	 * @param updateBrushesAndOther Whether to refresh GDI brushes and pens, and tree view styling.
+	 *
+	 * @see DarkMode::setToneColors
+	 * @see DarkMode::updateThemeBrushesAndPens
+	 * @see DarkMode::calculateTreeViewStyle
+	 */
+	void setDefaultColors(bool updateBrushesAndOther)
+	{
+		switch (g_dmCfg._dmType)
+		{
+			case DarkModeType::dark:
+			{
+				DarkMode::getTheme().setToneColors();
+				DarkMode::getThemeView()._clrView = DarkMode::darkColorsView;
+				break;
+			}
+
+			case DarkModeType::light:
+			{
+				DarkMode::getTheme()._colors = DarkMode::getLightColors();
+				DarkMode::getThemeView()._clrView = DarkMode::lightColorsView;
+				break;
+			}
+
+			case DarkModeType::classic:
+			{
+				DarkMode::setViewBackgroundColor(::GetSysColor(COLOR_WINDOW));
+				DarkMode::setViewTextColor(::GetSysColor(COLOR_WINDOWTEXT));
+				break;
+			}
+		}
+
+		if (updateBrushesAndOther)
+		{
+			if (g_dmCfg._dmType != DarkModeType::classic)
+			{
+				DarkMode::updateThemeBrushesAndPens();
+				DarkMode::updateViewBrushesAndPens();
+			}
+
+			DarkMode::calculateTreeViewStyle();
+		}
+	}
+
+	/**
+	 * @brief Initializes the dark mode configuration based on the selected mode.
+	 *
+	 * Sets the active dark mode rendering and system-following behavior according to the specified `dmType`:
+	 * - `0`: Light mode, do not follow system.
+	 * - `1` or default: Dark mode, do not follow system.
+	 * - `2`: *[Internal]* Follow system — light or dark depending on registry (see `DarkMode::isDarkModeReg()`).
+	 * - `3`: Classic mode, do not follow system.
+	 * - `4`: *[Internal]* Follow system — classic or dark depending on registry.
+	 *
+	 * @param dmType Integer representing the desired mode.
+	 *
+	 * @see DarkModeType
+	 * @see WinMode
+	 * @see DarkMode::isDarkModeReg()
+	 */
 	void initDarkModeConfig(UINT dmType)
 	{
 		switch (dmType)
@@ -928,6 +1156,17 @@ namespace DarkMode
 		}
 	}
 
+	/**
+	 * @brief Sets the preferred window corner style on Windows 11.
+	 *
+	 * Assigns a valid `DWM_WINDOW_CORNER_PREFERENCE` value to the config,
+	 * falling back to `DWMWCP_DEFAULT` if the input is out of range.
+	 *
+	 * @param roundCornerStyle Integer value representing a `DWM_WINDOW_CORNER_PREFERENCE`.
+	 *
+	 * @see https://learn.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwm_window_corner_preference
+	 * @see DarkMode::setDarkTitleBarEx()
+	 */
 	void setRoundCornerConfig(UINT roundCornerStyle)
 	{
 		const auto cornerStyle = static_cast<DWM_WINDOW_CORNER_PREFERENCE>(roundCornerStyle);
@@ -943,6 +1182,17 @@ namespace DarkMode
 
 	static constexpr DWORD kDwmwaClrDefaultRGBCheck = 0x00FFFFFF;
 
+	/**
+	 * @brief Sets the preferred border color for window edge on Windows 11.
+	 *
+	 * Assigns the given `COLORREF` to the configuration. If the value matches
+	 * `kDwmwaClrDefaultRGBCheck`, the color is reset to `DWMWA_COLOR_DEFAULT`.
+	 *
+	 * @param clr Border color value, or sentinel to reset to system default.
+	 *
+	 * @see DWMWA_BORDER_COLOR
+	 * @see DarkMode::setDarkTitleBarEx()
+	 */
 	void setBorderColorConfig(COLORREF clr)
 	{
 		if (clr == kDwmwaClrDefaultRGBCheck)
@@ -955,6 +1205,17 @@ namespace DarkMode
 		}
 	}
 
+	/**
+	 * @brief Sets the Mica effects on Windows 11 setting.
+	 *
+	 * Assigns a valid `DWM_SYSTEMBACKDROP_TYPE` to the configuration. If the value exceeds
+	 * `DWMSBT_TABBEDWINDOW`, it falls back to `DWMSBT_AUTO`.
+	 *
+	 * @param mica Integer value representing a `DWM_SYSTEMBACKDROP_TYPE`.
+	 *
+	 * @see DWM_SYSTEMBACKDROP_TYPE
+	 * @see DarkMode::setDarkTitleBarEx()
+	 */
 	void setMicaConfig(UINT mica)
 	{
 		const auto micaType = static_cast<DWM_SYSTEMBACKDROP_TYPE>(mica);
@@ -968,12 +1229,137 @@ namespace DarkMode
 		}
 	}
 
+	/**
+	 * @brief Sets Mica effects on the full window setting.
+	 *
+	 * Controls whether Mica should be applied to the entire window
+	 * or limited to the title bar only.
+	 *
+	 * @param extendMica `true` to apply Mica to the full window, `false` for title bar only.
+	 *
+	 * @see DarkMode::setDarkTitleBarEx()
+	 */
 	void setMicaExtendedConfig(bool extendMica)
 	{
 		g_dmCfg._micaExtend = extendMica;
 	}
 
+	/**
+	 * @brief Sets dialog colors on title bar on Windows 11 setting.
+	 *
+	 * Controls whether title bar should have same colors as dialog window.
+	 *
+	 * @param colorize `true` to have title bar to have same colors as dialog window.
+	 *
+	 * @see DarkMode::setDarkTitleBarEx()
+	 */
+	void setColorizeTitleBarConfig(bool colorize)
+	{
+		g_dmCfg._colorizeTitleBar = colorize;
+	}
+
+	/**
+	 * @brief Initializes undocumented dark mode API.
+	 *
+	 * Wraps `InitDarkMode()` from DarkMode.h.
+	 */
+	static void initExperimentalDarkMode()
+	{
+		::InitDarkMode();
+	}
+
+	/**
+	 * @brief Enables or disables dark mode using undocumented API.
+	 *
+	 * Optionally applies a scrollbar fix for dark mode inconsistencies.
+	 *
+	 * @param useDark Enable dark mode when `true`, disable when `false`.
+	 * @param fixDarkScrollbar Apply scrollbar fix if `true`.
+	 */
+	static void setDarkMode(bool useDark, bool fixDarkScrollbar = true)
+	{
+		::SetDarkMode(useDark, fixDarkScrollbar);
+	}
+
+	/**
+	 * @brief Enables or disables dark mode support for a specific window.
+	 *
+	 * @param hWnd Window handle to apply dark mode.
+	 * @param allow Whether to allow (`true`) or disallow (`false`) dark mode.
+	 * @return `true` if successfully applied.
+	 */
+	static bool allowDarkModeForWindow(HWND hWnd, bool allow)
+	{
+		return ::AllowDarkModeForWindow(hWnd, allow);
+	}
+
+#if defined(_DARKMODELIB_ALLOW_OLD_OS)
+	/**
+	 * @brief Refreshes the title bar theme color for legacy systems.
+	 *
+	 * Used only on old Windows 10 systems when `_DARKMODELIB_ALLOW_OLD_OS` is defined.
+	 *
+	 * @param hWnd Handle to the window to update.
+	 */
+	static void setTitleBarThemeColor(HWND hWnd)
+	{
+		::RefreshTitleBarThemeColor(hWnd);
+	}
+#endif
+
+	/**
+	 * @brief Checks whether a `WM_SETTINGCHANGE` message indicates a color scheme switch.
+	 *
+	 * @param lParam LPARAM from a system message.
+	 * @return `true` if the message signals a theme mode change.
+	 */
+	[[nodiscard]] static bool isColorSchemeChangeMessage(LPARAM lParam)
+	{
+		return ::IsColorSchemeChangeMessage(lParam);
+	}
+
+	/**
+	 * @brief Determines if high contrast mode is currently active.
+	 *
+	 * @return `true` if high contrast is enabled via system accessibility settings.
+	 */
+	static bool isHighContrast()
+	{
+		return ::IsHighContrast();
+	}
+
+	/**
+	 * @brief Determines if themed styling should be preferred over subclassing.
+	 *
+	 * Requires support for experimental theming and Windows 10 or later.
+	 *
+	 * @return `true` if themed appearance is preferred and supported.
+	 */
+	static bool isThemePrefered()
+	{
+		return (DarkMode::getLibInfo(LibInfo::preferTheme) == TRUE)
+			&& DarkMode::isAtLeastWindows10()
+			&& DarkMode::isExperimentalSupported();
+	}
+
 #if !defined(_DARKMODELIB_NO_INI_CONFIG)
+	 /**
+	  * @brief Initializes dark mode configuration and colors from an INI file.
+	  *
+	  * Loads configuration values from the specified INI file path and applies them to the
+	  * current dark mode settings. This includes:
+	  * - Base appearance (`DarkModeType`) and system-following mode (`WinMode`)
+	  * - Optional Mica and rounded corner styling
+	  * - Custom colors for background, text, borders, and headers (if present)
+	  * - Tone settings for dark theme (`ColorTone`)
+	  *
+	  * If the INI file does not exist, default dark mode behavior is applied via
+	  * @ref DarkMode::setDarkModeConfig.
+	  *
+	  * @param iniName Name of INI file (resolved via @ref GetIniPath).
+	  *
+	  * @note When `DarkModeType::classic` is set, system colors are used instead of themed ones.
+	  */
 	static void initOptions(const std::wstring& iniName)
 	{
 		if (iniName.empty())
@@ -981,14 +1367,14 @@ namespace DarkMode
 			return;
 		}
 
-		const std::wstring iniPath = getIniPath(iniName);
-		if (fileExists(iniPath))
+		const std::wstring iniPath = GetIniPath(iniName);
+		if (FileExists(iniPath))
 		{
 			DarkMode::initDarkModeConfig(::GetPrivateProfileIntW(L"main", L"mode", 1, iniPath.c_str()));
 			if (g_dmCfg._dmType == DarkModeType::classic)
 			{
-				DarkMode::setViewBackgroundColor(::GetSysColor(COLOR_WINDOW));
-				DarkMode::setViewTextColor(::GetSysColor(COLOR_WINDOWTEXT));
+				DarkMode::setDarkModeConfig(static_cast<UINT>(DarkModeType::classic));
+				DarkMode::setDefaultColors(false);
 				return;
 			}
 
@@ -1000,7 +1386,7 @@ namespace DarkMode
 
 			DarkMode::setMicaConfig(::GetPrivateProfileIntW(sectionBase.c_str(), L"mica", 0, iniPath.c_str()));
 			DarkMode::setRoundCornerConfig(::GetPrivateProfileIntW(sectionBase.c_str(), L"roundCorner", 0, iniPath.c_str()));
-			setClrFromIni(sectionBase, L"borderColor", iniPath, &g_dmCfg._borderColor);
+			SetClrFromIni(sectionBase, L"borderColor", iniPath, &g_dmCfg._borderColor);
 			if (g_dmCfg._borderColor == kDwmwaClrDefaultRGBCheck)
 			{
 				g_dmCfg._borderColor = DWMWA_COLOR_DEFAULT;
@@ -1031,88 +1417,105 @@ namespace DarkMode
 				DarkMode::getThemeView()._clrView = DarkMode::lightColorsView;
 			}
 
-			setClrFromIni(sectionColorsView, L"backgroundView", iniPath, &DarkMode::getThemeView()._clrView.background);
-			setClrFromIni(sectionColorsView, L"textView", iniPath, &DarkMode::getThemeView()._clrView.text);
-			setClrFromIni(sectionColorsView, L"gridlines", iniPath, &DarkMode::getThemeView()._clrView.gridlines);
-			setClrFromIni(sectionColorsView, L"backgroundHeader", iniPath, &DarkMode::getThemeView()._clrView.headerBackground);
-			setClrFromIni(sectionColorsView, L"backgroundHotHeader", iniPath, &DarkMode::getThemeView()._clrView.headerHotBackground);
-			setClrFromIni(sectionColorsView, L"textHeader", iniPath, &DarkMode::getThemeView()._clrView.headerText);
-			setClrFromIni(sectionColorsView, L"edgeHeader", iniPath, &DarkMode::getThemeView()._clrView.headerEdge);
+			SetClrFromIni(sectionColorsView, L"backgroundView", iniPath, &DarkMode::getThemeView()._clrView.background);
+			SetClrFromIni(sectionColorsView, L"textView", iniPath, &DarkMode::getThemeView()._clrView.text);
+			SetClrFromIni(sectionColorsView, L"gridlines", iniPath, &DarkMode::getThemeView()._clrView.gridlines);
+			SetClrFromIni(sectionColorsView, L"backgroundHeader", iniPath, &DarkMode::getThemeView()._clrView.headerBackground);
+			SetClrFromIni(sectionColorsView, L"backgroundHotHeader", iniPath, &DarkMode::getThemeView()._clrView.headerHotBackground);
+			SetClrFromIni(sectionColorsView, L"textHeader", iniPath, &DarkMode::getThemeView()._clrView.headerText);
+			SetClrFromIni(sectionColorsView, L"edgeHeader", iniPath, &DarkMode::getThemeView()._clrView.headerEdge);
 
-			setClrFromIni(sectionColors, L"background", iniPath, &DarkMode::getTheme()._colors.background);
-			setClrFromIni(sectionColors, L"backgroundCtrl", iniPath, &DarkMode::getTheme()._colors.ctrlBackground);
-			setClrFromIni(sectionColors, L"backgroundHot", iniPath, &DarkMode::getTheme()._colors.hotBackground);
-			setClrFromIni(sectionColors, L"backgroundDlg", iniPath, &DarkMode::getTheme()._colors.dlgBackground);
-			setClrFromIni(sectionColors, L"backgroundError", iniPath, &DarkMode::getTheme()._colors.errorBackground);
+			SetClrFromIni(sectionColors, L"background", iniPath, &DarkMode::getTheme()._colors.background);
+			SetClrFromIni(sectionColors, L"backgroundCtrl", iniPath, &DarkMode::getTheme()._colors.ctrlBackground);
+			SetClrFromIni(sectionColors, L"backgroundHot", iniPath, &DarkMode::getTheme()._colors.hotBackground);
+			SetClrFromIni(sectionColors, L"backgroundDlg", iniPath, &DarkMode::getTheme()._colors.dlgBackground);
+			SetClrFromIni(sectionColors, L"backgroundError", iniPath, &DarkMode::getTheme()._colors.errorBackground);
 
-			setClrFromIni(sectionColors, L"text", iniPath, &DarkMode::getTheme()._colors.text);
-			setClrFromIni(sectionColors, L"textItem", iniPath, &DarkMode::getTheme()._colors.darkerText);
-			setClrFromIni(sectionColors, L"textDisabled", iniPath, &DarkMode::getTheme()._colors.disabledText);
-			setClrFromIni(sectionColors, L"textLink", iniPath, &DarkMode::getTheme()._colors.linkText);
+			SetClrFromIni(sectionColors, L"text", iniPath, &DarkMode::getTheme()._colors.text);
+			SetClrFromIni(sectionColors, L"textItem", iniPath, &DarkMode::getTheme()._colors.darkerText);
+			SetClrFromIni(sectionColors, L"textDisabled", iniPath, &DarkMode::getTheme()._colors.disabledText);
+			SetClrFromIni(sectionColors, L"textLink", iniPath, &DarkMode::getTheme()._colors.linkText);
 
-			setClrFromIni(sectionColors, L"edge", iniPath, &DarkMode::getTheme()._colors.edge);
-			setClrFromIni(sectionColors, L"edgeHot", iniPath, &DarkMode::getTheme()._colors.hotEdge);
-			setClrFromIni(sectionColors, L"edgeDisabled", iniPath, &DarkMode::getTheme()._colors.disabledEdge);
+			SetClrFromIni(sectionColors, L"edge", iniPath, &DarkMode::getTheme()._colors.edge);
+			SetClrFromIni(sectionColors, L"edgeHot", iniPath, &DarkMode::getTheme()._colors.hotEdge);
+			SetClrFromIni(sectionColors, L"edgeDisabled", iniPath, &DarkMode::getTheme()._colors.disabledEdge);
 
 			DarkMode::updateThemeBrushesAndPens();
 			DarkMode::updateViewBrushesAndPens();
+			DarkMode::calculateTreeViewStyle();
+
+			if (!g_dmCfg._micaExtend)
+			{
+				g_dmCfg._colorizeTitleBar = (::GetPrivateProfileIntW(sectionBase.c_str(), L"colorizeTitleBar", 0, iniPath.c_str()) == 1);
+			}
+
+			DarkMode::setDarkMode(g_dmCfg._dmType == DarkModeType::dark, true);
 		}
 		else
 		{
-			DarkMode::setDarkModeConfig();
-			if (g_dmCfg._dmType == DarkModeType::classic)
-			{
-				DarkMode::setViewBackgroundColor(::GetSysColor(COLOR_WINDOW));
-				DarkMode::setViewTextColor(::GetSysColor(COLOR_WINDOWTEXT));
-			}
+			DarkMode::setDarkModeConfig(static_cast<UINT>(DarkModeType::dark));
+			DarkMode::setDefaultColors(true);
 		}
 	}
 #endif // !defined(_DARKMODELIB_NO_INI_CONFIG)
 
-	static void initExperimentalDarkMode()
-	{
-		::InitDarkMode();
-	}
-
-	static void setDarkMode(bool useDark, bool fixDarkScrollbar)
-	{
-		::SetDarkMode(useDark, fixDarkScrollbar);
-	}
-
-	static bool allowDarkModeForWindow(HWND hWnd, bool allow)
-	{
-		return ::AllowDarkModeForWindow(hWnd, allow);
-	}
-
-#if defined(_DARKMODELIB_ALLOW_OLD_OS)
-	static void setTitleBarThemeColor(HWND hWnd)
-	{
-		::RefreshTitleBarThemeColor(hWnd);
-	}
-#endif
-
-	[[nodiscard]] static bool isColorSchemeChangeMessage(LPARAM lParam)
-	{
-		return ::IsColorSchemeChangeMessage(lParam);
-	}
-
-	static bool isHighContrast()
-	{
-		return ::IsHighContrast();
-	}
-
+	/**
+	 * @brief Applies dark mode settings based on the given configuration type.
+	 *
+	 * Initializes the dark mode type settings and system-following behavior.
+	 * Enables or disables dark mode depending on whether `DarkModeType::dark` is selected.
+	 * It is recommended to use together with @ref DarkMode::setDefaultColors to also set colors.
+	 *
+	 * @param dmType Dark mode configuration type; see @ref DarkMode::initDarkModeConfig for values.
+	 *
+	 * @see DarkMode::initDarkModeConfig()
+	 * @see DarkMode::setDefaultColors()
+	 */
 	void setDarkModeConfig(UINT dmType)
 	{
 		DarkMode::initDarkModeConfig(dmType);
-		DarkMode::setDarkMode(g_dmCfg._dmType == DarkModeType::dark, true);
-	}
 
+		const bool useDark = g_dmCfg._dmType == DarkModeType::dark;
+		DarkMode::setDarkMode(useDark, true);
+	}
+
+	/**
+	 * @brief Applies dark mode settings based on system mode preference.
+	 *
+	 * Determines the appropriate mode using @ref DarkMode::isDarkModeReg and forwards
+	 * the result to @ref DarkMode::setDarkModeConfig.
+	 * It is recommended to use together with @ref DarkMode::setDefaultColors to also set colors.
+	 *
+	 * Uses:
+	 * - `DarkModeType::dark` if registry prefers dark mode.
+	 * - `DarkModeType::classic` otherwise.
+	 *
+	 * @see DarkMode::setDefaultColors()
+	 */
 	void setDarkModeConfig()
 	{
 		const auto dmType = static_cast<UINT>(DarkMode::isDarkModeReg() ? DarkModeType::dark : DarkModeType::classic);
 		DarkMode::setDarkModeConfig(dmType);
 	}
 
+	/**
+	 * @brief Initializes dark mode experimental features, colors, and other settings.
+	 *
+	 * Performs one-time setup for dark mode, including:
+	 * - Initializing experimental features if not yet done.
+	 * - Optionally loading settings from an INI file (if INI config is enabled).
+	 * - Initializing TreeView style and applying dark mode settings.
+	 * - Preparing system colors (e.g. `COLOR_WINDOW`, `COLOR_WINDOWTEXT`, `COLOR_BTNFACE`)
+	 *   for hooking.
+	 *
+	 * @param iniName Optional path to an INI file for dark mode settings (ignored if already set).
+	 *
+	 * @note This function is only run once per session;
+	 *       subsequent calls have no effect, unless follow system mode is used,
+	 *       then only colors are updated each time system changes mode.
+	 *
+	 * @see DarkMode::calculateTreeViewStyle()
+	 */
 	void initDarkMode([[maybe_unused]] const wchar_t* iniName)
 	{
 		if (!g_dmCfg._isInit)
@@ -1123,32 +1526,24 @@ namespace DarkMode
 				g_dmCfg._isInitExperimental = true;
 			}
 
-			const bool useDark = g_dmCfg._dmType == DarkModeType::dark;
-			if (useDark)
-			{
-				DarkMode::getTheme()._colors = DarkMode::darkColors;
-				DarkMode::getThemeView()._clrView = DarkMode::darkColorsView;
-			}
-			else
-			{
-				DarkMode::getTheme()._colors = DarkMode::getLightColors();
-				DarkMode::getThemeView()._clrView = DarkMode::lightColorsView;
-			}
-
 #if !defined(_DARKMODELIB_NO_INI_CONFIG)
 			if (!g_dmCfg._isIniNameSet)
 			{
 				g_dmCfg._iniName = iniName;
 				g_dmCfg._isIniNameSet = true;
+
+				if (g_dmCfg._iniName.empty())
+				{
+					DarkMode::setDarkModeConfig(static_cast<UINT>(DarkModeType::dark));
+					DarkMode::setDefaultColors(true);
+				}
 			}
 			DarkMode::initOptions(g_dmCfg._iniName);
 #else
 			DarkMode::setDarkModeConfig();
+			DarkMode::setDefaultColors(true);
 #endif
 
-			DarkMode::calculateTreeViewStyle();
-			DarkMode::setDarkMode(g_dmCfg._dmType == DarkModeType::dark, true);
-
 			DarkMode::setSysColor(COLOR_WINDOW, DarkMode::getBackgroundColor());
 			DarkMode::setSysColor(COLOR_WINDOWTEXT, DarkMode::getTextColor());
 			DarkMode::setSysColor(COLOR_BTNFACE, DarkMode::getViewGridlinesColor());
@@ -1157,50 +1552,108 @@ namespace DarkMode
 		}
 	}
 
+	/**
+	 * @brief Initializes dark mode without INI settings.
+	 *
+	 * Forwards to @ref DarkMode::initDarkMode with an empty INI path, effectively disabling INI settings.
+	 */
 	void initDarkMode()
 	{
 		DarkMode::initDarkMode(L"");
 	}
 
+	/**
+	 * @brief Checks if non-classic mode is enabled.
+	 *
+	 * If `_DARKMODELIB_ALLOW_OLD_OS` is defined, this skips Windows version checks.
+	 * Otherwise, dark mode is only enabled on Windows 10 or newer.
+	 *
+	 * @return `true` if a supported dark mode type is active, otherwise `false`.
+	 */
 	bool isEnabled()
 	{
 #if defined(_DARKMODELIB_ALLOW_OLD_OS)
 		return g_dmCfg._dmType != DarkModeType::classic;
 #else
-		return DarkMode::isWindows10() && g_dmCfg._dmType != DarkModeType::classic;
+		return DarkMode::isAtLeastWindows10() && g_dmCfg._dmType != DarkModeType::classic;
 #endif
 	}
 
+	/**
+	 * @brief Checks if experimental dark mode features are currently active.
+	 *
+	 * @return `true` if experimental dark mode is enabled.
+	 */
 	bool isExperimentalActive()
 	{
 		return g_darkModeEnabled;
 	}
 
+	/**
+	 * @brief Checks if experimental dark mode features are supported by the system.
+	 *
+	 * @return `true` if dark mode experimental APIs are available.
+	 */
 	bool isExperimentalSupported()
 	{
 		return g_darkModeSupported;
 	}
 
+	/**
+	 * @brief Checks if follow the system mode behavior is enabled.
+	 *
+	 * @return `true` if "mode" is not `WinMode::disabled`, i.e. system mode is followed.
+	 */
 	bool isWindowsModeEnabled()
 	{
 		return g_dmCfg._windowsMode != WinMode::disabled;
 	}
 
-	bool isWindows10()
+	/**
+	 * @brief Checks if the host OS is at least Windows 10.
+	 *
+	 * @return `true` if running on Windows 10 or newer.
+	 */
+	bool isAtLeastWindows10()
 	{
 		return ::IsWindows10();
 	}
-
-	bool isWindows11()
+	/**
+	 * @brief Checks if the host OS is at least Windows 11.
+	 *
+	 * @return `true` if running on Windows 11 or newer.
+	 */
+	bool isAtLeastWindows11()
 	{
 		return ::IsWindows11();
 	}
 
+	/**
+	 * @brief Retrieves the current Windows build number.
+	 *
+	 * @return Windows build number reported by the system.
+	 */
 	DWORD getWindowsBuildNumber()
 	{
 		return GetWindowsBuildNumber();
 	}
 
+	/**
+	 * @brief Handles system setting changes related to dark mode.
+	 *
+	 * Responds to system messages indicating a color scheme change. If the current
+	 * dark mode state no longer matches the system registry preference, dark mode is
+	 * re-initialized.
+	 *
+	 * - Skips processing if experimental dark mode is unsupported.
+	 * - Relies on @ref DarkMode::isDarkModeReg for theme preference and skips during high contrast.
+	 *
+	 * @param lParam Message parameter (typically from `WM_SETTINGCHANGE`).
+	 * @return `true` if a dark mode change was handled; otherwise `false`.
+	 *
+	 * @see DarkMode::isDarkModeReg()
+	 * @see DarkMode::initDarkMode()
+	 */
 	bool handleSettingChange(LPARAM lParam)
 	{
 		if (DarkMode::isExperimentalSupported() && DarkMode::isColorSchemeChangeMessage(lParam))
@@ -1220,6 +1673,13 @@ namespace DarkMode
 		return false;
 	}
 
+	/**
+	 * @brief Checks if dark mode is enabled in the Windows registry.
+	 *
+	 * Queries `HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize\\AppsUseLightTheme`.
+	 *
+	 * @return `true` if dark mode is preferred (value is `0`); otherwise `false`.
+	 */
 	bool isDarkModeReg()
 	{
 		DWORD data{};
@@ -1239,25 +1699,69 @@ namespace DarkMode
 
 	// from DarkMode.h
 
+	/**
+	 * @brief Overrides a specific system color with a custom color.
+	 *
+	 * Currently supports:
+	 * - `COLOR_WINDOW`: Background of ComboBoxEx list.
+	 * - `COLOR_WINDOWTEXT`: Text color of ComboBoxEx list.
+	 * - `COLOR_BTNFACE`: Gridline color in ListView (when applicable).
+	 *
+	 * @param nIndex One of the supported system color indices.
+	 * @param color Custom `COLORREF` value to apply.
+	 */
 	void setSysColor(int nIndex, COLORREF color)
 	{
 		::SetMySysColor(nIndex, color);
 	}
 
-	bool hookSysColor()
+	/**
+	 * @brief Hooks system color to support runtime customization.
+	 *
+	 * @return `true` if the hook was installed successfully.
+	 */
+	static bool hookSysColor()
 	{
 		return ::HookSysColor();
 	}
-	void unhookSysColor()
+
+	/**
+	 * @brief Unhooks system color overrides and restores default color behavior.
+	 *
+	 * This function is safe to call even if no color hook is currently installed.
+	 * It ensures that system colors return to normal without requiring
+	 * prior state checks.
+	 */
+	static void unhookSysColor()
 	{
 		::UnhookSysColor();
 	}
 
+	/**
+	 * @brief Makes scroll bars on the specified window and all its children consistent.
+	 *
+	 * Currently not widely used by default.
+	 *
+	 * @param hWnd Handle to the parent window.
+	 */
 	void enableDarkScrollBarForWindowAndChildren(HWND hWnd)
 	{
 		::EnableDarkScrollBarForWindowAndChildren(hWnd);
 	}
 
+	/**
+	 * @brief Paints a rounded rectangle using the specified pen and brush.
+	 *
+	 * Draws a rounded rectangle defined by `rect`, using the provided pen (`hpen`) and brush (`hBrush`)
+	 * for the edge and fill, respectively. Preserves previous GDI object selections.
+	 *
+	 * @param hdc Handle to the device context.
+	 * @param rect Rectangle bounds for the shape.
+	 * @param hpen Pen used to draw the edge.
+	 * @param hBrush Brush used to inner fill.
+	 * @param width Horizontal corner radius.
+	 * @param height Vertical corner radius.
+	 */
 	void paintRoundRect(HDC hdc, const RECT& rect, HPEN hpen, HBRUSH hBrush, int width, int height)
 	{
 		auto holdBrush = ::SelectObject(hdc, hBrush);
@@ -1267,11 +1771,36 @@ namespace DarkMode
 		::SelectObject(hdc, holdPen);
 	}
 
+	/**
+	 * @brief Paints an unfilled rounded rectangle (frame only).
+	 *
+	 * Uses a `NULL_BRUSH` to omit the inner fill, drawing only the rounded frame.
+	 *
+	 * @param hdc Handle to the device context.
+	 * @param rect Rectangle bounds for the frame.
+	 * @param hpen Pen used to draw the edge.
+	 * @param width Horizontal corner radius.
+	 * @param height Vertical corner radius.
+	 */
 	void paintRoundFrameRect(HDC hdc, const RECT& rect, HPEN hpen, int width, int height)
 	{
 		DarkMode::paintRoundRect(hdc, rect, hpen, static_cast<HBRUSH>(::GetStockObject(NULL_BRUSH)), width, height);
 	}
 
+	/**
+	 * @class ThemeData
+	 * @brief RAII-style wrapper for `HTHEME` handle tied to a specific theme class.
+	 *
+	 * Prevents leaks by managing the lifecycle of a theme handle opened via `OpenThemeData()`.
+	 * Ensures handles are released properly in the destructor via `CloseThemeData()`.
+	 *
+	 * Usage:
+	 * - Construct with a valid theme class name (e.g. `L"Button"`).
+	 * - Call `ensureTheme(HWND)` before drawing to open the theme handle.
+	 * - Access the active handle via `getHTheme()`.
+	 *
+	 * Copying and moving are explicitly disabled to preserve exclusive ownership.
+	 */
 	class ThemeData
 	{
 	public:
@@ -1320,6 +1849,22 @@ namespace DarkMode
 		HTHEME _hTheme = nullptr;
 	};
 
+	/**
+	 * @class BufferData
+	 * @brief RAII-style utility for double buffer technique.
+	 *
+	 * Allocates and resizes an offscreen buffer for flicker-free GDI drawing. When
+	 * `ensureBuffer()` is called with a target HDC and client rect, it creates or resizes
+	 * a memory device context and bitmap accordingly. Automatically releases resources
+	 * via `releaseBuffer()` and destructor.
+	 *
+	 * Usage:
+	 * - Call `ensureBuffer()` before painting.
+	 * - Draw to `getHMemDC()`.
+	 * - BitBlt back to screen in WM_PAINT.
+	 *
+	 * Copying and moving are explicitly disabled to preserve exclusive ownership.
+	 */
 	class BufferData
 	{
 	public:
@@ -1380,6 +1925,20 @@ namespace DarkMode
 		SIZE _szBuffer{};
 	};
 
+	/**
+	 * @class FontData
+	 * @brief RAII-style wrapper for managing a GDI font (`HFONT`) resource.
+	 *
+	 * Ensures safe creation, assignment, and destruction of fonts in GDI-based UI code.
+	 * Automatically deletes the font in the destructor or when replaced via `setFont()`.
+	 *
+	 * Usage:
+	 * - Use `setFont()` to assign a new font, deleting any previous one.
+	 * - `getFont()` provides access to the current `HFONT`.
+	 * - `hasFont()` checks if a valid font is currently held.
+	 *
+	 * Copying and moving are explicitly disabled to preserve exclusive ownership.
+	 */
 	class FontData
 	{
 	public:
@@ -1429,6 +1988,20 @@ namespace DarkMode
 		HFONT _hFont = nullptr;
 	};
 
+	/**
+	 * @brief Attaches a typed subclass procedure with custom data to a window.
+	 *
+	 * If the subclass ID is not already attached, allocates a `T` instance using the given
+	 * `param` and stores it as subclass reference data. Ownership is transferred to the system.
+	 *
+	 * @tparam T The user-defined data type associated with the subclass.
+	 * @tparam Param Type used to initialize `T`.
+	 * @param hWnd Target window.
+	 * @param subclassProc Subclass procedure.
+	 * @param subclassID Identifier for the subclass instance.
+	 * @param param Constructor argument forwarded to `T`.
+	 * @return TRUE on success, FALSE on failure, -1 if subclass already set.
+	 */
 	template <typename T, typename Param>
 	static auto setSubclass(HWND hWnd, SUBCLASSPROC subclassProc, UINT_PTR subclassID, const Param& param) -> int
 	{
@@ -1445,6 +2018,17 @@ namespace DarkMode
 		return -1;
 	}
 
+	/**
+	 * @brief Attaches a typed subclass procedure with default-constructed data.
+	 *
+	 * Same logic as the other overload, but constructs `T` using its default constructor.
+	 *
+	 * @tparam T The user-defined data type associated with the subclass.
+	 * @param hWnd Target window.
+	 * @param subclassProc Subclass procedure.
+	 * @param subclassID Identifier for the subclass instance.
+	 * @return TRUE on success, FALSE on failure, -1 if already subclassed.
+	 */
 	template <typename T>
 	static auto setSubclass(HWND hWnd, SUBCLASSPROC subclassProc, UINT_PTR subclassID) -> int
 	{
@@ -1461,6 +2045,16 @@ namespace DarkMode
 		return -1;
 	}
 
+	/**
+	 * @brief Attaches an untyped subclass (no reference data).
+	 *
+	 * Sets a subclass with no associated custom data.
+	 *
+	 * @param hWnd Target window.
+	 * @param subclassProc Subclass procedure.
+	 * @param subclassID Identifier for the subclass instance.
+	 * @return TRUE on success, FALSE on failure, -1 if already subclassed.
+	 */
 	static int setSubclass(HWND hWnd, SUBCLASSPROC subclassProc, UINT_PTR subclassID)
 	{
 		if (::GetWindowSubclass(hWnd, subclassProc, subclassID, nullptr) == FALSE)
@@ -1470,6 +2064,18 @@ namespace DarkMode
 		return -1;
 	}
 
+	/**
+	 * @brief Removes a subclass and deletes associated user data (if provided).
+	 *
+	 * Retrieves and deletes user-defined `T` data stored in subclass reference
+	 * (unless `T = void`, in which case no delete is performed). Then removes the subclass.
+	 *
+	 * @tparam T Optional type of reference data to delete.
+	 * @param hWnd Window handle.
+	 * @param subclassProc Subclass procedure.
+	 * @param subclassID Identifier for the subclass instance.
+	 * @return TRUE on success, FALSE on failure, -1 if not present.
+	 */
 	template <typename T = void>
 	static auto removeSubclass(HWND hWnd, SUBCLASSPROC subclassProc, UINT_PTR subclassID) -> int
 	{
@@ -1490,6 +2096,25 @@ namespace DarkMode
 		return -1;
 	}
 
+	/**
+	 * @struct ButtonData
+	 * @brief Stores button theming state and original size metadata.
+	 *
+	 * Used for checkbox, radio, tri-state, or group box buttons. Used in conjunction
+	 * with subclassing of button controls to preserve original layout dimensions
+	 * and apply consistent visual styling. Captures the control's client size
+	 * for checkbox, radio, or tri-state buttons.
+	 *
+	 * Members:
+	 * - `_themeData` : RAII-managed theme handle for `VSCLASS_BUTTON`.
+	 * - `_szBtn` : Original size extracted from the button rectangle.
+	 * - `_iStateID` : Current visual state ID (e.g. pressed, disabled, ...).
+	 * - `_isSizeSet` : Indicates whether `_szBtn` holds a valid measurement.
+	 *
+	 * Constructor behavior:
+	 * - When constructed with an `HWND`, attempts to extract the initial size if the button
+	 *   is a checkbox/radio/tri-state type without `BS_MULTILINE`.
+	 */
 	struct ButtonData
 	{
 		ThemeData _themeData{ VSCLASS_BUTTON };
@@ -1501,6 +2126,7 @@ namespace DarkMode
 		ButtonData() = default;
 
 		// Saves width and height from the resource file for use as restrictions.
+		// Currently unused / have no effect.
 		explicit ButtonData(HWND hWnd)
 		{
 			const auto nBtnStyle = ::GetWindowLongPtr(hWnd, GWL_STYLE);
@@ -1532,8 +2158,30 @@ namespace DarkMode
 		}
 	};
 
+	/**
+	 * @brief Draws a themed owner drawn checkbox, radio, or tri-state button (excluding push-like buttons).
+	 *
+	 * Internally used by @ref DarkMode::paintButton to draw visual elements such as checkbox glyphs
+	 * or radio indicators alongside styled text. Not used for buttons with `BS_PUSHLIKE`,
+	 * which require different handling and theming logic.
+	 *
+	 * - Retrieves themed or fallback font for consistent appearance.
+	 * - Handles alignment, word wrapping, and prefix visibility per style flags.
+	 * - Draws themed background and glyph using `DrawThemeBackground`.
+	 * - Uses dark mode-aware text rendering and applies focus cue when needed.
+	 *
+	 * @param hWnd Handle to the button control.
+	 * @param hdc Device context for drawing.
+	 * @param hTheme Active visual style theme handle.
+	 * @param iPartID Part ID (`BP_CHECKBOX`, `BP_RADIOBUTTON`, etc.).
+	 * @param iStateID State ID (`CBS_CHECKEDHOT`, `RBS_UNCHECKEDNORMAL`, etc.).
+	 *
+	 * @see DarkMode::paintButton()
+	 */
 	static void renderButton(HWND hWnd, HDC hdc, HTHEME hTheme, int iPartID, int iStateID)
 	{
+		// Font part
+
 		HFONT hFont = nullptr;
 		bool isFontCreated = false;
 		LOGFONT lf{};
@@ -1550,6 +2198,8 @@ namespace DarkMode
 
 		auto holdFont = static_cast<HFONT>(::SelectObject(hdc, hFont));
 
+		// Style part
+
 		const auto nStyle = ::GetWindowLongPtr(hWnd, GWL_STYLE);
 		const bool isMultiline = (nStyle & BS_MULTILINE) == BS_MULTILINE;
 		const bool isTop = (nStyle & BS_TOP) == BS_TOP;
@@ -1558,7 +2208,7 @@ namespace DarkMode
 		const bool isRight = (nStyle & BS_RIGHT) == BS_RIGHT;
 		const bool isVCenter = (nStyle & BS_VCENTER) == BS_VCENTER;
 
-		DWORD dtFlags = DT_LEFT; // DT_LEFT is 0
+		DWORD dtFlags = DT_LEFT;
 		if (isMultiline)
 		{
 			dtFlags |= DT_WORDBREAK;
@@ -1593,6 +2243,7 @@ namespace DarkMode
 			dtFlags |= DT_HIDEPREFIX;
 		}
 
+		// Text and box part
 
 		RECT rcClient{};
 		::GetClientRect(hWnd, &rcClient);
@@ -1618,7 +2269,7 @@ namespace DarkMode
 		rcText.left = rcBackground.right + 3;
 
 		::DrawThemeParentBackground(hWnd, hdc, &rcClient);
-		::DrawThemeBackground(hTheme, hdc, iPartID, iStateID, &rcBackground, nullptr);
+		::DrawThemeBackground(hTheme, hdc, iPartID, iStateID, &rcBackground, nullptr); // draw box
 
 		DTTOPTS dtto{};
 		dtto.dwSize = sizeof(DTTOPTS);
@@ -1627,6 +2278,8 @@ namespace DarkMode
 
 		::DrawThemeTextEx(hTheme, hdc, iPartID, iStateID, buffer.c_str(), -1, dtFlags, &rcText, &dtto);
 
+		// Focus rect
+
 		const auto nState = static_cast<DWORD>(::SendMessage(hWnd, BM_GETSTATE, 0, 0));
 		if (((nState & BST_FOCUS) == BST_FOCUS) && ((uiState & UISF_HIDEFOCUS) != UISF_HIDEFOCUS))
 		{
@@ -1636,6 +2289,8 @@ namespace DarkMode
 			::DrawFocusRect(hdc, &rcFocus);
 		}
 
+		// Cleanup
+
 		::SelectObject(hdc, holdFont);
 		if (isFontCreated)
 		{
@@ -1643,6 +2298,24 @@ namespace DarkMode
 		}
 	}
 
+	/**
+	 * @brief Paints a checkbox, radio, or tri-state button with state-based visuals.
+	 *
+	 * Determines the appropriate themed part and state ID based on the control’s
+	 * style (e.g. `BS_CHECKBOX`, `BS_RADIOBUTTON`) and current button state flags
+	 * such as `BST_CHECKED`, `BST_PUSHED`, or `BST_HOT`.
+	 *
+	 * - Uses buffered animation (if available) to smoothly transition between states.
+	 * - Falls back to direct drawing via @ref DarkMode::renderButton if animation is not used.
+	 * - Internally updates the `buttonData._iStateID` to preserve the last rendered state.
+	 * - Not used for `BS_PUSHLIKE` buttons.
+	 *
+	 * @param hWnd Handle to the checkbox or radio button control.
+	 * @param hdc Device context used for rendering.
+	 * @param buttonData Theming and state info, including current theme and last state.
+	 *
+	 * @see DarkMode::renderButton()
+	 */
 	static void paintButton(HWND hWnd, HDC hdc, ButtonData& buttonData)
 	{
 		const auto& hTheme = buttonData._themeData.getHTheme();
@@ -1654,6 +2327,7 @@ namespace DarkMode
 		int iPartID = 0;
 		int iStateID = 0;
 
+		// Get style
 		switch (nBtnStyle)
 		{
 			case BS_CHECKBOX:
@@ -1695,7 +2369,6 @@ namespace DarkMode
 			{
 				iPartID = BP_CHECKBOX;
 				iStateID = CBS_UNCHECKEDDISABLED;
-				// assert(false);
 				break;
 			}
 		}
@@ -1705,6 +2378,8 @@ namespace DarkMode
 			return;
 		}
 
+		// Animation part - hover transition
+
 		BP_ANIMATIONPARAMS animParams{};
 		animParams.cbSize = sizeof(BP_ANIMATIONPARAMS);
 		animParams.style = BPAS_LINEAR;
@@ -1742,6 +2417,20 @@ namespace DarkMode
 		}
 	}
 
+	/**
+	 * @brief Window subclass procedure for themed owner drawn checkbox, radio, and tri-state buttons.
+	 *
+	 * @param hWnd Window handle being subclassed.
+	 * @param uMsg Message identifier.
+	 * @param wParam Message-specific data.
+	 * @param lParam Message-specific data.
+	 * @param uIdSubclass Subclass identifier.
+	 * @param dwRefData ButtonData instance.
+	 * @return LRESULT Result of message processing.
+	 *
+	 * @see DarkMode::setCheckboxOrRadioBtnCtrlSubclass()
+	 * @see DarkMode::removeCheckboxOrRadioBtnCtrlSubclass()
+	 */
 	static LRESULT CALLBACK ButtonSubclass(
 		HWND hWnd,
 		UINT uMsg,
@@ -1824,7 +2513,7 @@ namespace DarkMode
 					break;
 				}
 
-				// skip the button's normal wndproc so it won't redraw out of wm_paint
+				// Skip the button's normal wndproc so it won't redraw out of wm_paint
 				const LRESULT retVal = ::DefWindowProc(hWnd, uMsg, wParam, lParam);
 				::InvalidateRect(hWnd, nullptr, FALSE);
 				return retVal;
@@ -1847,24 +2536,71 @@ namespace DarkMode
 		return ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
 	}
 
+	/**
+	 * @brief Applies themed owner drawn subclassing to a checkbox, radio, or tri-state button control.
+	 *
+	 * Associates a `ButtonData` instance with the control.
+	 *
+	 * @param hWnd Handle to the checkbox, radio, or tri-state button control.
+	 *
+	 * @see DarkMode::ButtonSubclass()
+	 * @see DarkMode::removeCheckboxOrRadioBtnCtrlSubclass()
+	 */
 	void setCheckboxOrRadioBtnCtrlSubclass(HWND hWnd)
 	{
-		DarkMode::setSubclass<ButtonData>(hWnd, ButtonSubclass, kButtonSubclassID);
+		DarkMode::setSubclass<ButtonData>(hWnd, ButtonSubclass, kButtonSubclassID, hWnd);
 	}
 
+	/**
+	 * @brief Removes the owner drawn subclass from a checkbox, radio, or tri-state button control.
+	 *
+	 * Cleans up the `ButtonData` instance and detaches the control's subclass proc.
+	 *
+	 * @param hWnd Handle to the control previously subclassed.
+	 *
+	 * @see DarkMode::ButtonSubclass()
+	 * @see DarkMode::setCheckboxOrRadioBtnCtrlSubclass()
+	 */
 	void removeCheckboxOrRadioBtnCtrlSubclass(HWND hWnd)
 	{
 		DarkMode::removeSubclass<ButtonData>(hWnd, ButtonSubclass, kButtonSubclassID);
 	}
 
+	/**
+	 * @brief Paints a group box frame and text with custom colors.
+	 *
+	 * Handles drawing a themed group box with optional centered text, styled borders,
+	 * and font fallback. If a caption text is present, the frame is clipped to avoid overdrawing
+	 * behind the text. The function adapts layout for both centered and left-aligned titles.
+	 *
+	 * Rendering steps:
+	 * - Determines current visual state (`GBS_DISABLED`, `GBS_NORMAL`).
+	 * - Retrieves themed font via `GetThemeFont` or falls back to dialog font.
+	 * - Measures caption text, computes layout and exclusion for frame clipping.
+	 * - Paints the outer rounded frame via @ref DarkMode::paintRoundFrameRect
+	 *   using `DarkMode::getEdgePen()`.
+	 * - Restores clip region and renders text using `DrawThemeTextEx` with custom colors.
+	 *
+	 * @param hWnd Handle to the group box control.
+	 * @param hdc Device context used for painting.
+	 * @param buttonData Reference to the theming and state info (theme handle).
+	 *
+	 * @note Ensures proper cleanup of temporary GDI objects (font, clip region).
+	 *
+	 * @see DarkMode::paintRoundFrameRect()
+	 */
 	static void paintGroupbox(HWND hWnd, HDC hdc, const ButtonData& buttonData)
 	{
 		const auto& hTheme = buttonData._themeData.getHTheme();
 
+		// Style part
+
 		const bool isDisabled = ::IsWindowEnabled(hWnd) == FALSE;
 		static constexpr int iPartID = BP_GROUPBOX;
 		const int iStateID = isDisabled ? GBS_DISABLED : GBS_NORMAL;
 
+		// Font part
+
 		bool isFontCreated = false;
 		HFONT hFont = nullptr;
 		LOGFONT lf{};
@@ -1882,6 +2618,8 @@ namespace DarkMode
 
 		auto holdFont = static_cast<HFONT>(::SelectObject(hdc, hFont));
 
+		// Text rectangle part
+
 		std::wstring buffer;
 		const auto bufferLen = static_cast<size_t>(::GetWindowTextLength(hWnd));
 		if (bufferLen > 0)
@@ -1914,7 +2652,7 @@ namespace DarkMode
 
 			::ExcludeClipRect(hdc, rcText.left, rcText.top, rcText.right, rcText.bottom);
 		}
-		else
+		else // There is no text, use "M" to get metrics to move top edge down
 		{
 			SIZE szText{};
 			::GetTextExtentPoint32(hdc, L"M", 1, &szText);
@@ -1925,12 +2663,12 @@ namespace DarkMode
 		::GetThemeBackgroundContentRect(hTheme, hdc, BP_GROUPBOX, iStateID, &rcBackground, &rcContent);
 		::ExcludeClipRect(hdc, rcContent.left, rcContent.top, rcContent.right, rcContent.bottom);
 
-		//DrawThemeParentBackground(hWnd, hdc, &rcClient);
-		//DrawThemeBackground(hTheme, hdc, BP_GROUPBOX, iStateID, &rcBackground, nullptr);
-		DarkMode::paintRoundFrameRect(hdc, rcBackground, DarkMode::getEdgePen());
+		DarkMode::paintRoundFrameRect(hdc, rcBackground, DarkMode::getEdgePen()); // main frame
 
 		::SelectClipRgn(hdc, nullptr);
 
+		// Text part
+
 		if (!buffer.empty())
 		{
 			::InflateRect(&rcText, -2, 0);
@@ -1957,6 +2695,20 @@ namespace DarkMode
 		}
 	}
 
+	/**
+	 * @brief Window subclass procedure for owner drawn groupbox button control.
+	 *
+	 * @param hWnd Window handle being subclassed.
+	 * @param uMsg Message identifier.
+	 * @param wParam Message-specific data.
+	 * @param lParam Message-specific data.
+	 * @param uIdSubclass Subclass identifier.
+	 * @param dwRefData ButtonData instance.
+	 * @return LRESULT Result of message processing.
+	 *
+	 * @see DarkMode::setGroupboxCtrlSubclass()
+	 * @see DarkMode::removeGroupboxCtrlSubclass()
+	 */
 	static LRESULT CALLBACK GroupboxSubclass(
 		HWND hWnd,
 		UINT uMsg,
@@ -2039,16 +2791,55 @@ namespace DarkMode
 		return ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
 	}
 
+	/**
+	 * @brief Applies owner drawn subclassing to a groupbox button control.
+	 *
+	 * Associates a `ButtonData` instance with the control.
+	 *
+	 * @param hWnd Handle to the groupbox button control.
+	 *
+	 * @see DarkMode::GroupboxSubclass()
+	 * @see DarkMode::removeGroupboxCtrlSubclass()
+	 */
 	void setGroupboxCtrlSubclass(HWND hWnd)
 	{
 		DarkMode::setSubclass<ButtonData>(hWnd, GroupboxSubclass, kGroupboxSubclassID);
 	}
 
+	/**
+	 * @brief Removes the owner drawn subclass from a groupbox button control.
+	 *
+	 * Cleans up the `ButtonData` instance and detaches the control's subclass proc.
+	 *
+	 * @param hWnd Handle to the control previously subclassed.
+	 *
+	 * @see DarkMode::GroupboxSubclass()
+	 * @see DarkMode::setGroupboxCtrlSubclass()
+	 */
 	void removeGroupboxCtrlSubclass(HWND hWnd)
 	{
 		DarkMode::removeSubclass<ButtonData>(hWnd, GroupboxSubclass, kGroupboxSubclassID);
 	}
 
+	/**
+	 * @brief Applies theming and/or subclassing to a button control based on its style.
+	 *
+	 * Inspects the control's style (`BS_*`) to determine its visual category and applies
+	 * apropriate theming and/or subclassing accordingly. Handles:
+	 * - Checkbox/radio/tri-state buttons: Applies theme (optional) and optional subclassing
+	 * - Group boxes: Applies subclassing for dark mode drawing
+	 * - Push buttons: Applies visual theming if requested
+	 *
+	 * The behavior varies depending on dark mode support, Windows version, and the flags
+	 * provided in @ref DarkModeParams.
+	 *
+	 * @param hWnd Handle to the target button control.
+	 * @param p Parameters defining theming and subclassing behavior.
+	 *
+	 * @see DarkModeParams
+	 * @see DarkMode::setCheckboxOrRadioBtnCtrlSubclass()
+	 * @see DarkMode::setGroupboxCtrlSubclass()
+	 */
 	static void setBtnCtrlSubclassAndTheme(HWND hWnd, DarkModeParams p)
 	{
 		const auto nBtnStyle = ::GetWindowLongPtr(hWnd, GWL_STYLE);
@@ -2070,7 +2861,7 @@ namespace DarkMode
 					break;
 				}
 
-				if (DarkMode::isWindows11() && p._theme)
+				if (DarkMode::isAtLeastWindows11() && p._theme)
 				{
 					::SetWindowTheme(hWnd, p._themeClassName, nullptr);
 				}
@@ -2110,6 +2901,30 @@ namespace DarkMode
 		}
 	}
 
+	/**
+	 * @struct UpDownData
+	 * @brief Stores layout and rendering state for a owner drawn updown (spinner) control.
+	 *
+	 * Used to manage rectangle, buffer, and hit-test regions for owner-drawn subclassed
+	 * up-down controls, supporting both vertical and horizontal layouts.
+	 *
+	 * Key members:
+	 * - `_bufferData`: Offscreen back buffer for flicker-free rendering.
+	 * - `_rcClient`: Current client rectangle of the control.
+	 * - `_rcPrev`, `_rcNext`: Rectangles for the up/down or left/right arrow buttons.
+	 * - `_cornerRoundness`: Optional roundness for corners (used in Windows 11+ with tabs).
+	 * - `_isHorizontal`: `true` if the control is horizontal (`UDS_HORZ` style).
+	 * - `_wasHotNext`: Last hover state (used for hover feedback/rendering).
+	 *
+	 * Construction:
+	 * - Detects orientation from `GWL_STYLE`.
+	 * - Initializes corner styling based on OS and parent class.
+	 * - Extracts rectangles for arrow segments immediately.
+	 *
+	 * Usage:
+	 * - `updateRect(HWND)`: Refreshes rectangle from control handle.
+	 * - `updateRect(RECT)`: Checks for rectangle change and updates it.
+	 */
 	struct UpDownData
 	{
 		BufferData _bufferData;
@@ -2124,7 +2939,7 @@ namespace DarkMode
 		UpDownData() = delete;
 
 		explicit UpDownData(HWND hWnd)
-			: _cornerRoundness((DarkMode::isWindows11() && cmpWndClassName(::GetParent(hWnd), WC_TABCONTROL)) ? (kWin11CornerRoundness + 1) : 0)
+			: _cornerRoundness((DarkMode::isAtLeastWindows11() && CmpWndClassName(::GetParent(hWnd), WC_TABCONTROL)) ? (kWin11CornerRoundness + 1) : 0)
 			, _isHorizontal((::GetWindowLongPtr(hWnd, GWL_STYLE) & UDS_HORZ) == UDS_HORZ)
 		{
 			updateRect(hWnd);
@@ -2184,6 +2999,28 @@ namespace DarkMode
 		}
 	};
 
+	/**
+	 * @brief Custom paints a updown (spinner) control.
+	 *
+	 * Renders the two-button control using custom color brushes, pen styles, and directional
+	 * arrows. Adapts to both vertical and horizontal orientation based on @ref UpDownData.
+	 * Applies hover highlighting and draws appropriate glyphs (`<`/`>` or `˄`/`˅`) using
+	 * the control's font.
+	 *
+	 * Paint logic includes:
+	 * - Background fill with dialog background brush
+	 * - Rounded corners (optional, based on Windows 11 and parent class)
+	 * - Direction-aware layout and glyph placement
+	 *
+	 * @param hWnd Handle to the updown control being painted.
+	 * @param hdc Target device context.
+	 * @param upDownData Reference to layout and state information (segments, orientation, corner radius).
+	 *
+	 * @note Assumes the DC has already been prepared for painting. Uses `WM_GETFONT` to
+	 *       match the host UI font.
+	 *
+	 * @see UpDownData
+	 */
 	static void paintUpDown(HWND hWnd, HDC hdc, UpDownData& upDownData)
 	{
 		const bool isDisabled = ::IsWindowEnabled(hWnd) == FALSE;
@@ -2192,6 +3029,8 @@ namespace DarkMode
 		::FillRect(hdc, &upDownData._rcClient, DarkMode::getDlgBackgroundBrush());
 		::SetBkMode(hdc, TRANSPARENT);
 
+		// Button part
+
 		POINT ptCursor{};
 		::GetCursorPos(&ptCursor);
 		::ScreenToClient(hWnd, &ptCursor);
@@ -2226,6 +3065,8 @@ namespace DarkMode
 		paintUpDownBtn(upDownData._rcPrev, isHotPrev);
 		paintUpDownBtn(upDownData._rcNext, isHotNext);
 
+		// Glyph part
+
 		auto hFont = reinterpret_cast<HFONT>(::SendMessage(hWnd, WM_GETFONT, 0, 0));
 		auto holdFont = static_cast<HFONT>(::SelectObject(hdc, hFont));
 
@@ -2244,6 +3085,20 @@ namespace DarkMode
 		::SelectObject(hdc, holdFont);
 	}
 
+	/**
+	 * @brief Window subclass procedure for owner drawn updown (spinner) control.
+	 *
+	 * @param hWnd Window handle being subclassed.
+	 * @param uMsg Message identifier.
+	 * @param wParam Message-specific data.
+	 * @param lParam Message-specific data.
+	 * @param uIdSubclass Subclass identifier.
+	 * @param dwRefData UpDownData instance .
+	 * @return LRESULT Result of message processing.
+	 *
+	 * @see DarkMode::setUpDownCtrlSubclass()
+	 * @see DarkMode::removeUpDownCtrlSubclass()
+	 */
 	static LRESULT CALLBACK UpDownSubclass(
 		HWND hWnd,
 		UINT uMsg,
@@ -2381,17 +3236,49 @@ namespace DarkMode
 		return ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
 	}
 
+	/**
+	 * @brief Applies owner drawn subclassing and theming to an updown (spinner) control.
+	 *
+	 * Associates a `UpDownData` instance with the control.
+	 *
+	 * @param hWnd Handle to the updown (spinner) control.
+	 *
+	 * @see DarkMode::UpDownSubclass()
+	 * @see DarkMode::removeUpDownCtrlSubclass()
+	 */
 	void setUpDownCtrlSubclass(HWND hWnd)
 	{
 		DarkMode::setSubclass<UpDownData>(hWnd, UpDownSubclass, kUpDownSubclassID, hWnd);
 		DarkMode::setDarkExplorerTheme(hWnd);
 	}
 
+	/**
+	 * @brief Removes the owner drawn subclass from a updown (spinner) control.
+	 *
+	 * Cleans up the `UpDownData` instance and detaches the control's subclass proc.
+	 *
+	 * @param hWnd Handle to the control previously subclassed.
+	 *
+	 * @see DarkMode::UpDownSubclass()
+	 * @see DarkMode::setUpDownCtrlSubclass()
+	 */
 	void removeUpDownCtrlSubclass(HWND hWnd)
 	{
 		DarkMode::removeSubclass<UpDownData>(hWnd, UpDownSubclass, kUpDownSubclassID);
 	}
 
+	/**
+	 * @brief Applies updown (spinner) control theming and/or subclassing based on specified parameters.
+	 *
+	 * Conditionally applies custom subclassing and/or themed appearance depending on
+	 * `DarkModeParams`. Subclassing takes priority if both are requested.
+	 *
+	 * @param hWnd Handle to the up-down control.
+	 * @param p Parameters controlling whether to apply theming and/or subclassing.
+	 *
+	 * @see DarkModeParams
+	 * @see DarkMode::setUpDownCtrlSubclass()
+	 */
 	static void setUpDownCtrlSubclassAndTheme(HWND hWnd, DarkModeParams p)
 	{
 		if (p._subclass)
@@ -2544,6 +3431,20 @@ namespace DarkMode
 		::SelectObject(hdc, holdPen);
 	}
 
+	/**
+	 * @brief Window subclass procedure for owner drawn tab control.
+	 *
+	 * @param hWnd Window handle being subclassed.
+	 * @param uMsg Message identifier.
+	 * @param wParam Message-specific data.
+	 * @param lParam Message-specific data.
+	 * @param uIdSubclass Subclass identifier.
+	 * @param dwRefData BufferData instance.
+	 * @return LRESULT Result of message processing.
+	 *
+	 * @see DarkMode::setTabCtrlPaintSubclass()
+	 * @see DarkMode::removeTabCtrlPaintSubclass()
+	 */
 	static LRESULT CALLBACK TabPaintSubclass(
 		HWND hWnd,
 		UINT uMsg,
@@ -2659,13 +3560,27 @@ namespace DarkMode
 		DarkMode::removeSubclass<BufferData>(hWnd, TabPaintSubclass, kTabPaintSubclassID);
 	}
 
+	/**
+	 * @brief Window subclass procedure for tab control's updown control subclassing.
+	 *
+	 * @param hWnd Window handle being subclassed.
+	 * @param uMsg Message identifier.
+	 * @param wParam Message-specific data.
+	 * @param lParam Message-specific data.
+	 * @param uIdSubclass Subclass identifier.
+	 * @param dwRefData Reserved data (unused).
+	 * @return LRESULT Result of message processing.
+	 *
+	 * @see DarkMode::setTabCtrlUpDownSubclass()
+	 * @see DarkMode::removeTabCtrlUpDownSubclass()
+	 */
 	static LRESULT CALLBACK TabUpDownSubclass(
 		HWND hWnd,
 		UINT uMsg,
 		WPARAM wParam,
 		LPARAM lParam,
 		UINT_PTR uIdSubclass,
-		DWORD_PTR /*dwRefData*/
+		[[maybe_unused]] DWORD_PTR dwRefData
 	)
 	{
 		switch (uMsg)
@@ -2681,7 +3596,7 @@ namespace DarkMode
 				if (LOWORD(wParam) == WM_CREATE)
 				{
 					auto hUpDown = reinterpret_cast<HWND>(lParam);
-					if (cmpWndClassName(hUpDown, UPDOWN_CLASS))
+					if (CmpWndClassName(hUpDown, UPDOWN_CLASS))
 					{
 						DarkMode::setUpDownCtrlSubclass(hUpDown);
 						return 0;
@@ -2785,6 +3700,20 @@ namespace DarkMode
 		::ReleaseDC(hWnd, hdc);
 	}
 
+	/**
+	 * @brief Window subclass procedure for owner drawn border for list box and edit control.
+	 *
+	 * @param hWnd Window handle being subclassed.
+	 * @param uMsg Message identifier.
+	 * @param wParam Message-specific data.
+	 * @param lParam Message-specific data.
+	 * @param uIdSubclass Subclass identifier.
+	 * @param dwRefData BorderMetricsData instance.
+	 * @return LRESULT Result of message processing.
+	 *
+	 * @see DarkMode::setCustomBorderForListBoxOrEditCtrlSubclass()
+	 * @see DarkMode::removeCustomBorderForListBoxOrEditCtrlSubclass()
+	 */
 	static LRESULT CALLBACK CustomBorderSubclass(
 		HWND hWnd,
 		UINT uMsg,
@@ -2830,21 +3759,6 @@ namespace DarkMode
 				::InflateRect(lpRect, -(pBorderMetricsData->_xEdge), -(pBorderMetricsData->_yEdge));
 
 				break;
-
-				//const auto nStyle = ::GetWindowLongPtr(hWnd, GWL_STYLE);
-				//const bool hasVerScrollbar = (nStyle & WS_VSCROLL) == WS_VSCROLL;
-				//if (hasVerScrollbar)
-				//{
-				//	lpRect->right -= pBorderMetricsData->_xScroll;
-				//}
-
-				//const bool hasHorScrollbar = (nStyle & WS_HSCROLL) == WS_HSCROLL;
-				//if (hasHorScrollbar)
-				//{
-				//	lpRect->bottom -= pBorderMetricsData->_yScroll;
-				//}
-
-				//return 0;
 			}
 
 			case WM_DPICHANGED:
@@ -2911,59 +3825,71 @@ namespace DarkMode
 		return ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
 	}
 
-	static void setCustomBorderForListBoxOrEditCtrlSubclass(HWND hWnd)
+	void setCustomBorderForListBoxOrEditCtrlSubclass(HWND hWnd)
 	{
 		DarkMode::setSubclass<BorderMetricsData>(hWnd, CustomBorderSubclass, kCustomBorderSubclassID);
 	}
 
-	//void removeCustomBorderForListBoxOrEditCtrlSubclass(HWND hWnd)
-	//{
-	//	DarkMode::removeCtrlSubclass<BorderMetricsData>(hWnd, CustomBorderSubclass, kCustomBorderSubclassID);
-	//}
+	void removeCustomBorderForListBoxOrEditCtrlSubclass(HWND hWnd)
+	{
+		DarkMode::removeSubclass<BorderMetricsData>(hWnd, CustomBorderSubclass, kCustomBorderSubclassID);
+	}
 
 	static void setCustomBorderForListBoxOrEditCtrlSubclassAndTheme(HWND hWnd, DarkModeParams p, bool isListBox)
 	{
 		const auto nStyle = ::GetWindowLongPtr(hWnd, GWL_STYLE);
 		const bool hasScrollBar = ((nStyle & WS_HSCROLL) == WS_HSCROLL) || ((nStyle & WS_VSCROLL) == WS_VSCROLL);
-		if (p._theme && (isListBox || hasScrollBar))
+
+		// edit control without scroll bars
+		if (DarkMode::isThemePrefered()
+			&& p._theme
+			&& !isListBox
+			&& !hasScrollBar)
 		{
-			//dark scrollbar for listbox or edit control
-			::SetWindowTheme(hWnd, p._themeClassName, nullptr);
+			DarkMode::setDarkThemeExperimental(hWnd, L"CFD");
 		}
+		else
+		{
+			if (p._theme && (isListBox || hasScrollBar))
+			{
+				// dark scroll bars for list box or edit control
+				::SetWindowTheme(hWnd, p._themeClassName, nullptr);
+			}
 
-		const auto nExStyle = ::GetWindowLongPtr(hWnd, GWL_EXSTYLE);
-		const bool hasClientEdge = (nExStyle & WS_EX_CLIENTEDGE) == WS_EX_CLIENTEDGE;
-		const bool isCBoxListBox = isListBox && (nStyle & LBS_COMBOBOX) == LBS_COMBOBOX;
+			const auto nExStyle = ::GetWindowLongPtr(hWnd, GWL_EXSTYLE);
+			const bool hasClientEdge = (nExStyle & WS_EX_CLIENTEDGE) == WS_EX_CLIENTEDGE;
+			const bool isCBoxListBox = isListBox && (nStyle & LBS_COMBOBOX) == LBS_COMBOBOX;
 
-		if (p._subclass && hasClientEdge && !isCBoxListBox)
-		{
-			DarkMode::setCustomBorderForListBoxOrEditCtrlSubclass(hWnd);
-		}
+			if (p._subclass && hasClientEdge && !isCBoxListBox)
+			{
+				DarkMode::setCustomBorderForListBoxOrEditCtrlSubclass(hWnd);
+			}
 
-		if (::GetWindowSubclass(hWnd, CustomBorderSubclass, kCustomBorderSubclassID, nullptr) == TRUE)
-		{
-			const bool enableClientEdge = !DarkMode::isEnabled();
-			DarkMode::setWindowExStyle(hWnd, enableClientEdge, WS_EX_CLIENTEDGE);
+			if (::GetWindowSubclass(hWnd, CustomBorderSubclass, kCustomBorderSubclassID, nullptr) == TRUE)
+			{
+				const bool enableClientEdge = !DarkMode::isEnabled();
+				DarkMode::setWindowExStyle(hWnd, enableClientEdge, WS_EX_CLIENTEDGE);
+			}
 		}
 	}
 
-	struct ComboboxData
+	struct ComboBoxData
 	{
 		ThemeData _themeData{ VSCLASS_COMBOBOX };
 		BufferData _bufferData;
 
 		LONG_PTR _cbStyle = CBS_SIMPLE;
 
-		ComboboxData() = delete;
+		ComboBoxData() = delete;
 
-		explicit ComboboxData(LONG_PTR cbStyle)
+		explicit ComboBoxData(LONG_PTR cbStyle)
 			: _cbStyle(cbStyle)
 		{}
 	};
 
-	static void paintCombobox(HWND hWnd, HDC hdc, ComboboxData& comboboxData)
+	static void paintCombobox(HWND hWnd, HDC hdc, ComboBoxData& comboBoxData)
 	{
-		auto& themeData = comboboxData._themeData;
+		auto& themeData = comboBoxData._themeData;
 		const auto& hTheme = themeData.getHTheme();
 
 		const bool hasTheme = themeData.ensureTheme(hWnd);
@@ -3005,8 +3931,10 @@ namespace DarkMode
 
 		HBRUSH hBrush = getBrush();
 
+		// Text part
+
 		// CBS_DROPDOWN and CBS_SIMPLE text is handled by parent by WM_CTLCOLOREDIT
-		if (comboboxData._cbStyle == CBS_DROPDOWNLIST)
+		if (comboBoxData._cbStyle == CBS_DROPDOWNLIST)
 		{
 			// erase background on item change
 			::FillRect(hdc, &rcClient, hBrush);
@@ -3056,7 +3984,7 @@ namespace DarkMode
 		{
 			hPen = DarkMode::getDisabledEdgePen();
 		}
-		else if ((isHot || hasFocus || comboboxData._cbStyle == CBS_SIMPLE))
+		else if ((isHot || hasFocus || comboBoxData._cbStyle == CBS_SIMPLE))
 		{
 			hPen = DarkMode::getHotEdgePen();
 		}
@@ -3066,7 +3994,8 @@ namespace DarkMode
 		}
 		auto holdPen = static_cast<HPEN>(::SelectObject(hdc, hPen));
 
-		if (comboboxData._cbStyle != CBS_SIMPLE)
+		// Drop down arrow part
+		if (comboBoxData._cbStyle != CBS_SIMPLE)
 		{
 			if (hasTheme)
 			{
@@ -3093,7 +4022,8 @@ namespace DarkMode
 			}
 		}
 
-		if (comboboxData._cbStyle == CBS_DROPDOWNLIST)
+		// Frame part
+		if (comboBoxData._cbStyle == CBS_DROPDOWNLIST)
 		{
 			::ExcludeClipRect(hdc, rcClient.left + 1, rcClient.top + 1, rcClient.right - 1, rcClient.bottom - 1);
 		}
@@ -3101,7 +4031,7 @@ namespace DarkMode
 		{
 			::ExcludeClipRect(hdc, cbi.rcItem.left, cbi.rcItem.top, cbi.rcItem.right, cbi.rcItem.bottom);
 
-			if (comboboxData._cbStyle == CBS_SIMPLE && cbi.hwndList != nullptr)
+			if (comboBoxData._cbStyle == CBS_SIMPLE && cbi.hwndList != nullptr)
 			{
 				RECT rcItem{ cbi.rcItem };
 				::MapWindowPoints(cbi.hwndItem, hWnd, reinterpret_cast<LPPOINT>(&rcItem), 2);
@@ -3111,7 +4041,7 @@ namespace DarkMode
 			RECT rcInner{ rcClient };
 			::InflateRect(&rcInner, -1, -1);
 
-			if (comboboxData._cbStyle == CBS_DROPDOWN)
+			if (comboBoxData._cbStyle == CBS_DROPDOWN)
 			{
 				const std::array<POINT, 2> edge{ {
 					{ rcArrow.left - 1, rcArrow.top },
@@ -3131,12 +4061,26 @@ namespace DarkMode
 			::FillRect(hdc, &rcInner, isDisabled ? DarkMode::getDlgBackgroundBrush() : DarkMode::getCtrlBackgroundBrush());
 		}
 
-		static const int roundness = DarkMode::isWindows11() ? kWin11CornerRoundness : 0;
+		static const int roundness = DarkMode::isAtLeastWindows11() ? kWin11CornerRoundness : 0;
 		DarkMode::paintRoundFrameRect(hdc, rcClient, hPen, roundness, roundness);
 
 		::SelectObject(hdc, holdPen);
 	}
 
+	/**
+	 * @brief Window subclass procedure for owner drawn combo box control.
+	 *
+	 * @param hWnd Window handle being subclassed.
+	 * @param uMsg Message identifier.
+	 * @param wParam Message-specific data.
+	 * @param lParam Message-specific data.
+	 * @param uIdSubclass Subclass identifier.
+	 * @param dwRefData ComboBoxData instance.
+	 * @return LRESULT Result of message processing.
+	 *
+	 * @see DarkMode::setComboBoxCtrlSubclass()
+	 * @see DarkMode::removeComboBoxCtrlSubclass()
+	 */
 	static LRESULT CALLBACK ComboBoxSubclass(
 		HWND hWnd,
 		UINT uMsg,
@@ -3146,7 +4090,7 @@ namespace DarkMode
 		DWORD_PTR dwRefData
 	)
 	{
-		auto* pComboboxData = reinterpret_cast<ComboboxData*>(dwRefData);
+		auto* pComboboxData = reinterpret_cast<ComboBoxData*>(dwRefData);
 		auto& themeData = pComboboxData->_themeData;
 		auto& bufferData = pComboboxData->_bufferData;
 		const auto& hMemDC = bufferData.getHMemDC();
@@ -3264,21 +4208,23 @@ namespace DarkMode
 	void setComboBoxCtrlSubclass(HWND hWnd)
 	{
 		const auto cbStyle = ::GetWindowLongPtr(hWnd, GWL_STYLE) & CBS_DROPDOWNLIST;
-		DarkMode::setSubclass<ComboboxData>(hWnd, ComboBoxSubclass, kComboBoxSubclassID, cbStyle);
+		DarkMode::setSubclass<ComboBoxData>(hWnd, ComboBoxSubclass, kComboBoxSubclassID, cbStyle);
 	}
 
 	void removeComboBoxCtrlSubclass(HWND hWnd)
 	{
-		DarkMode::removeSubclass<ComboboxData>(hWnd, ComboBoxSubclass, kComboBoxSubclassID);
+		DarkMode::removeSubclass<ComboBoxData>(hWnd, ComboBoxSubclass, kComboBoxSubclassID);
 	}
 
 	static void setComboBoxCtrlSubclassAndTheme(HWND hWnd, DarkModeParams p)
 	{
-		const auto nStyle = ::GetWindowLongPtr(hWnd, GWL_STYLE);
+		const auto cbStyle = ::GetWindowLongPtr(hWnd, GWL_STYLE) & CBS_DROPDOWNLIST;
+		const bool isCbList = cbStyle == CBS_DROPDOWNLIST;
+		const bool isCbSimple = cbStyle == CBS_SIMPLE;
 
-		if ((nStyle & CBS_DROPDOWNLIST) == CBS_DROPDOWNLIST
-			|| (nStyle & CBS_DROPDOWN) == CBS_DROPDOWN
-			|| (nStyle & CBS_SIMPLE) == CBS_SIMPLE)
+		if (isCbList
+			|| cbStyle == CBS_DROPDOWN
+			|| isCbSimple)
 		{
 			COMBOBOXINFO cbi{};
 			cbi.cbSize = sizeof(COMBOBOXINFO);
@@ -3286,39 +4232,58 @@ namespace DarkMode
 			{
 				if (p._theme && cbi.hwndList != nullptr)
 				{
-					if ((nStyle & CBS_SIMPLE) == CBS_SIMPLE)
+					if (isCbSimple)
 					{
 						DarkMode::replaceClientEdgeWithBorderSafe(cbi.hwndList);
 					}
 
-					//dark scrollbar for listbox of combobox
+					// dark scroll bar for list box of combo box
 					::SetWindowTheme(cbi.hwndList, p._themeClassName, nullptr);
 				}
 			}
 
-			if (p._subclass)
+			if (!DarkMode::isThemePrefered() && p._subclass)
 			{
 				HWND hParent = ::GetParent(hWnd);
-				if ((hParent == nullptr || getWndClassName(hParent) != WC_COMBOBOXEX))
+				if ((hParent == nullptr || GetWndClassName(hParent) != WC_COMBOBOXEX))
 				{
 					DarkMode::setComboBoxCtrlSubclass(hWnd);
 				}
 			}
 
-			if (p._theme)
+			if (p._theme) // for light dropdown arrow in dark mode
 			{
 				DarkMode::setDarkThemeExperimental(hWnd, L"CFD");
+
+				if (!isCbList)
+				{
+					::SendMessage(hWnd, CB_SETEDITSEL, 0, 0); // clear selection
+				}
 			}
 		}
 	}
 
+	/**
+	 * @brief Window subclass procedure for custom color for combo box ex' list box and edit control.
+	 *
+	 * @param hWnd Window handle being subclassed.
+	 * @param uMsg Message identifier.
+	 * @param wParam Message-specific data.
+	 * @param lParam Message-specific data.
+	 * @param uIdSubclass Subclass identifier.
+	 * @param dwRefData Reserved data (unused).
+	 * @return LRESULT Result of message processing.
+	 *
+	 * @see DarkMode::setComboBoxExCtrlSubclass()
+	 * @see DarkMode::removeComboBoxExCtrlSubclass()
+	 */
 	static LRESULT CALLBACK ComboboxExSubclass(
 		HWND hWnd,
 		UINT uMsg,
 		WPARAM wParam,
 		LPARAM lParam,
 		UINT_PTR uIdSubclass,
-		DWORD_PTR /*dwRefData*/
+		[[maybe_unused]] DWORD_PTR dwRefData
 	)
 	{
 		switch (uMsg)
@@ -3368,8 +4333,8 @@ namespace DarkMode
 					break;
 				}
 
-				// ComboboxEx has only one child combobox, so only control-defined notification code is checked.
-				// Hooking is done only when listbox is about to show. And unhook when listbox is closed.
+				// ComboboxEx has only one child combo box, so only control-defined notification code is checked.
+				// Hooking is done only when list box is about to show. And unhook when list box is closed.
 				// This process is used to avoid visual glitches in other GUI.
 				switch (HIWORD(wParam))
 				{
@@ -3420,13 +4385,27 @@ namespace DarkMode
 		}
 	}
 
+	/**
+	 * @brief Window subclass procedure for custom color for list view's gridlines and edit control.
+	 *
+	 * @param hWnd Window handle being subclassed.
+	 * @param uMsg Message identifier.
+	 * @param wParam Message-specific data.
+	 * @param lParam Message-specific data.
+	 * @param uIdSubclass Subclass identifier.
+	 * @param dwRefData Reserved data (unused).
+	 * @return LRESULT Result of message processing.
+	 *
+	 * @see DarkMode::setListViewCtrlSubclass()
+	 * @see DarkMode::removeListViewCtrlSubclass()
+	 */
 	static LRESULT CALLBACK ListViewSubclass(
 		HWND hWnd,
 		UINT uMsg,
 		WPARAM wParam,
 		LPARAM lParam,
 		UINT_PTR uIdSubclass,
-		DWORD_PTR /*dwRefData*/
+		[[maybe_unused]] DWORD_PTR dwRefData
 	)
 	{
 		switch (uMsg)
@@ -3481,43 +4460,35 @@ namespace DarkMode
 					break;
 				}
 
-				switch (reinterpret_cast<LPNMHDR>(lParam)->code)
+				if (reinterpret_cast<LPNMHDR>(lParam)->code == NM_CUSTOMDRAW)
 				{
-					case NM_CUSTOMDRAW:
+					auto* lpnmcd = reinterpret_cast<LPNMCUSTOMDRAW>(lParam);
+					switch (lpnmcd->dwDrawStage)
 					{
-						auto* lpnmcd = reinterpret_cast<LPNMCUSTOMDRAW>(lParam);
-						switch (lpnmcd->dwDrawStage)
+						case CDDS_PREPAINT:
 						{
-							case CDDS_PREPAINT:
+							if (DarkMode::isExperimentalActive())
 							{
-								if (DarkMode::isExperimentalActive())
-								{
-									return CDRF_NOTIFYITEMDRAW;
-								}
-								return CDRF_DODEFAULT;
+								return CDRF_NOTIFYITEMDRAW;
 							}
+							return CDRF_DODEFAULT;
+						}
 
-							case CDDS_ITEMPREPAINT:
-							{
-								::SetTextColor(lpnmcd->hdc, DarkMode::getDarkerTextColor());
+						case CDDS_ITEMPREPAINT:
+						{
+							::SetTextColor(lpnmcd->hdc, DarkMode::getDarkerTextColor());
 
-								return CDRF_NEWFONT;
-							}
+							return CDRF_NEWFONT;
+						}
 
-							default:
-							{
-								return CDRF_DODEFAULT;
-							}
+						default:
+						{
+							return CDRF_DODEFAULT;
 						}
 					}
-
-					default:
-					{
-						break;
-					}
-				}
-				break;
-			}
+				}
+				break;
+			}
 
 			default:
 			{
@@ -3539,6 +4510,8 @@ namespace DarkMode
 
 	static void setListViewCtrlSubclassAndTheme(HWND hWnd, DarkModeParams p)
 	{
+		HWND hHeader = ListView_GetHeader(hWnd);
+
 		if (p._theme)
 		{
 			ListView_SetTextColor(hWnd, DarkMode::getViewTextColor());
@@ -3548,12 +4521,19 @@ namespace DarkMode
 			DarkMode::setDarkListView(hWnd);
 			DarkMode::setDarkListViewCheckboxes(hWnd);
 			DarkMode::setDarkTooltips(hWnd, DarkMode::ToolTipsType::listview);
+
+			if (DarkMode::isThemePrefered())
+			{
+				DarkMode::setDarkThemeExperimental(hHeader, L"ItemsView");
+			}
 		}
 
 		if (p._subclass)
 		{
-			HWND hHeader = ListView_GetHeader(hWnd);
-			DarkMode::setDarkHeader(hHeader);
+			if (!DarkMode::isThemePrefered())
+			{
+				DarkMode::setHeaderCtrlSubclass(hHeader);
+			}
 
 			const auto lvExStyle = ListView_GetExtendedListViewStyle(hWnd);
 			ListView_SetExtendedListViewStyle(hWnd, lvExStyle | LVS_EX_DOUBLEBUFFER);
@@ -3720,6 +4700,20 @@ namespace DarkMode
 		::SelectObject(hdc, holdPen);
 	}
 
+	/**
+	 * @brief Window subclass procedure for owner drawn header control.
+	 *
+	 * @param hWnd Window handle being subclassed.
+	 * @param uMsg Message identifier.
+	 * @param wParam Message-specific data.
+	 * @param lParam Message-specific data.
+	 * @param uIdSubclass Subclass identifier.
+	 * @param dwRefData HeaderData instance.
+	 * @return LRESULT Result of message processing.
+	 *
+	 * @see DarkMode::setHeaderCtrlSubclass()
+	 * @see DarkMode::removeHeaderCtrlSubclass()
+	 */
 	static LRESULT CALLBACK HeaderSubclass(
 		HWND hWnd,
 		UINT uMsg,
@@ -3997,11 +4991,13 @@ namespace DarkMode
 			}
 		}
 
-		/*POINT edgeHor[]{
+#if 0 // for horizontal edge
+		POINT edgeHor[]{
 			{rcClient.left, rcClient.top},
 			{rcClient.right, rcClient.top}
 		};
-		Polyline(hdc, edgeHor, _countof(edgeHor));*/
+		Polyline(hdc, edgeHor, _countof(edgeHor));
+#endif
 
 		if (hasSizeGrip)
 		{
@@ -4023,6 +5019,20 @@ namespace DarkMode
 		::SelectObject(hdc, holdPen);
 	}
 
+	/**
+	 * @brief Window subclass procedure for owner drawn status bar control.
+	 *
+	 * @param hWnd Window handle being subclassed.
+	 * @param uMsg Message identifier.
+	 * @param wParam Message-specific data.
+	 * @param lParam Message-specific data.
+	 * @param uIdSubclass Subclass identifier.
+	 * @param dwRefData StatusBarData instance.
+	 * @return LRESULT Result of message processing.
+	 *
+	 * @see DarkMode::setStatusBarCtrlSubclass()
+	 * @see DarkMode::removeStatusBarCtrlSubclass()
+	 */
 	static LRESULT CALLBACK StatusBarSubclass(
 		HWND hWnd,
 		UINT uMsg,
@@ -4115,7 +5125,7 @@ namespace DarkMode
 				LOGFONT lf{};
 				NONCLIENTMETRICS ncm{};
 				ncm.cbSize = sizeof(NONCLIENTMETRICS);
-				if (::SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(NONCLIENTMETRICS), &ncm, 0) != FALSE)
+				if (::SystemParametersInfoW(SPI_GETNONCLIENTMETRICS, sizeof(NONCLIENTMETRICS), &ncm, 0) != FALSE)
 				{
 					lf = ncm.lfStatusFont;
 					pStatusBarData->_fontData.setFont(::CreateFontIndirect(&lf));
@@ -4141,7 +5151,7 @@ namespace DarkMode
 		LOGFONT lf{};
 		NONCLIENTMETRICS ncm{};
 		ncm.cbSize = sizeof(NONCLIENTMETRICS);
-		if (::SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(NONCLIENTMETRICS), &ncm, 0) != FALSE)
+		if (::SystemParametersInfoW(SPI_GETNONCLIENTMETRICS, sizeof(NONCLIENTMETRICS), &ncm, 0) != FALSE)
 		{
 			lf = ncm.lfStatusFont;
 		}
@@ -4166,7 +5176,11 @@ namespace DarkMode
 		ThemeData _themeData{ VSCLASS_PROGRESS };
 		BufferData _bufferData;
 
-		int _iStateID = PBFS_PARTIAL; // PBFS_PARTIAL for cyan color
+		int _iStateID = PBFS_PARTIAL;
+
+		explicit ProgressBarData(HWND hWnd)
+			: _iStateID(static_cast<int>(::SendMessage(hWnd, PBM_GETSTATE, 0, 0)))
+		{}
 	};
 
 	static void getProgressBarRects(HWND hWnd, RECT* rcEmpty, RECT* rcFilled)
@@ -4208,6 +5222,20 @@ namespace DarkMode
 		::FillRect(hdc, &rcClient, DarkMode::getCtrlBackgroundBrush());
 	}
 
+	/**
+	 * @brief Window subclass procedure for owner drawn progress bar control.
+	 *
+	 * @param hWnd Window handle being subclassed.
+	 * @param uMsg Message identifier.
+	 * @param wParam Message-specific data.
+	 * @param lParam Message-specific data.
+	 * @param uIdSubclass Subclass identifier.
+	 * @param dwRefData ProgressBarData instance.
+	 * @return LRESULT Result of message processing.
+	 *
+	 * @see DarkMode::setProgressBarCtrlSubclass()
+	 * @see DarkMode::removeProgressBarCtrlSubclass()
+	 */
 	static LRESULT CALLBACK ProgressBarSubclass(
 		HWND hWnd,
 		UINT uMsg,
@@ -4329,6 +5357,7 @@ namespace DarkMode
 
 					default:
 					{
+						pProgressBarData->_iStateID = PBFS_PARTIAL; // cyan
 						break;
 					}
 				}
@@ -4345,7 +5374,7 @@ namespace DarkMode
 
 	void setProgressBarCtrlSubclass(HWND hWnd)
 	{
-		DarkMode::setSubclass<ProgressBarData>(hWnd, ProgressBarSubclass, kProgressBarSubclassID);
+		DarkMode::setSubclass<ProgressBarData>(hWnd, ProgressBarSubclass, kProgressBarSubclassID, hWnd);
 	}
 
 	void removeProgressBarCtrlSubclass(HWND hWnd)
@@ -4355,16 +5384,14 @@ namespace DarkMode
 
 	static void setProgressBarCtrlSubclass(HWND hWnd, DarkModeParams p)
 	{
-		if (p._theme)
+		const auto nStyle = ::GetWindowLongPtr(hWnd, GWL_STYLE);
+		if (p._theme && (nStyle & PBS_MARQUEE) == PBS_MARQUEE)
 		{
-			if (p._subclass)
-			{
-				DarkMode::setProgressBarCtrlSubclass(hWnd);
-			}
+			DarkMode::setProgressBarClassicTheme(hWnd);
 		}
-		else
+		else if (p._subclass)
 		{
-			DarkMode::setProgressBarClassicTheme(hWnd);
+			DarkMode::setProgressBarCtrlSubclass(hWnd);
 		}
 	}
 
@@ -4379,6 +5406,20 @@ namespace DarkMode
 		{}
 	};
 
+	/**
+	 * @brief Window subclass procedure for better disabled state appearence for static control with text.
+	 *
+	 * @param hWnd Window handle being subclassed.
+	 * @param uMsg Message identifier.
+	 * @param wParam Message-specific data.
+	 * @param lParam Message-specific data.
+	 * @param uIdSubclass Subclass identifier.
+	 * @param dwRefData StaticTextData instance.
+	 * @return LRESULT Result of message processing.
+	 *
+	 * @see DarkMode::setStaticTextCtrlSubclass()
+	 * @see DarkMode::removeStaticTextCtrlSubclass()
+	 */
 	static LRESULT CALLBACK StaticTextSubclass(
 		HWND hWnd,
 		UINT uMsg,
@@ -4455,11 +5496,19 @@ namespace DarkMode
 			TreeView_SetTextColor(hWnd, DarkMode::getViewTextColor());
 			TreeView_SetBkColor(hWnd, DarkMode::getViewBackgroundColor());
 
-			DarkMode::setTreeViewStyle(hWnd, p._theme);
+			DarkMode::setTreeViewWindowTheme(hWnd, p._theme);
 			DarkMode::setDarkTooltips(hWnd, DarkMode::ToolTipsType::treeview);
 		}
 	}
 
+	static void setRebarCtrlSubclass(HWND hWnd, DarkModeParams p)
+	{
+		if (p._subclass)
+		{
+			DarkMode::setWindowEraseBgSubclass(hWnd);
+		}
+	}
+
 	static void setToolbarCtrlTheme(HWND hWnd, DarkModeParams p)
 	{
 		if (p._theme)
@@ -4469,6 +5518,14 @@ namespace DarkMode
 		}
 	}
 
+	static void setScrollBarCtrlTheme(HWND hWnd, DarkModeParams p)
+	{
+		if (p._theme)
+		{
+			DarkMode::setDarkScrollBar(hWnd);
+		}
+	}
+
 	static void enableSysLinkCtrlCtlColor(HWND hWnd, DarkModeParams p)
 	{
 		if (p._theme)
@@ -4485,10 +5542,19 @@ namespace DarkMode
 		}
 	}
 
+	static void setTrackbarCtrlTheme(HWND hWnd, DarkModeParams p)
+	{
+		if (p._theme)
+		{
+			DarkMode::setDarkTooltips(hWnd, ToolTipsType::trackbar);
+			DarkMode::setWindowStyle(hWnd, DarkMode::isEnabled(), TBS_TRANSPARENTBKGND);
+		}
+	}
+
 	static BOOL CALLBACK DarkEnumChildProc(HWND hWnd, LPARAM lParam)
 	{
 		const auto& p = *reinterpret_cast<DarkModeParams*>(lParam);
-		const std::wstring className = getWndClassName(hWnd);
+		const std::wstring className = GetWndClassName(hWnd);
 
 		if (className == WC_BUTTON)
 		{
@@ -4532,6 +5598,12 @@ namespace DarkMode
 			return TRUE;
 		}
 
+		if (className == REBARCLASSNAMEW)
+		{
+			DarkMode::setRebarCtrlSubclass(hWnd, p);
+			return TRUE;
+		}
+
 		if (className == TOOLBARCLASSNAME)
 		{
 			DarkMode::setToolbarCtrlTheme(hWnd, p);
@@ -4558,10 +5630,7 @@ namespace DarkMode
 
 		if (className == WC_SCROLLBAR)
 		{
-			if (p._theme)
-			{
-				DarkMode::setDarkScrollBar(hWnd);
-			}
+			DarkMode::setScrollBarCtrlTheme(hWnd, p);
 			return TRUE;
 		}
 
@@ -4589,18 +5658,18 @@ namespace DarkMode
 			return TRUE;
 		}
 
-		/*
-		// for debugging
-		if (className == L"#32770")
+		if (className == TRACKBAR_CLASS)
 		{
+			DarkMode::setTrackbarCtrlTheme(hWnd, p);
 			return TRUE;
 		}
 
-		if (className == TRACKBAR_CLASS)
+#if 0 // for debugging
+		if (className == L"#32770") // dialog
 		{
 			return TRUE;
 		}
-		*/
+#endif
 
 		return TRUE;
 	}
@@ -4621,17 +5690,34 @@ namespace DarkMode
 #if defined(_DARKMODELIB_ALLOW_OLD_OS)
 		DarkMode::setChildCtrlsSubclassAndTheme(hParent, false, true);
 #else
-		DarkMode::setChildCtrlsSubclassAndTheme(hParent, false, DarkMode::isWindows10());
+		DarkMode::setChildCtrlsSubclassAndTheme(hParent, false, DarkMode::isAtLeastWindows10());
 #endif
 	}
 
+	/**
+	 * @brief Window subclass procedure for handling `WM_ERASEBKGND` message.
+	 *
+	 * Handles `WM_ERASEBKGND` to fill the window's client area with the custom color brush,
+	 * preventing default light gray flicker or mismatched fill.
+	 *
+	 * @param hWnd Window handle being subclassed.
+	 * @param uMsg Message identifier.
+	 * @param wParam Message-specific data.
+	 * @param lParam Message-specific data.
+	 * @param uIdSubclass Subclass identifier.
+	 * @param dwRefData Reserved data (unused).
+	 * @return LRESULT Result of message processing.
+	 *
+	 * @see DarkMode::setWindowEraseBgSubclass()
+	 * @see DarkMode::removeWindowEraseBgSubclass()
+	 */
 	static LRESULT CALLBACK WindowEraseBgSubclass(
 		HWND hWnd,
 		UINT uMsg,
 		WPARAM wParam,
 		LPARAM lParam,
 		UINT_PTR uIdSubclass,
-		DWORD_PTR /*dwRefData*/
+		[[maybe_unused]] DWORD_PTR dwRefData
 	)
 	{
 		switch (uMsg)
@@ -4663,23 +5749,69 @@ namespace DarkMode
 		return ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
 	}
 
+	/**
+	 * @brief Applies window subclassing to handle `WM_ERASEBKGND` message.
+	 *
+	 * @param hWnd Handle to the control to subclass.
+	 *
+	 * @see DarkMode::WindowEraseBgSubclass()
+	 * @see DarkMode::removeWindowEraseBgSubclass()
+	 */
 	void setWindowEraseBgSubclass(HWND hWnd)
 	{
 		DarkMode::setSubclass(hWnd, WindowEraseBgSubclass, kWindowEraseBgSubclassID);
 	}
 
+	/**
+	 * @brief Removes the subclass used for `WM_ERASEBKGND` message handling.
+	 *
+	 * Detaches the window's subclass proc used for `WM_ERASEBKGND` message handling.
+	 *
+	 * @param hWnd Handle to the previously subclassed window.
+	 *
+	 * @see DarkMode::WindowEraseBgSubclass()
+	 * @see DarkMode::removeWindowEraseBgSubclass()
+	 */
 	void removeWindowEraseBgSubclass(HWND hWnd)
 	{
 		DarkMode::removeSubclass(hWnd, WindowEraseBgSubclass, kWindowEraseBgSubclassID);
 	}
 
+	/**
+	 * @brief Window subclass procedure for handling `WM_CTLCOLOR*` messages.
+	 *
+	 * Handles control drawing messages to apply foreground and background
+	 * styling based on control type and class.
+	 *
+	 * Handles:
+	 * - `WM_CTLCOLOREDIT`, `WM_CTLCOLORLISTBOX`, `WM_CTLCOLORDLG`, `WM_CTLCOLORSTATIC`
+	 * - `WM_PRINTCLIENT` for removing light border for push buttons in dark mode
+	 *
+	 * Cleans up subclass on `WM_NCDESTROY`
+	 *
+	 * Uses `DarkMode::onCtlColor*` utilities.
+	 *
+	 * @param hWnd Window handle being subclassed.
+	 * @param uMsg Message identifier.
+	 * @param wParam Message-specific data.
+	 * @param lParam Message-specific data.
+	 * @param uIdSubclass Subclass identifier.
+	 * @param dwRefData Reserved data (unused).
+	 * @return LRESULT Result of message processing.
+	 *
+	 * @see DarkMode::onCtlColor()
+	 * @see DarkMode::onCtlColorDlg()
+	 * @see DarkMode::onCtlColorDlgStaticText()
+	 * @see DarkMode::onCtlColorDlgLinkText()
+	 * @see DarkMode::onCtlColorListbox()
+	 */
 	static LRESULT CALLBACK WindowCtlColorSubclass(
 		HWND hWnd,
 		UINT uMsg,
 		WPARAM wParam,
 		LPARAM lParam,
 		UINT_PTR uIdSubclass,
-		DWORD_PTR /*dwRefData*/
+		[[maybe_unused]] DWORD_PTR dwRefData
 	)
 	{
 		switch (uMsg)
@@ -4727,7 +5859,7 @@ namespace DarkMode
 
 				auto hChild = reinterpret_cast<HWND>(lParam);
 				const bool isChildEnabled = ::IsWindowEnabled(hChild) == TRUE;
-				const std::wstring className = getWndClassName(hChild);
+				const std::wstring className = GetWndClassName(hChild);
 
 				auto hdc = reinterpret_cast<HDC>(wParam);
 
@@ -4745,10 +5877,10 @@ namespace DarkMode
 					return DarkMode::onCtlColorDlgLinkText(hdc, isChildEnabled);
 				}
 
-				DWORD_PTR dwRefData = 0;
-				if (::GetWindowSubclass(hChild, StaticTextSubclass, kStaticTextSubclassID, &dwRefData) == TRUE)
+				DWORD_PTR dwRefDataStaticText = 0;
+				if (::GetWindowSubclass(hChild, StaticTextSubclass, kStaticTextSubclassID, &dwRefDataStaticText) == TRUE)
 				{
-					const bool isTextEnabled = (reinterpret_cast<StaticTextData*>(dwRefData))->_isEnabled;
+					const bool isTextEnabled = (reinterpret_cast<StaticTextData*>(dwRefDataStaticText))->_isEnabled;
 					return DarkMode::onCtlColorDlgStaticText(hdc, isTextEnabled);
 				}
 				return DarkMode::onCtlColorDlg(hdc);
@@ -4771,18 +5903,62 @@ namespace DarkMode
 		return ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
 	}
 
+	/**
+	 * @brief Applies window subclassing to handle `WM_CTLCOLOR*` messages.
+	 *
+	 * Enable custom colors for edit, listbox, static, and dialog elements
+	 * via @ref DarkMode::WindowCtlColorSubclass.
+	 *
+	 * @param hWnd Handle to the parent or composite control (dialog, rebar, toolbar, ...) to subclass.
+	 *
+	 * @see DarkMode::WindowCtlColorSubclass()
+	 * @see DarkMode::removeWindowCtlColorSubclass()
+	 */
 	void setWindowCtlColorSubclass(HWND hWnd)
 	{
 		DarkMode::setSubclass(hWnd, WindowCtlColorSubclass, kWindowCtlColorSubclassID);
 	}
 
+	/**
+	 * @brief Removes the subclass used for `WM_CTLCOLOR*` messages handling.
+	 *
+	 * Detaches the window's subclass proc used for `WM_CTLCOLOR*` messages handling.
+	 *
+	 * @param hWnd Handle to the previously subclassed window.
+	 *
+	 * @see DarkMode::WindowCtlColorSubclass()
+	 * @see DarkMode::setWindowCtlColorSubclass()
+	 */
 	void removeWindowCtlColorSubclass(HWND hWnd)
 	{
 		DarkMode::removeSubclass(hWnd, WindowCtlColorSubclass, kWindowCtlColorSubclassID);
 	}
 
+	/**
+	 * @brief Applies custom drawing to a toolbar items (buttons) during `CDDS_ITEMPREPAINT`
+	 *
+	 * Handles color assignment and background painting for toolbar buttons during the
+	 * `CDDS_ITEMPREPAINT` stage of `NMTBCUSTOMDRAW`. Applies appropriate brushes, pens,
+	 * and background rendering depending on the button state:
+	 * - **Hot**: Uses hot background and edge styling.
+	 * - **Checked**: Uses control background and standard edge styling.
+	 * - **Drop-down**: Calculates and paints iconic split-button drop arrow.
+	 *
+	 * Also configures transparency and color usage for text, hot-tracking, and background fills.
+	 * Ensures hot/checked states are visually overridden by custom color highlights.
+	 *
+	 * @param lptbcd Reference to the toolbar's custom draw structure.
+	 * @return Flags to control draw behavior (`TBCDRF_USECDCOLORS`, `TBCDRF_NOBACKGROUND`, `CDRF_NOTIFYPOSTPAINT`).
+	 *
+	 * @note This function clears `CDIS_HOT`/`CDIS_CHECKED` to allow manual visual overrides.
+	 *
+	 * @see DarkMode::postpaintToolbarItem()
+	 * @see DarkMode::darkToolbarNotifyCustomDraw()
+	 */
 	[[nodiscard]] static LRESULT prepaintToolbarItem(LPNMTBCUSTOMDRAW& lptbcd)
 	{
+		// Set colors
+
 		lptbcd->hbrMonoDither = DarkMode::getBackgroundBrush();
 		lptbcd->hbrLines = DarkMode::getEdgeBrush();
 		lptbcd->hpenLines = DarkMode::getEdgePen();
@@ -4794,18 +5970,21 @@ namespace DarkMode
 		lptbcd->nStringBkMode = TRANSPARENT;
 		lptbcd->nHLStringBkMode = TRANSPARENT;
 
+		// Get styles and rectangles
+
 		const bool isHot = (lptbcd->nmcd.uItemState & CDIS_HOT) == CDIS_HOT;
 		const bool isChecked = (lptbcd->nmcd.uItemState & CDIS_CHECKED) == CDIS_CHECKED;
 
 		RECT rcItem{ lptbcd->nmcd.rc };
 		RECT rcDrop{};
 
-		TBBUTTONINFO tbi{};
-		tbi.cbSize = sizeof(TBBUTTONINFO);
+		TBBUTTONINFOW tbi{};
+		tbi.cbSize = sizeof(TBBUTTONINFOW);
 		tbi.dwMask = TBIF_IMAGE | TBIF_STYLE;
 		::SendMessage(lptbcd->nmcd.hdr.hwndFrom, TB_GETBUTTONINFO, lptbcd->nmcd.dwItemSpec, reinterpret_cast<LPARAM>(&tbi));
+
 		const bool isIcon = tbi.iImage != I_IMAGENONE;
-		const bool isDropDown = ((tbi.fsStyle & BTNS_DROPDOWN) == BTNS_DROPDOWN) && isIcon;
+		const bool isDropDown = ((tbi.fsStyle & BTNS_DROPDOWN) == BTNS_DROPDOWN) && isIcon; // has 2 "buttons"
 		if (isDropDown)
 		{
 			const auto idx = ::SendMessage(lptbcd->nmcd.hdr.hwndFrom, TB_COMMANDTOINDEX, lptbcd->nmcd.dwItemSpec, 0);
@@ -4814,9 +5993,11 @@ namespace DarkMode
 			rcItem.right = rcDrop.left;
 		}
 
-		static const int roundness = DarkMode::isWindows11() ? kWin11CornerRoundness + 1 : 0;
+		static const int roundness = DarkMode::isAtLeastWindows11() ? kWin11CornerRoundness + 1 : 0;
 
-		if (isHot)
+		// Paint part
+
+		if (isHot) // hot must have higher priority to overwrite checked state
 		{
 			if (!isIcon)
 			{
@@ -4831,7 +6012,7 @@ namespace DarkMode
 				}
 			}
 
-			lptbcd->nmcd.uItemState &= ~static_cast<UINT>(CDIS_CHECKED | CDIS_HOT);
+			lptbcd->nmcd.uItemState &= ~static_cast<UINT>(CDIS_CHECKED | CDIS_HOT); // clears states to use custom highlight
 		}
 		else if (isChecked)
 		{
@@ -4848,7 +6029,7 @@ namespace DarkMode
 				}
 			}
 
-			lptbcd->nmcd.uItemState &= ~static_cast<UINT>(CDIS_CHECKED);
+			lptbcd->nmcd.uItemState &= ~static_cast<UINT>(CDIS_CHECKED); // clears state to use custom highlight
 		}
 
 		LRESULT retVal = TBCDRF_USECDCOLORS;
@@ -4865,10 +6046,28 @@ namespace DarkMode
 		return retVal;
 	}
 
+	/**
+	 * @brief Applies custom drawing to a toolbar items (buttons) during `CDDS_ITEMPOSTPAINT.
+	 *
+	 * Paints arrow glyph with custom color over system black "⏷" for button with style `BTNS_DROPDOWN`.
+	 * Triggered by `CDRF_NOTIFYPOSTPAINT` from @ref DarkMode::prepaintToolbarItem.
+	 *
+	 * Logic:
+	 * - Retrieves the drop-down rectangle via `TB_GETITEMDROPDOWNRECT`.
+	 * - Selects the toolbar font and draws a centered arrow glyph with custom text color.
+	 *
+	 * @param lptbcd Reference to `LPNMTBCUSTOMDRAW`.
+	 * @return `CDRF_DODEFAULT` to let default text/icon rendering proceed normally.
+	 *
+	 * @note Only applies to iconic buttons.
+	 *
+	 * @see DarkMode::prepaintToolbarItem()
+	 * @see DarkMode::darkToolbarNotifyCustomDraw()
+	 */
 	[[nodiscard]] static LRESULT postpaintToolbarItem(LPNMTBCUSTOMDRAW& lptbcd)
 	{
-		TBBUTTONINFO tbi{};
-		tbi.cbSize = sizeof(TBBUTTONINFO);
+		TBBUTTONINFOW tbi{};
+		tbi.cbSize = sizeof(TBBUTTONINFOW);
 		tbi.dwMask = TBIF_IMAGE;
 		::SendMessage(lptbcd->nmcd.hdr.hwndFrom, TB_GETBUTTONINFO, lptbcd->nmcd.dwItemSpec, reinterpret_cast<LPARAM>(&tbi));
 		const bool isIcon = tbi.iImage != I_IMAGENONE;
@@ -4894,6 +6093,24 @@ namespace DarkMode
 		return CDRF_DODEFAULT;
 	}
 
+	/**
+	 * @brief Handles custom draw notifications for a toolbar control.
+	 *
+	 * Processes `NMTBCUSTOMDRAW` messages to provide custom color painting
+	 * at each stage of the custom draw cycle:
+	 * - **CDDS_PREPAINT**: Fills the toolbar background and requests item-level drawing.
+	 * - **CDDS_ITEMPREPAINT**: Applies custom item painting via @ref DarkMode::prepaintToolbarItem.
+	 * - **CDDS_ITEMPOSTPAINT**: Paints dropdown arrows glyphs via @ref DarkMode::postpaintToolbarItem.
+	 *
+	 * @param hWnd Handle to the toolbar control.
+	 * @param uMsg Should be `WM_NOTIFY` with custom draw type (forwarded to default subclass processing).
+	 * @param wParam Message parameter (forwarded to default subclass processing).
+	 * @param lParam Pointer to `NMTBCUSTOMDRAW`.
+	 * @return `LRESULT` containing draw flags or the result of default subclass processing.
+	 *
+	 * @see DarkMode::prepaintToolbarItem()
+	 * @see DarkMode::postpaintToolbarItem()
+	 */
 	[[nodiscard]] static LRESULT darkToolbarNotifyCustomDraw(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
 	{
 		auto* lptbcd = reinterpret_cast<LPNMTBCUSTOMDRAW>(lParam);
@@ -4902,14 +6119,8 @@ namespace DarkMode
 		{
 			case CDDS_PREPAINT:
 			{
-				LRESULT retVal = CDRF_DODEFAULT;
-				if (DarkMode::isEnabled())
-				{
-					::FillRect(lptbcd->nmcd.hdc, &lptbcd->nmcd.rc, DarkMode::getDlgBackgroundBrush());
-					retVal |= CDRF_NOTIFYITEMDRAW | CDRF_NOTIFYPOSTPAINT;
-				}
-
-				return retVal;
+				::FillRect(lptbcd->nmcd.hdc, &lptbcd->nmcd.rc, DarkMode::getDlgBackgroundBrush());
+				return CDRF_NOTIFYITEMDRAW | CDRF_NOTIFYPOSTPAINT;
 			}
 
 			case CDDS_ITEMPREPAINT:
@@ -4930,7 +6141,24 @@ namespace DarkMode
 		return ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
 	}
 
-	static void prepaintListViewItem(LPNMLVCUSTOMDRAW& lplvcd, bool isReport, bool hasGridlines)
+	/**
+	 * @brief Applies custom drawing to a list view item during `CDDS_ITEMPREPAINT`.
+	 *
+	 * Sets text/background colors and fills the item rectangle based on state and style.
+	 * Handles list view custom colors and styles, and adapts to grid line configuration.
+	 *
+	 * Behavior:
+	 * - **Selected**: Uses `DarkMode::getCtrlBackground*()` colors and text brush.
+	 * - **Hot**: Uses `DarkMode::getHotBackground*()` colors with optional hover frame.
+	 * - **Gridlines active**: Fills the entire row background, column by column.
+	 *
+	 * @param lplvcd Reference to `LPNMLVCUSTOMDRAW`.
+	 * @param isReport Whether list view is in `LVS_REPORT` mode.
+	 * @param hasGridLines Whether grid lines are enabled (`LVS_EX_GRIDLINES`).
+	 *
+	 * @see DarkMode::darkListViewNotifyCustomDraw()
+	 */
+	static void prepaintListViewItem(LPNMLVCUSTOMDRAW& lplvcd, bool isReport, bool hasGridLines)
 	{
 		const auto& hList = lplvcd->nmcd.hdr.hwndFrom;
 		const bool isSelected = ListView_GetItemState(hList, lplvcd->nmcd.dwItemSpec, LVIS_SELECTED) == LVIS_SELECTED;
@@ -4954,7 +6182,7 @@ namespace DarkMode
 
 		if (hBrush != nullptr)
 		{
-			if (!isReport || hasGridlines)
+			if (!isReport || hasGridLines)
 			{
 				::FillRect(lplvcd->nmcd.hdc, &lplvcd->nmcd.rc, hBrush);
 			}
@@ -4983,21 +6211,40 @@ namespace DarkMode
 				}
 			}
 		}
-		else if (hasGridlines)
+		else if (hasGridLines)
 		{
 			::FillRect(lplvcd->nmcd.hdc, &lplvcd->nmcd.rc, DarkMode::getViewBackgroundBrush());
 		}
 
 		if (isFocused)
 		{
-			//::DrawFocusRect(lplvcd->nmcd.hdc, &lplvcd->nmcd.rc);
+#if 0 // for testing
+			::DrawFocusRect(lplvcd->nmcd.hdc, &lplvcd->nmcd.rc);
+#endif
 		}
-		else if (!isSelected && isHot && !hasGridlines)
+		else if (!isSelected && isHot && !hasGridLines)
 		{
 			::FrameRect(lplvcd->nmcd.hdc, &lplvcd->nmcd.rc, DarkMode::getHotEdgeBrush());
 		}
 	}
 
+	/**
+	 * @brief Handles custom draw notifications for a list view control.
+	 *
+	 * Processes `NMLVCUSTOMDRAW` messages to provide custom color painting
+	 * at each stage of the custom draw cycle:
+	 * - **CDDS_PREPAINT**: Optionally fills the list view with grid lines
+	 *                      with custom background color and requests item-level drawing.
+	 * - **CDDS_ITEMPREPAINT**: Applies custom item painting via @ref DarkMode::prepaintListViewItem.
+	 *
+	 * @param hWnd Handle to the list view control.
+	 * @param uMsg Should be `WM_NOTIFY` with custom draw type (forwarded to default subclass processing).
+	 * @param wParam Message parameter (forwarded to default subclass processing).
+	 * @param lParam Pointer to `NMLVCUSTOMDRAW`.
+	 * @return `LRESULT` containing draw flags or the result of default subclass processing.
+	 *
+	 * @see DarkMode::prepaintListViewItem()
+	 */
 	[[nodiscard]] static LRESULT darkListViewNotifyCustomDraw(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
 	{
 		auto* lplvcd = reinterpret_cast<LPNMLVCUSTOMDRAW>(lParam);
@@ -5015,11 +6262,6 @@ namespace DarkMode
 		{
 			case CDDS_PREPAINT:
 			{
-				if (!DarkMode::isEnabled())
-				{
-					return CDRF_DODEFAULT;
-				}
-
 				if (isReport && hasGridlines)
 				{
 					::FillRect(lplvcd->nmcd.hdc, &lplvcd->nmcd.rc, DarkMode::getViewBackgroundBrush());
@@ -5042,6 +6284,18 @@ namespace DarkMode
 		return ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
 	}
 
+	/**
+	 * @brief Applies custom drawing to a tree view node during `CDDS_ITEMPREPAINT`.
+	 *
+	 * Colors the node background for selection/hot states, assigns text color,
+	 * and requests optional post-paint framing.
+	 *
+	 * @param lptvcd Reference to `LPNMTVCUSTOMDRAW`.
+	 * @return Bitmask with `CDRF_NEWFONT`, `CDRF_NOTIFYPOSTPAINT` if drawing was applied.
+	 *
+	 * @see DarkMode::postpaintTreeViewItem()
+	 * @see DarkMode::darkTreeViewNotifyCustomDraw()
+	 */
 	[[nodiscard]] static LRESULT prepaintTreeViewItem(LPNMTVCUSTOMDRAW& lptvcd)
 	{
 		LRESULT retVal = CDRF_DODEFAULT;
@@ -5059,7 +6313,7 @@ namespace DarkMode
 			lptvcd->clrText = DarkMode::getTextColor();
 			lptvcd->clrTextBk = DarkMode::getHotBackgroundColor();
 
-			if (DarkMode::isWindows10() || g_dmCfg._treeViewStyle == TreeViewStyle::light)
+			if (DarkMode::isAtLeastWindows10() || DarkMode::getTreeViewStyle() == TreeViewStyle::light)
 			{
 				::FillRect(lptvcd->nmcd.hdc, &lptvcd->nmcd.rc, DarkMode::getHotBackgroundBrush());
 				retVal |= CDRF_NOTIFYPOSTPAINT;
@@ -5070,6 +6324,16 @@ namespace DarkMode
 		return retVal;
 	}
 
+	/**
+	 * @brief Applies custom drawing to a tree view node during `CDDS_ITEMPOSTPAINT`.
+	 *
+	 * Paints a frame around a tree view node after painting based on state.
+	 *
+	 * @param lptvcd Reference to `LPNMTVCUSTOMDRAW`.
+	 *
+	 * @see DarkMode::prepaintTreeViewItem()
+	 * @see DarkMode::darkTreeViewNotifyCustomDraw()
+	 */
 	static void postpaintTreeViewItem(LPNMTVCUSTOMDRAW& lptvcd)
 	{
 		RECT rcFrame{ lptvcd->nmcd.rc };
@@ -5085,6 +6349,24 @@ namespace DarkMode
 		}
 	}
 
+	/**
+	 * @brief Handles custom draw notifications for a tree view control.
+	 *
+	 * Processes `NMTVCUSTOMDRAW` messages to provide custom color painting
+	 * at each stage of the custom draw cycle:
+	 * - **CDDS_PREPAINT**: Requests item-level drawing.
+	 * - **CDDS_ITEMPREPAINT**: Applies custom item painting based on state via @ref DarkMode::prepaintTreeViewItem.
+	 * - **CDDS_ITEMPOSTPAINT**: Paints frames based on state via @ref DarkMode::postpaintTreeViewItem.
+	 *
+	 * @param hWnd Handle to the tree view control.
+	 * @param uMsg Should be `WM_NOTIFY` with custom draw type (forwarded to default subclass processing).
+	 * @param wParam Message parameter (forwarded to default subclass processing).
+	 * @param lParam Pointer to `NMTVCUSTOMDRAW`.
+	 * @return `LRESULT` containing draw flags or the result of default subclass processing.
+	 *
+	 * @see DarkMode::prepaintTreeViewItem()
+	 * @see DarkMode::postpaintTreeViewItem()
+	 */
 	[[nodiscard]] static LRESULT darkTreeViewNotifyCustomDraw(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
 	{
 		auto* lptvcd = reinterpret_cast<LPNMTVCUSTOMDRAW>(lParam);
@@ -5093,12 +6375,17 @@ namespace DarkMode
 		{
 			case CDDS_PREPAINT:
 			{
-				return DarkMode::isEnabled() ? CDRF_NOTIFYITEMDRAW : CDRF_DODEFAULT;
+				return CDRF_NOTIFYITEMDRAW;
 			}
 
 			case CDDS_ITEMPREPAINT:
 			{
-				return DarkMode::prepaintTreeViewItem(lptvcd);
+				const LRESULT retVal = DarkMode::prepaintTreeViewItem(lptvcd);
+				if (retVal == CDRF_DODEFAULT)
+				{
+					break;
+				}
+				return retVal;
 			}
 
 			case CDDS_ITEMPOSTPAINT:
@@ -5115,7 +6402,81 @@ namespace DarkMode
 		return ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
 	}
 
-	[[nodiscard]] static LRESULT darkTrackBarNotifyCustomDraw(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
+	/**
+	 * @brief Applies custom drawing to a trackbar items during `CDDS_ITEMPREPAINT`.
+	 *
+	 * Colors the trackbar thumb background for selection state,
+	 * and colors the trackbar slider based on if tracbar is enabled.
+	 * For trackbar with style `TBS_AUTOTICKS` default handling is used.
+	 *
+	 * @param lpnmcd Reference to `LPNMCUSTOMDRAW`.
+	 * @return `CDRF_SKIPDEFAULT` if drawing was applied.
+	 *
+	 * @see DarkMode::darkTrackbarNotifyCustomDraw()
+	 */
+	[[nodiscard]] static LRESULT prepaintTrackbarItem(LPNMCUSTOMDRAW& lpnmcd)
+	{
+		LRESULT retVal = CDRF_DODEFAULT;
+
+		switch (lpnmcd->dwItemSpec)
+		{
+			case TBCD_TICS:
+			{
+				break;
+			}
+
+			case TBCD_THUMB:
+			{
+				if ((lpnmcd->uItemState & CDIS_SELECTED) == CDIS_SELECTED)
+				{
+					::FillRect(lpnmcd->hdc, &lpnmcd->rc, DarkMode::getCtrlBackgroundBrush());
+					retVal = CDRF_SKIPDEFAULT;
+				}
+				break;
+			}
+
+			case TBCD_CHANNEL: // slider
+			{
+				if (::IsWindowEnabled(lpnmcd->hdr.hwndFrom) == FALSE)
+				{
+					::FillRect(lpnmcd->hdc, &lpnmcd->rc, DarkMode::getDlgBackgroundBrush());
+					DarkMode::paintRoundFrameRect(lpnmcd->hdc, lpnmcd->rc, DarkMode::getEdgePen(), 0, 0);
+				}
+				else
+				{
+					::FillRect(lpnmcd->hdc, &lpnmcd->rc, DarkMode::getCtrlBackgroundBrush());
+				}
+
+				retVal = CDRF_SKIPDEFAULT;
+				break;
+			}
+
+			default:
+			{
+				break;
+			}
+		}
+
+		return retVal;
+	}
+
+	/**
+	 * @brief Handles custom draw notifications for a trackbar control.
+	 *
+	 * Processes `NMCUSTOMDRAW` messages to provide custom color painting
+	 * at each stage of the custom draw cycle:
+	 * - **CDDS_PREPAINT**: Requests item-level drawing.
+	 * - **CDDS_ITEMPREPAINT**: Applies custom item painting based on item type via @ref DarkMode::prepaintTrackbarItem.
+	 *
+	 * @param hWnd Handle to the trackbar control.
+	 * @param uMsg Should be `WM_NOTIFY` with custom draw type (forwarded to default subclass processing).
+	 * @param wParam Message parameter (forwarded to default subclass processing).
+	 * @param lParam Pointer to `NMCUSTOMDRAW`.
+	 * @return `LRESULT` containing draw flags or the result of default subclass processing.
+	 *
+	 * @see DarkMode::prepaintTrackbarItem()
+	 */
+	[[nodiscard]] static LRESULT darkTrackbarNotifyCustomDraw(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
 	{
 		auto* lpnmcd = reinterpret_cast<LPNMCUSTOMDRAW>(lParam);
 
@@ -5123,44 +6484,17 @@ namespace DarkMode
 		{
 			case CDDS_PREPAINT:
 			{
-				return DarkMode::isEnabled() ? CDRF_NOTIFYITEMDRAW : CDRF_DODEFAULT;
+				return CDRF_NOTIFYITEMDRAW;
 			}
 
 			case CDDS_ITEMPREPAINT:
 			{
-				switch (lpnmcd->dwItemSpec)
+				const LRESULT retVal = DarkMode::prepaintTrackbarItem(lpnmcd);
+				if (retVal == CDRF_DODEFAULT)
 				{
-					case TBCD_THUMB:
-					{
-						if ((lpnmcd->uItemState & CDIS_SELECTED) == CDIS_SELECTED)
-						{
-							::FillRect(lpnmcd->hdc, &lpnmcd->rc, DarkMode::getCtrlBackgroundBrush());
-							return CDRF_SKIPDEFAULT;
-						}
-						break;
-					}
-
-					case TBCD_CHANNEL:
-					{
-						if (::IsWindowEnabled(lpnmcd->hdr.hwndFrom) == FALSE)
-						{
-							::FillRect(lpnmcd->hdc, &lpnmcd->rc, DarkMode::getDlgBackgroundBrush());
-							DarkMode::paintRoundFrameRect(lpnmcd->hdc, lpnmcd->rc, DarkMode::getEdgePen(), 0, 0);
-						}
-						else
-						{
-							::FillRect(lpnmcd->hdc, &lpnmcd->rc, DarkMode::getCtrlBackgroundBrush());
-						}
-
-						return CDRF_SKIPDEFAULT;
-					}
-
-					default:
-					{
-						break;
-					}
+					break;
 				}
-				break;
+				return retVal;
 			}
 
 			default:
@@ -5171,49 +6505,92 @@ namespace DarkMode
 		return ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
 	}
 
+	/**
+	 * @brief Applies custom drawing to a rebar control during `CDDS_PREPAINT`.
+	 *
+	 * Paints chevrons and 'gripper' edges for all bands if applicable.
+	 *
+	 * @param lpnmcd Reference to `LPNMCUSTOMDRAW`.
+	 * @return `CDRF_SKIPDEFAULT` if drawing was applied.
+	 *
+	 * @see DarkMode::darkRebarNotifyCustomDraw()
+	 */
 	[[nodiscard]] static LRESULT prepaintRebar(LPNMCUSTOMDRAW& lpnmcd)
 	{
-		if (!DarkMode::isEnabled())
-		{
-			return CDRF_DODEFAULT;
-		}
-
 		::FillRect(lpnmcd->hdc, &lpnmcd->rc, DarkMode::getDlgBackgroundBrush());
+
 		REBARBANDINFO rbBand{};
 		rbBand.cbSize = sizeof(REBARBANDINFO);
 		rbBand.fMask = RBBIM_STYLE | RBBIM_CHEVRONLOCATION | RBBIM_CHEVRONSTATE;
-		::SendMessage(lpnmcd->hdr.hwndFrom, RB_GETBANDINFO, 0, reinterpret_cast<LPARAM>(&rbBand));
 
-		LRESULT retVal = CDRF_DODEFAULT;
-
-		if ((rbBand.fStyle & RBBS_USECHEVRON) == RBBS_USECHEVRON
-			&& (rbBand.rcChevronLocation.right - rbBand.rcChevronLocation.left) > 0)
+		const auto nBands = static_cast<UINT>(::SendMessage(lpnmcd->hdr.hwndFrom, RB_GETBANDCOUNT, 0, 0));
+		for (UINT i = 0; i < nBands; ++i)
 		{
-			static const int roundness = DarkMode::isWindows11() ? kWin11CornerRoundness + 1 : 0;
-
-			const bool isHot = (rbBand.uChevronState & STATE_SYSTEM_HOTTRACKED) == STATE_SYSTEM_HOTTRACKED;
-			const bool isPressed = (rbBand.uChevronState & STATE_SYSTEM_PRESSED) == STATE_SYSTEM_PRESSED;
+			::SendMessage(lpnmcd->hdr.hwndFrom, RB_GETBANDINFO, static_cast<WPARAM>(i), reinterpret_cast<LPARAM>(&rbBand));
 
-			if (isHot)
+			// paints chevron
+			if ((rbBand.fStyle & RBBS_USECHEVRON) == RBBS_USECHEVRON
+				&& (rbBand.rcChevronLocation.right - rbBand.rcChevronLocation.left) > 0)
 			{
-				DarkMode::paintRoundRect(lpnmcd->hdc, rbBand.rcChevronLocation, DarkMode::getHotEdgePen(), DarkMode::getHotBackgroundBrush(), roundness, roundness);
+				static const int roundness = DarkMode::isAtLeastWindows11() ? kWin11CornerRoundness + 1 : 0;
+
+				const bool isHot = (rbBand.uChevronState & STATE_SYSTEM_HOTTRACKED) == STATE_SYSTEM_HOTTRACKED;
+				const bool isPressed = (rbBand.uChevronState & STATE_SYSTEM_PRESSED) == STATE_SYSTEM_PRESSED;
+
+				if (isHot)
+				{
+					DarkMode::paintRoundRect(lpnmcd->hdc, rbBand.rcChevronLocation, DarkMode::getHotEdgePen(), DarkMode::getHotBackgroundBrush(), roundness, roundness);
+				}
+				else if (isPressed)
+				{
+					DarkMode::paintRoundRect(lpnmcd->hdc, rbBand.rcChevronLocation, DarkMode::getEdgePen(), DarkMode::getCtrlBackgroundBrush(), roundness, roundness);
+				}
+
+				::SetTextColor(lpnmcd->hdc, isHot ? DarkMode::getTextColor() : DarkMode::getDarkerTextColor());
+				::SetBkMode(lpnmcd->hdc, TRANSPARENT);
+
+				static constexpr UINT dtFlags = DT_NOPREFIX | DT_CENTER | DT_TOP | DT_SINGLELINE | DT_NOCLIP;
+				::DrawText(lpnmcd->hdc, L"»", -1, &rbBand.rcChevronLocation, dtFlags);
 			}
-			else if (isPressed)
+
+			// paints gripper edge
+			if ((rbBand.fStyle & RBBS_GRIPPERALWAYS) == RBBS_GRIPPERALWAYS
+				&& ((rbBand.fStyle & RBBS_FIXEDSIZE) != RBBS_FIXEDSIZE
+					|| (rbBand.fStyle & RBBS_NOGRIPPER) != RBBS_NOGRIPPER))
 			{
-				DarkMode::paintRoundRect(lpnmcd->hdc, rbBand.rcChevronLocation, DarkMode::getEdgePen(), DarkMode::getCtrlBackgroundBrush(), roundness, roundness);
-			}
+				auto holdPen = static_cast<HPEN>(::SelectObject(lpnmcd->hdc, DarkMode::getDarkerTextPen()));
 
-			::SetTextColor(lpnmcd->hdc, isHot ? DarkMode::getTextColor() : DarkMode::getDarkerTextColor());
-			::SetBkMode(lpnmcd->hdc, TRANSPARENT);
+				RECT rcBand{};
+				::SendMessage(lpnmcd->hdr.hwndFrom, RB_GETRECT, static_cast<WPARAM>(i), reinterpret_cast<LPARAM>(&rcBand));
 
-			static constexpr UINT dtFlags = DT_NOPREFIX | DT_CENTER | DT_TOP | DT_SINGLELINE | DT_NOCLIP;
-			::DrawText(lpnmcd->hdc, L"»", -1, &rbBand.rcChevronLocation, dtFlags);
+				static constexpr LONG offset = 5;
+				const std::array<POINT, 2> edges{ {
+					{ rcBand.left, rcBand.top + offset},
+					{ rcBand.left, rcBand.bottom - offset}
+				} };
+				::Polyline(lpnmcd->hdc, edges.data(), static_cast<int>(edges.size()));
 
-			retVal = CDRF_SKIPDEFAULT;
+				::SelectObject(lpnmcd->hdc, holdPen);
+			}
 		}
-		return retVal;
+		return CDRF_SKIPDEFAULT;
 	}
 
+	/**
+	 * @brief Handles custom draw notifications for a rebar control.
+	 *
+	 * Processes `NMCUSTOMDRAW` messages to provide custom color painting
+	 * at each stage of the custom draw cycle:
+	 * - **CDDS_PREPAINT**: Applies custom painting based on item type via @ref DarkMode::prepaintRebar.
+	 *
+	 * @param hWnd Handle to the rebar control.
+	 * @param uMsg Should be `WM_NOTIFY` with custom draw type (forwarded to default subclass processing).
+	 * @param wParam Message parameter (forwarded to default subclass processing).
+	 * @param lParam Pointer to `NMCUSTOMDRAW`.
+	 * @return `LRESULT` containing draw flags or the result of default subclass processing.
+	 *
+	 * @see DarkMode::prepaintRebar()
+	 */
 	[[nodiscard]] static LRESULT darkRebarNotifyCustomDraw(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
 	{
 		auto* lpnmcd = reinterpret_cast<LPNMCUSTOMDRAW>(lParam);
@@ -5224,13 +6601,30 @@ namespace DarkMode
 		return ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
 	}
 
+	/**
+	 * @brief Window subclass procedure for handling `WM_NOTIFY` message for custom draw for supported controls.
+	 *
+	 * Handles `WM_NOTIFY` for custom draw for supported controls:
+	 * - toolbar, list view, tree view, trackbar, and rebar.
+	 *
+	 * @param hWnd Window handle being subclassed.
+	 * @param uMsg Message identifier.
+	 * @param wParam Message-specific data.
+	 * @param lParam Message-specific data.
+	 * @param uIdSubclass Subclass identifier.
+	 * @param dwRefData Reserved data (unused).
+	 * @return LRESULT Result of message processing.
+	 *
+	 * @see DarkMode::setWindowNotifyCustomDrawSubclass()
+	 * @see DarkMode::removeWindowNotifyCustomDrawSubclass()
+	 */
 	static LRESULT CALLBACK WindowNotifySubclass(
 		HWND hWnd,
 		UINT uMsg,
 		WPARAM wParam,
 		LPARAM lParam,
 		UINT_PTR uIdSubclass,
-		DWORD_PTR /*dwRefData*/
+		[[maybe_unused]] DWORD_PTR dwRefData
 	)
 	{
 		switch (uMsg)
@@ -5249,42 +6643,33 @@ namespace DarkMode
 				}
 
 				auto* lpnmhdr = reinterpret_cast<LPNMHDR>(lParam);
-				const std::wstring className = getWndClassName(lpnmhdr->hwndFrom);
-
-				switch (lpnmhdr->code)
+				if (lpnmhdr->code == NM_CUSTOMDRAW)
 				{
-					case NM_CUSTOMDRAW:
-					{
-						if (className == TOOLBARCLASSNAME)
-						{
-							return DarkMode::darkToolbarNotifyCustomDraw(hWnd, uMsg, wParam, lParam);
-						}
+					const std::wstring className = GetWndClassName(lpnmhdr->hwndFrom);
 
-						if (className == WC_LISTVIEW)
-						{
-							return DarkMode::darkListViewNotifyCustomDraw(hWnd, uMsg, wParam, lParam);
-						}
+					if (className == TOOLBARCLASSNAME)
+					{
+						return DarkMode::darkToolbarNotifyCustomDraw(hWnd, uMsg, wParam, lParam);
+					}
 
-						if (className == WC_TREEVIEW)
-						{
-							return DarkMode::darkTreeViewNotifyCustomDraw(hWnd, uMsg, wParam, lParam);
-						}
+					if (className == WC_LISTVIEW)
+					{
+						return DarkMode::darkListViewNotifyCustomDraw(hWnd, uMsg, wParam, lParam);
+					}
 
-						if (className == TRACKBAR_CLASS)
-						{
-							return DarkMode::darkTrackBarNotifyCustomDraw(hWnd, uMsg, wParam, lParam);
-						}
+					if (className == WC_TREEVIEW)
+					{
+						return DarkMode::darkTreeViewNotifyCustomDraw(hWnd, uMsg, wParam, lParam);
+					}
 
-						if (className == REBARCLASSNAME)
-						{
-							return DarkMode::darkRebarNotifyCustomDraw(hWnd, uMsg, wParam, lParam);
-						}
-						break;
+					if (className == TRACKBAR_CLASS)
+					{
+						return DarkMode::darkTrackbarNotifyCustomDraw(hWnd, uMsg, wParam, lParam);
 					}
 
-					default:
+					if (className == REBARCLASSNAME)
 					{
-						break;
+						return DarkMode::darkRebarNotifyCustomDraw(hWnd, uMsg, wParam, lParam);
 					}
 				}
 				break;
@@ -5298,26 +6683,199 @@ namespace DarkMode
 		return ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
 	}
 
-	void setWindowNotifyCustomDrawSubclass(HWND hWnd, bool subclassChildren)
+	/**
+	 * @brief Applies window subclassing for handling `NM_CUSTOMDRAW` notifications for custom drawing.
+	 *
+	 * Installs @ref DarkMode::WindowNotifySubclass.
+	 * Enables handling of `WM_NOTIFY` `NM_CUSTOMDRAW` notifications for custom drawing
+	 * behavior for supported controls.
+	 *
+	 * @param hWnd Handle to the window with child which support `NM_CUSTOMDRAW`.
+	 *
+	 * @see DarkMode::WindowNotifySubclass()
+	 * @see DarkMode::removeWindowNotifyCustomDrawSubclass()
+	 */
+	void setWindowNotifyCustomDrawSubclass(HWND hWnd)
+	{
+		DarkMode::setSubclass(hWnd, WindowNotifySubclass, kWindowNotifySubclassID);
+	}
+
+	/**
+	 * @brief Removes the subclass used for handling `NM_CUSTOMDRAW` notifications for custom drawing.
+	 *
+	 * Detaches the window's subclass proc used for handling `NM_CUSTOMDRAW` notifications for custom drawing.
+	 *
+	 * @param hWnd Handle to the previously subclassed window.
+	 *
+	 * @see DarkMode::WindowNotifySubclass()
+	 * @see DarkMode::setWindowNotifyCustomDrawSubclass()
+	 */
+	void removeWindowNotifyCustomDrawSubclass(HWND hWnd)
 	{
-		if (DarkMode::setSubclass(hWnd, WindowNotifySubclass, kWindowNotifySubclassID) == TRUE)
+		DarkMode::removeSubclass(hWnd, WindowNotifySubclass, kWindowNotifySubclassID);
+	}
+
+	/**
+	 * @brief Fills the menu bar background custom color.
+	 *
+	 * Uses `GetMenuBarInfo` and `GetWindowRect` to compute the menu bar rectangle
+	 * in client-relative coordinates, then fills it with @ref DarkMode::getDlgBackgroundBrush.
+	 *
+	 * @param hWnd Handle to the window with a menu bar.
+	 * @param hdc Target device context for painting.
+	 *
+	 * @note Offsets top slightly to account for non-client overlap.
+	 */
+	static void paintMenuBar(HWND hWnd, HDC hdc)
+	{
+		// get the menubar rect
+		MENUBARINFO mbi{};
+		mbi.cbSize = sizeof(MENUBARINFO);
+		::GetMenuBarInfo(hWnd, OBJID_MENU, 0, &mbi);
+
+		RECT rcWindow{};
+		::GetWindowRect(hWnd, &rcWindow);
+
+		// the rcBar is offset by the window rect
+		RECT rcBar{ mbi.rcBar };
+		::OffsetRect(&rcBar, -rcWindow.left, -rcWindow.top);
+
+		rcBar.top -= 1;
+
+		::FillRect(hdc, &rcBar, DarkMode::getDlgBackgroundBrush());
+	}
+
+	/**
+	 * @brief Paints a single menu bar item with custom colors based on state.
+	 *
+	 * Measures and renders menu item text using `DrawThemeTextEx`, and
+	 * fills background using appropriate brush based on `ODS_*` item state.
+	 *
+	 * @param UDMI Reference to `UAHDRAWMENUITEM` struct from `WM_UAHDRAWMENUITEM`.
+	 * @param hTheme The themed handle to `VSCLASS_MENU` (via @ref ThemeData).
+	 *
+	 * @see DarkMode::WindowMenuBarSubclass()
+	 */
+	static void paintMenuBarItems(UAHDRAWMENUITEM& UDMI, const HTHEME& hTheme)
+	{
+		// get the menu item string
+		std::wstring buffer(MAX_PATH, L'\0');
+		MENUITEMINFO mii{};
+		mii.cbSize = sizeof(MENUITEMINFO);
+		mii.fMask = MIIM_STRING;
+		mii.dwTypeData = buffer.data();
+		mii.cch = MAX_PATH - 1;
+
+		::GetMenuItemInfo(UDMI.um.hmenu, static_cast<UINT>(UDMI.umi.iPosition), TRUE, &mii);
+
+		// get the item state for drawing
+
+		DWORD dwFlags = DT_CENTER | DT_SINGLELINE | DT_VCENTER;
+
+		int iTextStateID = MBI_NORMAL;
+		int iBackgroundStateID = MBI_NORMAL;
+		if ((UDMI.dis.itemState & ODS_SELECTED) == ODS_SELECTED)
+		{
+			// clicked
+			iTextStateID = MBI_PUSHED;
+			iBackgroundStateID = MBI_PUSHED;
+		}
+		else if ((UDMI.dis.itemState & ODS_HOTLIGHT) == ODS_HOTLIGHT)
+		{
+			// hot tracking
+			iTextStateID = ((UDMI.dis.itemState & ODS_INACTIVE) == ODS_INACTIVE) ? MBI_DISABLEDHOT : MBI_HOT;
+			iBackgroundStateID = MBI_HOT;
+		}
+		else if (((UDMI.dis.itemState & ODS_GRAYED) == ODS_GRAYED)
+			|| ((UDMI.dis.itemState & ODS_DISABLED) == ODS_DISABLED)
+			|| ((UDMI.dis.itemState & ODS_INACTIVE) == ODS_INACTIVE))
+		{
+			// disabled / grey text / inactive
+			iTextStateID = MBI_DISABLED;
+			iBackgroundStateID = MBI_DISABLED;
+		}
+		else if ((UDMI.dis.itemState & ODS_DEFAULT) == ODS_DEFAULT)
+		{
+			// normal display
+			iTextStateID = MBI_NORMAL;
+			iBackgroundStateID = MBI_NORMAL;
+		}
+
+		if ((UDMI.dis.itemState & ODS_NOACCEL) == ODS_NOACCEL)
+		{
+			dwFlags |= DT_HIDEPREFIX;
+		}
+
+		switch (iBackgroundStateID)
 		{
-			if (subclassChildren)
+			case MBI_NORMAL:
+			case MBI_DISABLED:
 			{
-				DarkMode::setChildCtrlsSubclassAndTheme(hWnd);
-				if (DarkMode::isWindowsModeEnabled())
-				{
-					DarkMode::setWindowSettingChangeSubclass(hWnd);
-				}
+				::FillRect(UDMI.um.hdc, &UDMI.dis.rcItem, DarkMode::getDlgBackgroundBrush());
+				break;
+			}
+
+			case MBI_HOT:
+			case MBI_DISABLEDHOT:
+			{
+				::FillRect(UDMI.um.hdc, &UDMI.dis.rcItem, DarkMode::getHotBackgroundBrush());
+				break;
+			}
+
+			case MBI_PUSHED:
+			case MBI_DISABLEDPUSHED:
+			{
+				::FillRect(UDMI.um.hdc, &UDMI.dis.rcItem, DarkMode::getCtrlBackgroundBrush());
+				break;
+			}
+
+			default:
+			{
+				::DrawThemeBackground(hTheme, UDMI.um.hdc, MENU_BARITEM, iBackgroundStateID, &UDMI.dis.rcItem, nullptr);
+				break;
 			}
 		}
-	}
 
-	void removeWindowNotifyCustomDrawSubclass(HWND hWnd)
-	{
-		DarkMode::removeSubclass(hWnd, WindowNotifySubclass, kWindowNotifySubclassID);
+		DTTOPTS dttopts{};
+		dttopts.dwSize = sizeof(DTTOPTS);
+		dttopts.dwFlags = DTT_TEXTCOLOR;
+		switch (iTextStateID)
+		{
+			case MBI_NORMAL:
+			case MBI_HOT:
+			case MBI_PUSHED:
+			{
+				dttopts.crText = DarkMode::getTextColor();
+				break;
+			}
+
+			case MBI_DISABLED:
+			case MBI_DISABLEDHOT:
+			case MBI_DISABLEDPUSHED:
+			{
+				dttopts.crText = DarkMode::getDisabledTextColor();
+				break;
+			}
+
+			default:
+			{
+				break;
+			}
+		}
+
+		::DrawThemeTextEx(hTheme, UDMI.um.hdc, MENU_BARITEM, iTextStateID, buffer.c_str(), static_cast<int>(mii.cch), dwFlags, &UDMI.dis.rcItem, &dttopts);
 	}
 
+	/**
+	 * @brief Over-paints the 1-pixel light line under a menu bar with custom color.
+	 *
+	 * Called post-paint to overwrite non-client leftovers that break custom color styling.
+	 * Computes exact line position based on `MenuBarInfo`, and fills with custom color.
+	 *
+	 * @param hWnd Handle to the window with a menu bar.
+	 *
+	 * @see DarkMode::WindowMenuBarSubclass()
+	 */
 	static void drawUAHMenuNCBottomLine(HWND hWnd)
 	{
 		MENUBARINFO mbi{};
@@ -5347,6 +6905,22 @@ namespace DarkMode
 		::ReleaseDC(hWnd, hdc);
 	}
 
+	/**
+	 * @brief Window subclass procedure for custom color for themed menu bar.
+	 *
+	 * Applies custom colors for menu bar, but not for popup menus.
+	 *
+	 * @param hWnd Window handle being subclassed.
+	 * @param uMsg Message identifier.
+	 * @param wParam Message-specific data.
+	 * @param lParam Message-specific data.
+	 * @param uIdSubclass Subclass identifier.
+	 * @param dwRefData ThemeData instance.
+	 * @return LRESULT Result of message processing.
+	 *
+	 * @see DarkMode::setWindowMenuBarSubclass()
+	 * @see DarkMode::removeWindowMenuBarSubclass()
+	 */
 	static LRESULT CALLBACK WindowMenuBarSubclass(
 		HWND hWnd,
 		UINT uMsg,
@@ -5375,22 +6949,7 @@ namespace DarkMode
 			case WM_UAHDRAWMENU:
 			{
 				auto* pUDM = reinterpret_cast<UAHMENU*>(lParam);
-
-				// get the menubar rect
-				MENUBARINFO mbi{};
-				mbi.cbSize = sizeof(MENUBARINFO);
-				::GetMenuBarInfo(hWnd, OBJID_MENU, 0, &mbi);
-
-				RECT rcWindow{};
-				::GetWindowRect(hWnd, &rcWindow);
-
-				// the rcBar is offset by the window rect
-				RECT rcBar{ mbi.rcBar };
-				::OffsetRect(&rcBar, -rcWindow.left, -rcWindow.top);
-
-				rcBar.top -= 1;
-
-				::FillRect(pUDM->hdc, &rcBar, DarkMode::getDlgBackgroundBrush());
+				DarkMode::paintMenuBar(hWnd, pUDM->hdc);
 
 				return 0;
 			}
@@ -5398,124 +6957,19 @@ namespace DarkMode
 			case WM_UAHDRAWMENUITEM:
 			{
 				const auto& hTheme = pMenuThemeData->getHTheme();
-
 				auto* pUDMI = reinterpret_cast<UAHDRAWMENUITEM*>(lParam);
-
-				// get the menu item string
-				std::wstring buffer(MAX_PATH, L'\0');
-				MENUITEMINFO mii{};
-				mii.cbSize = sizeof(MENUITEMINFO);
-				mii.fMask = MIIM_STRING;
-				mii.dwTypeData = buffer.data();
-				mii.cch = MAX_PATH - 1;
-
-				::GetMenuItemInfo(pUDMI->um.hmenu, static_cast<UINT>(pUDMI->umi.iPosition), TRUE, &mii);
-
-				// get the item state for drawing
-
-				DWORD dwFlags = DT_CENTER | DT_SINGLELINE | DT_VCENTER;
-
-				int iTextStateID = MBI_NORMAL;
-				int iBackgroundStateID = MBI_NORMAL;
-				if ((pUDMI->dis.itemState & ODS_SELECTED) == ODS_SELECTED)
-				{
-					// clicked
-					iTextStateID = MBI_PUSHED;
-					iBackgroundStateID = MBI_PUSHED;
-				}
-				else if ((pUDMI->dis.itemState & ODS_HOTLIGHT) == ODS_HOTLIGHT)
-				{
-					// hot tracking
-					iTextStateID = ((pUDMI->dis.itemState & ODS_INACTIVE) == ODS_INACTIVE) ? MBI_DISABLEDHOT : MBI_HOT;
-					iBackgroundStateID = MBI_HOT;
-				}
-				else if (((pUDMI->dis.itemState & ODS_GRAYED) == ODS_GRAYED)
-					|| ((pUDMI->dis.itemState & ODS_DISABLED) == ODS_DISABLED)
-					|| ((pUDMI->dis.itemState & ODS_INACTIVE) == ODS_INACTIVE))
-				{
-					// disabled / grey text / inactive
-					iTextStateID = MBI_DISABLED;
-					iBackgroundStateID = MBI_DISABLED;
-				}
-				else if ((pUDMI->dis.itemState & ODS_DEFAULT) == ODS_DEFAULT)
-				{
-					// normal display
-					iTextStateID = MBI_NORMAL;
-					iBackgroundStateID = MBI_NORMAL;
-				}
-
-				if ((pUDMI->dis.itemState & ODS_NOACCEL) == ODS_NOACCEL)
-				{
-					dwFlags |= DT_HIDEPREFIX;
-				}
-
-				switch (iBackgroundStateID)
-				{
-					case MBI_NORMAL:
-					case MBI_DISABLED:
-					{
-						::FillRect(pUDMI->um.hdc, &pUDMI->dis.rcItem, DarkMode::getDlgBackgroundBrush());
-						break;
-					}
-
-					case MBI_HOT:
-					case MBI_DISABLEDHOT:
-					{
-						::FillRect(pUDMI->um.hdc, &pUDMI->dis.rcItem, DarkMode::getHotBackgroundBrush());
-						break;
-					}
-
-					case MBI_PUSHED:
-					case MBI_DISABLEDPUSHED:
-					{
-						::FillRect(pUDMI->um.hdc, &pUDMI->dis.rcItem, DarkMode::getCtrlBackgroundBrush());
-						break;
-					}
-
-					default:
-					{
-						::DrawThemeBackground(hTheme, pUDMI->um.hdc, MENU_BARITEM, iBackgroundStateID, &pUDMI->dis.rcItem, nullptr);
-						break;
-					}
-				}
-
-				DTTOPTS dttopts{};
-				dttopts.dwSize = sizeof(DTTOPTS);
-				dttopts.dwFlags = DTT_TEXTCOLOR;
-				switch (iTextStateID)
-				{
-					case MBI_NORMAL:
-					case MBI_HOT:
-					case MBI_PUSHED:
-					{
-						dttopts.crText = DarkMode::getTextColor();
-						break;
-					}
-
-					case MBI_DISABLED:
-					case MBI_DISABLEDHOT:
-					case MBI_DISABLEDPUSHED:
-					{
-						dttopts.crText = DarkMode::getDisabledTextColor();
-						break;
-					}
-
-					default:
-					{
-						break;
-					}
-				}
-
-				::DrawThemeTextEx(hTheme, pUDMI->um.hdc, MENU_BARITEM, iTextStateID, buffer.c_str(), static_cast<int>(mii.cch), dwFlags, &pUDMI->dis.rcItem, &dttopts);
+				DarkMode::paintMenuBarItems(*pUDMI, hTheme);
 
 				return 0;
 			}
 
+#if 0 // for debugging
 			case WM_UAHMEASUREMENUITEM:
 			{
-				//auto pMMI = reinterpret_cast<UAHMEASUREMENUITEM*>(lParam);
+				auto* pMMI = reinterpret_cast<UAHMEASUREMENUITEM*>(lParam);
 				return ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
 			}
+#endif
 
 			case WM_DPICHANGED:
 			case WM_DPICHANGED_AFTERPARENT:
@@ -5541,23 +6995,61 @@ namespace DarkMode
 		return ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
 	}
 
+	/**
+	 * @brief Applies window subclassing for menu bar themed custom drawing.
+	 *
+	 * Installs @ref DarkMode::WindowMenuBarSubclass with an associated `ThemeData` instance
+	 * for the `VSCLASS_MENU` visual style. Enables custom drawing
+	 * behavior for menu bar.
+	 *
+	 * @param hWnd Handle to the window with a menu bar.
+	 *
+	 * @see DarkMode::WindowMenuBarSubclass()
+	 * @see DarkMode::removeWindowMenuBarSubclass()
+	 */
 	void setWindowMenuBarSubclass(HWND hWnd)
 	{
 		DarkMode::setSubclass<ThemeData>(hWnd, WindowMenuBarSubclass, kWindowMenuBarSubclassID, VSCLASS_MENU);
 	}
 
+	/**
+	 * @brief Removes the subclass used for menu bar themed custom drawing.
+	 *
+	 * Detaches the window's subclass proc used for menu bar themed custom drawing.
+	 *
+	 * @param hWnd Handle to the previously subclassed window.
+	 *
+	 * @see DarkMode::WindowMenuBarSubclass()
+	 * @see DarkMode::setWindowMenuBarSubclass()
+	 */
 	void removeWindowMenuBarSubclass(HWND hWnd)
 	{
 		DarkMode::removeSubclass<ThemeData>(hWnd, WindowMenuBarSubclass, kWindowMenuBarSubclassID);
 	}
 
+	/**
+	 * @brief Window subclass procedure for handling `WM_SETTINGCHANGE` message.
+	 *
+	 * Handles `WM_SETTINGCHANGE` to perform changes for dark mode based on system setting.
+	 *
+	 * @param hWnd Window handle being subclassed.
+	 * @param uMsg Message identifier.
+	 * @param wParam Message-specific data.
+	 * @param lParam Message-specific data.
+	 * @param uIdSubclass Subclass identifier.
+	 * @param dwRefData Reserved data (unused).
+	 * @return LRESULT Result of message processing.
+	 *
+	 * @see DarkMode::setWindowSettingChangeSubclass()
+	 * @see DarkMode::removeWindowSettingChangeSubclass()
+	 */
 	static LRESULT CALLBACK WindowSettingChangeSubclass(
 		HWND hWnd,
 		UINT uMsg,
 		WPARAM wParam,
 		LPARAM lParam,
 		UINT_PTR uIdSubclass,
-		DWORD_PTR /*dwRefData*/
+		[[maybe_unused]] DWORD_PTR dwRefData
 	)
 	{
 		switch (uMsg)
@@ -5574,7 +7066,7 @@ namespace DarkMode
 				{
 					DarkMode::setDarkTitleBarEx(hWnd, true);
 					DarkMode::setChildCtrlsTheme(hWnd);
-					::RedrawWindow(hWnd, nullptr, nullptr, RDW_INVALIDATE | RDW_ERASE | RDW_ALLCHILDREN | RDW_UPDATENOW);
+					::RedrawWindow(hWnd, nullptr, nullptr, RDW_INVALIDATE | RDW_ERASE | RDW_ALLCHILDREN | RDW_UPDATENOW | RDW_FRAME);
 				}
 				break;
 			}
@@ -5587,16 +7079,48 @@ namespace DarkMode
 		return ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
 	}
 
+	/**
+	 * @brief Applies window subclassing to handle `WM_SETTINGCHANGE` message.
+	 *
+	 * Enable monitoring WM_SETTINGCHANGE message,
+	 * allowing the app to respond to system-wide dark mode change.
+	 *
+	 * @param hWnd Handle to the main window.
+	 *
+	 * @see DarkMode::WindowSettingChangeSubclass()
+	 * @see DarkMode::removeWindowSettingChangeSubclass()
+	 */
 	void setWindowSettingChangeSubclass(HWND hWnd)
 	{
 		DarkMode::setSubclass(hWnd, WindowSettingChangeSubclass, kWindowSettingChangeSubclassID);
 	}
 
+	/**
+	 * @brief Removes the subclass used for `WM_SETTINGCHANGE` message handling.
+	 *
+	 * Detaches the window's subclass proc used for `WM_SETTINGCHANGE` messages handling.
+	 *
+	 * @param hWnd Handle to the previously subclassed window.
+	 *
+	 * @see DarkMode::WindowSettingChangeSubclass()
+	 * @see DarkMode::setWindowSettingChangeSubclass()
+	 */
 	void removeWindowSettingChangeSubclass(HWND hWnd)
 	{
 		DarkMode::removeSubclass(hWnd, WindowSettingChangeSubclass, kWindowSettingChangeSubclassID);
 	}
 
+	/**
+	 * @brief Configures the SysLink control to be affected by `WM_CTLCOLORSTATIC` message.
+	 *
+	 * Configures the first hyperlink item (index 0)
+	 * to either use default system link colors if in classic mode,
+	 * or to be affected by `WM_CTLCOLORSTATIC` message from its parent.
+	 *
+	 * @param hWnd Handle to the SysLink control.
+	 *
+	 * @note Currently affects only the first link (index 0).
+	 */
 	void enableSysLinkCtrlCtlColor(HWND hWnd)
 	{
 		LITEM item{};
@@ -5607,6 +7131,30 @@ namespace DarkMode
 		::SendMessage(hWnd, LM_SETITEM, 0, reinterpret_cast<LPARAM>(&item));
 	}
 
+	/**
+	 * @brief Sets dark title bar and optional Windows 11 features.
+	 *
+	 * For Windows 10 (2004+) and newer, this function configures the dark title bar using
+	 * `DWMWA_USE_IMMERSIVE_DARK_MODE`. On Windows 11, if `useWin11Features` is `true`, it
+	 * additionally applies:
+	 * - Rounded corners (`DWMWA_WINDOW_CORNER_PREFERENCE`)
+	 * - Border color (`DWMWA_BORDER_COLOR`)
+	 * - Mica backdrop (`DWMWA_SYSTEMBACKDROP_TYPE`) if allowed and compatible
+	 * - Static text color for text and dialog background color for background
+	 *   (`DWMWA_CAPTION_COLOR`, `DWMWA_TEXT_COLOR`),
+	 *   only when frames are not extended to full window
+	 *
+	 * If `_DARKMODELIB_ALLOW_OLD_OS` is defined and running on pre-2004 builds,
+	 * fallback behavior will enable dark title bars via undocumented APIs.
+	 *
+	 * @param hWnd Handle to the top-level window.
+	 * @param useWin11Features `true` to enable Windows 11 specific features such as Mica and rounded corners.
+	 *
+	 * @note Requires Windows 10 version 2004 (build 19041) or later.
+	 *
+	 * @see DwmSetWindowAttribute
+	 * @see DwmExtendFrameIntoClientArea
+	 */
 	void setDarkTitleBarEx(HWND hWnd, bool useWin11Features)
 	{
 		static constexpr DWORD win10Build2004 = 19041;
@@ -5616,11 +7164,13 @@ namespace DarkMode
 			const BOOL useDark = DarkMode::isExperimentalActive() ? TRUE : FALSE;
 			::DwmSetWindowAttribute(hWnd, DWMWA_USE_IMMERSIVE_DARK_MODE, &useDark, sizeof(useDark));
 
-			if (useWin11Features && DarkMode::isWindows11())
+			if (useWin11Features && DarkMode::isAtLeastWindows11())
 			{
 				::DwmSetWindowAttribute(hWnd, DWMWA_WINDOW_CORNER_PREFERENCE, &g_dmCfg._roundCorner, sizeof(g_dmCfg._roundCorner));
 				::DwmSetWindowAttribute(hWnd, DWMWA_BORDER_COLOR, &g_dmCfg._borderColor, sizeof(g_dmCfg._borderColor));
 
+				bool canColorizeTitleBar = true;
+
 				if (DarkMode::getWindowsBuildNumber() >= win11Mica)
 				{
 					if (g_dmCfg._micaExtend && g_dmCfg._mica != DWMSBT_AUTO && !DarkMode::isWindowsModeEnabled() && (g_dmCfg._dmType == DarkModeType::dark))
@@ -5630,7 +7180,15 @@ namespace DarkMode
 					}
 
 					::DwmSetWindowAttribute(hWnd, DWMWA_SYSTEMBACKDROP_TYPE, &g_dmCfg._mica, sizeof(g_dmCfg._mica));
+
+					canColorizeTitleBar = !g_dmCfg._micaExtend;
 				}
+
+				canColorizeTitleBar = g_dmCfg._colorizeTitleBar && canColorizeTitleBar && DarkMode::isEnabled();
+				const COLORREF clrDlg = canColorizeTitleBar ? DarkMode::getDlgBackgroundColor() : DWMWA_COLOR_DEFAULT;
+				const COLORREF clrText = canColorizeTitleBar ? DarkMode::getTextColor() : DWMWA_COLOR_DEFAULT;
+				::DwmSetWindowAttribute(hWnd, DWMWA_CAPTION_COLOR, &clrDlg, sizeof(clrDlg));
+				::DwmSetWindowAttribute(hWnd, DWMWA_TEXT_COLOR, &clrText, sizeof(clrText));
 			}
 		}
 #if defined(_DARKMODELIB_ALLOW_OLD_OS)
@@ -5642,41 +7200,133 @@ namespace DarkMode
 #endif
 	}
 
+	/**
+	 * @brief Sets dark mode title bar on supported Windows versions.
+	 *
+	 * Delegates to @ref setDarkTitleBarEx with `useWin11Features = false`.
+	 *
+	 * @param hWnd Handle to the top-level window.
+	 *
+	 * @see DarkMode::setDarkTitleBarEx()
+	 */
 	void setDarkTitleBar(HWND hWnd)
 	{
 		DarkMode::setDarkTitleBarEx(hWnd, false);
 	}
 
+	/**
+	 * @brief Applies an experimental visual style to the specified window, if supported.
+	 *
+	 * When experimental features are supported and active,
+	 * this function enables dark experimental visual style on the window.
+	 *
+	 * @param hWnd Handle to the target window or control.
+	 * @param themeClassName Name of the theme class to apply (e.g. L"Explorer", "ItemsView").
+	 *
+	 * @note This function is a no-op if experimental theming is not supported on the current OS.
+	 *
+	 * @see DarkMode::isExperimentalSupported()
+	 * @see DarkMode::isExperimentalActive()
+	 * @see DarkMode::allowDarkModeForWindow()
+	 */
+	void setDarkThemeExperimental(HWND hWnd, const wchar_t* themeClassName)
+	{
+		if (DarkMode::isExperimentalSupported())
+		{
+			DarkMode::allowDarkModeForWindow(hWnd, DarkMode::isExperimentalActive());
+			::SetWindowTheme(hWnd, themeClassName, nullptr);
+		}
+	}
+
+	/**
+	 * @brief Applies "DarkMode_Explorer" visual style if experimental mode is active.
+	 *
+	 * Useful for controls like list views or tree views to use dark scroll bars
+	 * and explorer style theme in supported environments.
+	 *
+	 * @param hWnd Handle to the control or window to theme.
+	 */
 	void setDarkExplorerTheme(HWND hWnd)
 	{
 		::SetWindowTheme(hWnd, DarkMode::isExperimentalActive() ? L"DarkMode_Explorer" : nullptr, nullptr);
 	}
 
+	/**
+	 * @brief Applies "DarkMode_Explorer" visual style to scroll bars.
+	 *
+	 * Convenience wrapper that calls @ref DarkMode::setDarkExplorerTheme to apply dark scroll bar
+	 * for compatible controls (e.g. list views, tree views).
+	 *
+	 * @param hWnd Handle to the control with scroll bars.
+	 *
+	 * @see DarkMode::setDarkExplorerTheme()
+	 */
 	void setDarkScrollBar(HWND hWnd)
 	{
 		DarkMode::setDarkExplorerTheme(hWnd);
 	}
 
+	/**
+	 * @brief Applies "DarkMode_Explorer" visual style to tooltip controls based on context.
+	 *
+	 * Selects the appropriate `GETTOOLTIPS` message depending on the control type
+	 * (e.g. toolbar, list view, tree view, tab bar) to retrieve the tooltip handle.
+	 * If `ToolTipsType::tooltip` is specified, applies theming directly to `hWnd`.
+	 *
+	 * Internally calls @ref DarkMode::setDarkExplorerTheme to set dark tooltip.
+	 *
+	 * @param hWnd Handle to the parent control or tooltip.
+	 * @param type The tooltip context type (toolbar, list view, etc.).
+	 *
+	 * @see DarkMode::setDarkExplorerTheme()
+	 * @see ToolTipsType
+	 */
 	void setDarkTooltips(HWND hWnd, ToolTipsType type)
 	{
 		UINT msg = 0;
 		switch (type)
 		{
 			case DarkMode::ToolTipsType::toolbar:
+			{
 				msg = TB_GETTOOLTIPS;
 				break;
+			}
+
 			case DarkMode::ToolTipsType::listview:
+			{
 				msg = LVM_GETTOOLTIPS;
 				break;
+			}
+
 			case DarkMode::ToolTipsType::treeview:
+			{
 				msg = TVM_GETTOOLTIPS;
 				break;
+			}
+
 			case DarkMode::ToolTipsType::tabbar:
+			{
 				msg = TCM_GETTOOLTIPS;
 				break;
+			}
+
+			case DarkMode::ToolTipsType::trackbar:
+			{
+				msg = TBM_GETTOOLTIPS;
+				break;
+			}
+
+			case DarkMode::ToolTipsType::rebar:
+			{
+				msg = RB_GETTOOLTIPS;
+				break;
+			}
+
 			case DarkMode::ToolTipsType::tooltip:
+			{
 				msg = 0;
 				break;
+			}
 		}
 
 		if (msg == 0)
@@ -5693,6 +7343,15 @@ namespace DarkMode
 		}
 	}
 
+	/**
+	 * @brief Sets the color of line above a toolbar control for non-classic mode.
+	 *
+	 * Sends `TB_SETCOLORSCHEME` to customize the line drawn above the toolbar.
+	 * When non-classic mode is enabled, sets both `clrBtnHighlight` and `clrBtnShadow`
+	 * to the dialog background color, otherwise uses system defaults.
+	 *
+	 * @param hWnd Handle to the toolbar control.
+	 */
 	void setDarkLineAbovePanelToolbar(HWND hWnd)
 	{
 		COLORSCHEME scheme{};
@@ -5712,20 +7371,38 @@ namespace DarkMode
 		::SendMessage(hWnd, TB_SETCOLORSCHEME, 0, reinterpret_cast<LPARAM>(&scheme));
 	}
 
-	void setDarkHeader(HWND hWnd)
-	{
-		//DarkMode::setDarkThemeExperimental(hWnd, L"ItemsView");
-		DarkMode::setHeaderCtrlSubclass(hWnd);
-	}
-
+	/**
+	 * @brief Applies an experimental Explorer visual style to a list view.
+	 *
+	 * Uses @ref DarkMode::setDarkThemeExperimental with the `"Explorer"` theme class to adapt
+	 * list view visuals (e.g. scroll bars, selection color) for dark mode, if supported.
+	 *
+	 * @param hWnd Handle to the list view control.
+	 *
+	 * @see DarkMode::setDarkThemeExperimental()
+	 */
 	void setDarkListView(HWND hWnd)
 	{
 		DarkMode::setDarkThemeExperimental(hWnd, L"Explorer");
 	}
 
+	/**
+	 * @brief Replaces default list view checkboxes with themed dark-mode versions on Windows 11.
+	 *
+	 * If the list view uses `LVS_EX_CHECKBOXES` and is running on Windows 11 or later,
+	 * this function manually renders the unchecked and checked checkbox visuals using
+	 * themed drawing APIs, then inserts the resulting icons into the state image list.
+	 *
+	 * Uses `"DarkMode_Explorer::Button"` as the theme class if experimental dark mode is active;
+	 * otherwise falls back to `VSCLASS_BUTTON`.
+	 *
+	 * @param hWnd Handle to the list view control with extended checkbox style.
+	 *
+	 * @note Does nothing on pre-Windows 11 systems or if checkboxes are not enabled.
+	 */
 	void setDarkListViewCheckboxes(HWND hWnd)
 	{
-		if (!DarkMode::isWindows11())
+		if (!DarkMode::isAtLeastWindows11())
 		{
 			return;
 		}
@@ -5794,15 +7471,25 @@ namespace DarkMode
 		::ReleaseDC(nullptr, hdc);
 	}
 
-	void setDarkThemeExperimental(HWND hWnd, const wchar_t* themeClassName)
-	{
-		if (DarkMode::isExperimentalSupported())
-		{
-			DarkMode::allowDarkModeForWindow(hWnd, DarkMode::isExperimentalActive());
-			::SetWindowTheme(hWnd, themeClassName, nullptr);
-		}
-	}
-
+	/**
+	 * @brief Sets colors and edges for a RichEdit control.
+	 *
+	 * Determines if the control has `WS_BORDER` or `WS_EX_STATICEDGE`, and sets the background
+	 * accordingly: uses control background color when edged, otherwise dialog background.
+	 *
+	 * In dark mode:
+	 * - Sets background color via `EM_SETBKGNDCOLOR`
+	 * - Updates default text color via `EM_SETCHARFORMAT`
+	 * - Applies themed scroll bars using `DarkMode_Explorer::ScrollBar`
+	 *
+	 * When not in dark mode, restores default visual styles and coloring.
+	 * Also conditionally swaps `WS_BORDER` and `WS_EX_STATICEDGE`.
+	 *
+	 * @param hWnd Handle to the RichEdit control.
+	 *
+	 * @see DarkMode::setWindowStyle()
+	 * @see DarkMode::setWindowExStyle()
+	 */
 	void setDarkRichEdit(HWND hWnd)
 	{
 		const auto nStyle = ::GetWindowLongPtr(hWnd, GWL_STYLE);
@@ -5836,7 +7523,28 @@ namespace DarkMode
 		DarkMode::setWindowExStyle(hWnd, !DarkMode::isEnabled() && hasBorder, WS_EX_STATICEDGE);
 	}
 
-	void setDarkDlgSafe(HWND hWnd, bool useWin11Features)
+	/**
+	 * @brief Applies visual styles; ctl color message and child controls subclassings to a window safely.
+	 *
+	 * Ensures the specified window is not `nullptr` and then:
+	 * - Enables the dark title bar
+	 * - Subclasses the window for control ctl coloring
+	 * - Applies theming and subclassing to child controls
+	 *
+	 *
+	 * @param hWnd Handle to the window. No action taken if `nullptr`.
+	 * @param useWin11Features `true` to enable Windows 11 specific styling like Mica or rounded corners.
+	 *
+	 * @note Should not be used in combination with @ref DarkMode::setDarkWndNotifySafeEx
+	 *       and @ref DarkMode::setDarkWndNotifySafe to avoid overlapping styling logic.
+	 *
+	 * @see DarkMode::setDarkWndNotifySafeEx()
+	 * @see DarkMode::setDarkWndNotifySafe()
+	 * @see DarkMode::setDarkTitleBarEx()
+	 * @see DarkMode::setWindowCtlColorSubclass()
+	 * @see DarkMode::setChildCtrlsSubclassAndTheme()
+	 */
+	void setDarkWndSafe(HWND hWnd, bool useWin11Features)
 	{
 		if (hWnd == nullptr)
 		{
@@ -5844,12 +7552,39 @@ namespace DarkMode
 		}
 
 		DarkMode::setDarkTitleBarEx(hWnd, useWin11Features);
-		//DarkMode::setWindowEraseBgSubclass(hWnd);
 		DarkMode::setWindowCtlColorSubclass(hWnd);
 		DarkMode::setChildCtrlsSubclassAndTheme(hWnd);
 	}
 
-	void setDarkDlgNotifySafe(HWND hWnd, bool useWin11Features)
+	/**
+	 * @brief Applies visual styles; ctl color message, child controls, custom drawing, and setting change subclassings to a window safely.
+	 *
+	 * Ensures the specified window is not `nullptr` and then:
+	 * - Enables the dark title bar
+	 * - Subclasses the window for control coloring
+	 * - Applies theming and subclassing to child controls
+	 * - Enables custom draw-based theming via notification subclassing
+	 * - Subclasses the window to handle dark mode change if window mode is enabled.
+	 *
+	 * @param hWnd Handle to the window. No action taken if `nullptr`.
+	 * @param setSettingChangeSubclass `true` to set setting change subclass if applicable.
+	 * @param useWin11Features `true` to enable Windows 11 specific styling like Mica or rounded corners.
+	 *
+	 * @note `setSettingChangeSubclass = true` should be used only on main window.
+	 *       For other secondary windows and controls use @ref DarkMode::setDarkWndNotifySafe.
+	 *       Should not be used in combination with @ref DarkMode::setDarkWndSafe
+	 *       and @ref DarkMode::setDarkWndNotifySafe to avoid overlapping styling logic.
+	 *
+	 * @see DarkMode::setDarkWndNotifySafe()
+	 * @see DarkMode::setDarkWndSafe()
+	 * @see DarkMode::setDarkTitleBarEx()
+	 * @see DarkMode::setWindowCtlColorSubclass()
+	 * @see DarkMode::setWindowNotifyCustomDrawSubclass()
+	 * @see DarkMode::setChildCtrlsSubclassAndTheme()
+	 * @see DarkMode::isWindowsModeEnabled()
+	 * @see DarkMode::setWindowSettingChangeSubclass()
+	 */
+	void setDarkWndNotifySafeEx(HWND hWnd, bool setSettingChangeSubclass, bool useWin11Features)
 	{
 		if (hWnd == nullptr)
 		{
@@ -5857,16 +7592,63 @@ namespace DarkMode
 		}
 
 		DarkMode::setDarkTitleBarEx(hWnd, useWin11Features);
-		//DarkMode::setWindowEraseBgSubclass(hWnd);
 		DarkMode::setWindowCtlColorSubclass(hWnd);
-		DarkMode::setWindowNotifyCustomDrawSubclass(hWnd, true);
-	}
-
+		DarkMode::setWindowNotifyCustomDrawSubclass(hWnd);
+		DarkMode::setChildCtrlsSubclassAndTheme(hWnd);
+		if (setSettingChangeSubclass && DarkMode::isWindowsModeEnabled())
+		{
+			DarkMode::setWindowSettingChangeSubclass(hWnd);
+		}
+	}
+
+	/**
+	 * @brief Applies visual styles; ctl color message, child controls, and custom drawing subclassings to a window safely.
+	 *
+	 * Calls @ref DarkMode::setDarkWndNotifySafeEx with `setSettingChangeSubclass = false`, streamlining
+	 * dark mode setup for secondary or transient windows that don't need to track system dark mode changes.
+	 *
+	 * @param hWnd Handle to the target window.
+	 * @param useWin11Features Enable Windows 11-specific visual effects (e.g., Mica, rounded corners).
+	 *
+	 * @note Should not be used in combination with @ref DarkMode::setDarkWndSafe
+	 *       and @ref DarkMode::setDarkWndNotifySafeEx to avoid overlapping styling logic.
+	 *
+	 * @see DarkMode::setDarkWndNotifySafeEx()
+	 * @see DarkMode::setDarkWndSafe()
+	 */
+	void setDarkWndNotifySafe(HWND hWnd, bool useWin11Features)
+	{
+		DarkMode::setDarkWndNotifySafeEx(hWnd, false, useWin11Features);
+	}
+
+	/**
+	 * @brief Enables or disables theme-based dialog background textures in classic mode.
+	 *
+	 * Applies `ETDT_ENABLETAB` only when `theme` is `true` and the current mode is classic.
+	 * This replaces the default classic gray background with a lighter themed texture.
+	 * Otherwise disables themed dialog textures with `ETDT_DISABLE`.
+	 *
+	 * @param hWnd Handle to the target dialog window.
+	 * @param theme `true` to enable themed tab textures in classic mode.
+	 *
+	 * @see EnableThemeDialogTexture
+	 */
 	void enableThemeDialogTexture(HWND hWnd, bool theme)
 	{
 		::EnableThemeDialogTexture(hWnd, theme && (g_dmCfg._dmType == DarkModeType::classic) ? ETDT_ENABLETAB : ETDT_DISABLE);
 	}
 
+	/**
+	 * @brief Enables or disables visual styles for a window.
+	 *
+	 * Applies `SetWindowTheme(hWnd, L"", L"")` when `doDisable` is `true`, effectively removing
+	 * the current theme. Restores default theming when `doDisable` is `false`.
+	 *
+	 * @param hWnd Handle to the window.
+	 * @param doDisable `true` to strip visual styles, `false` to re-enable them.
+	 *
+	 * @see SetWindowTheme
+	 */
 	void disableVisualStyle(HWND hWnd, bool doDisable)
 	{
 		if (doDisable)
@@ -5879,7 +7661,16 @@ namespace DarkMode
 		}
 	}
 
-	// adapted from https://stackoverflow.com/a/56678483
+	/**
+	 * @brief Calculates perceptual lightness of a COLORREF color.
+	 *
+	 * Converts the RGB color to linear space and calculates perceived lightness.
+	 *
+	 * @param clr COLORREF in 0xBBGGRR format.
+	 * @return Lightness value as a double.
+	 *
+	 * @note Based on: https://stackoverflow.com/a/56678483
+	 */
 	double calculatePerceivedLightness(COLORREF clr)
 	{
 		auto linearValue = [](double colorChannel) -> double {
@@ -5923,51 +7714,88 @@ namespace DarkMode
 		return ((std::pow(luminance, oneThird) * scalingFactor) - offset);
 	}
 
+	/**
+	 * @brief Retrieves the current TreeView style configuration.
+	 *
+	 * @return Reference to the current `TreeViewStyle`.
+	 */
+	const TreeViewStyle& getTreeViewStyle()
+	{
+		return g_dmCfg._tvStyle;
+	}
+
+	/// Set TreeView style
+	static void setTreeViewStyle(TreeViewStyle tvStyle)
+	{
+		g_dmCfg._tvStyle = tvStyle;
+	}
+
+	/**
+	 * @brief Determines appropriate TreeView style based on background perceived lightness.
+	 *
+	 * Checks the perceived lightness of the current view background and
+	 * selects a corresponding style: dark, light, or classic. Style selection
+	 * is based on how far the lightness deviates from the middle gray threshold range
+	 * around the midpoint value (50.0).
+	 *
+	 * @see DarkMode::calculatePerceivedLightness()
+	 */
 	void calculateTreeViewStyle()
 	{
 		static constexpr double middle = 50.0;
 		const COLORREF bgColor = DarkMode::getViewBackgroundColor();
 
-		if (g_tvCfg._background != bgColor || g_tvCfg._lightness == middle)
+		if (g_dmCfg._tvBackground != bgColor || g_dmCfg._lightness == middle)
 		{
-			g_tvCfg._lightness = calculatePerceivedLightness(bgColor);
-			g_tvCfg._background = bgColor;
+			g_dmCfg._lightness = DarkMode::calculatePerceivedLightness(bgColor);
+			g_dmCfg._tvBackground = bgColor;
 		}
 
-		if (g_tvCfg._lightness < (middle - MiddleGrayRange))
+		if (g_dmCfg._lightness < (middle - kMiddleGrayRange))
 		{
-			g_dmCfg._treeViewStyle = TreeViewStyle::dark;
+			DarkMode::setTreeViewStyle(TreeViewStyle::dark);
 		}
-		else if (g_tvCfg._lightness > (middle + MiddleGrayRange))
+		else if (g_dmCfg._lightness > (middle + kMiddleGrayRange))
 		{
-			g_dmCfg._treeViewStyle = TreeViewStyle::light;
+			DarkMode::setTreeViewStyle(TreeViewStyle::light);
 		}
 		else
 		{
-			g_dmCfg._treeViewStyle = TreeViewStyle::classic;
-		}
-	}
-
-	void updatePrevTreeViewStyle()
-	{
-		g_tvCfg._stylePrev = g_dmCfg._treeViewStyle;
-	}
-
-	TreeViewStyle getTreeViewStyle()
-	{
-		return g_dmCfg._treeViewStyle;
-	}
-
-	void setTreeViewStyle(HWND hWnd, bool force)
-	{
-		if (force || g_tvCfg._stylePrev != g_dmCfg._treeViewStyle)
+			DarkMode::setTreeViewStyle(TreeViewStyle::classic);
+		}
+	}
+
+	/**
+	 * @brief Applies the appropriate window theme style to the specified TreeView.
+	 *
+	 * Updates the TreeView's visual behavior and theme based on the currently selected
+	 * style @ref DarkMode::getTreeViewStyle. It conditionally adjusts the `TVS_TRACKSELECT`
+	 * style flag and applies a matching visual theme using `SetWindowTheme()`.
+	 *
+	 * If `force` is `true`, the style is applied regardless of previous state.
+	 * Otherwise, the update occurs only if the style has changed since the last update.
+	 *
+	 * - `light`: Enables `TVS_TRACKSELECT`, applies "Explorer" theme.
+	 * - `dark`: If supported, enables `TVS_TRACKSELECT`, applies "DarkMode_Explorer" theme.
+	 * - `classic`: Disables `TVS_TRACKSELECT`, clears the theme.
+	 *
+	 * @param hWnd Handle to the TreeView control.
+	 * @param force Whether to forcibly reapply the style even if unchanged.
+	 *
+	 * @see TreeViewStyle
+	 * @see DarkMode::getTreeViewStyle()
+	 * @see DarkMode::getPrevTreeViewStyle()
+	 */
+	void setTreeViewWindowTheme(HWND hWnd, bool force)
+	{
+		if (force || DarkMode::getPrevTreeViewStyle() != DarkMode::getTreeViewStyle())
 		{
 			auto nStyle = ::GetWindowLongPtr(hWnd, GWL_STYLE);
 			const bool hasHotStyle = (nStyle & TVS_TRACKSELECT) == TVS_TRACKSELECT;
 			bool change = false;
 			std::wstring strSubAppName;
 
-			switch (g_dmCfg._treeViewStyle)
+			switch (DarkMode::getTreeViewStyle())
 			{
 				case TreeViewStyle::light:
 				{
@@ -6016,16 +7844,79 @@ namespace DarkMode
 		}
 	}
 
+	/**
+	 * @brief Retrieves the previous TreeView style configuration.
+	 *
+	 * @return Reference to the previous `TreeViewStyle`.
+	 */
+	const TreeViewStyle& getPrevTreeViewStyle()
+	{
+		return g_dmCfg._tvStylePrev;
+	}
+
+	/**
+	 * @brief Stores the current TreeView style as the previous style for later comparison.
+	 */
+	void setPrevTreeViewStyle()
+	{
+		g_dmCfg._tvStylePrev = DarkMode::getTreeViewStyle();
+	}
+
+	/**
+	 * @brief Checks whether the current theme is dark.
+	 *
+	 * Internally it use TreeView style to determine if dark theme is used.
+	 *
+	 * @return `true` if the active style is `TreeViewStyle::dark`, otherwise `false`.
+	 *
+	 * @see DarkMode::getTreeViewStyle()
+	 */
 	bool isThemeDark()
 	{
-		return g_dmCfg._treeViewStyle == TreeViewStyle::dark;
+		return DarkMode::getTreeViewStyle() == TreeViewStyle::dark;
 	}
 
+	/**
+	 * @brief Checks whether the color is dark.
+	 *
+	 * @param clr Color to check.
+	 *
+	 * @return `true` if the perceived lightness of the color
+	 *         is less than (50.0 - kMiddleGrayRange), otherwise `false`.
+	 *
+	 * @see DarkMode::calculatePerceivedLightness()
+	 */
+	bool isColorDark(COLORREF clr)
+	{
+		static constexpr double middle = 50.0;
+		return DarkMode::calculatePerceivedLightness(clr) < (middle - kMiddleGrayRange);
+	}
+
+	/**
+	 * @brief Forces a window to redraw its non-client frame.
+	 *
+	 * Triggers a non-client area update by using `SWP_FRAMECHANGED` without changing
+	 * size, position, or Z-order.
+	 *
+	 * @param hWnd Handle to the target window.
+	 */
 	void redrawWindowFrame(HWND hWnd)
 	{
 		::SetWindowPos(hWnd, nullptr, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);
 	}
 
+	/**
+	 * @brief Sets or clears a specific window style or extended style.
+	 *
+	 * Checks if the specified `dwFlag` is already set and toggles it if needed.
+	 * Only valid for `GWL_STYLE` or `GWL_EXSTYLE`.
+	 *
+	 * @param hWnd Handle to the window.
+	 * @param setFlag `true` to set the flag, `false` to clear it.
+	 * @param dwFlag Style bitmask to apply.
+	 * @param gwlIdx Either `GWL_STYLE` or `GWL_EXSTYLE`.
+	 * @return `TRUE` if modified, `FALSE` if unchanged, `-1` if invalid index.
+	 */
 	static int setWindowLongPtrStyle(HWND hWnd, bool setFlag, LONG_PTR dwFlag, int gwlIdx)
 	{
 		if ((gwlIdx != GWL_STYLE) && (gwlIdx != GWL_EXSTYLE))
@@ -6045,6 +7936,16 @@ namespace DarkMode
 		return FALSE;
 	}
 
+	/**
+	 * @brief Sets a window's standard style flags and redraws window if needed.
+	 *
+	 * Wraps @ref DarkMode::setWindowLongPtrStyle with `GWL_STYLE`
+	 * and calls @ref DarkMode::redrawWindowFrame if a change occurs.
+	 *
+	 * @param hWnd Handle to the target window.
+	 * @param setStyle `true` to set the flag, `false` to remove it.
+	 * @param styleFlag Style bit to modify.
+	 */
 	void setWindowStyle(HWND hWnd, bool setStyle, LONG_PTR styleFlag)
 	{
 		if (DarkMode::setWindowLongPtrStyle(hWnd, setStyle, styleFlag, GWL_STYLE) == TRUE)
@@ -6053,6 +7954,16 @@ namespace DarkMode
 		}
 	}
 
+	/**
+	 * @brief Sets a window's extended style flags and redraws window if needed.
+	 *
+	 * Wraps @ref DarkMode::setWindowLongPtrStyle with `GWL_EXSTYLE`
+	 * and calls @ref DarkMode::redrawWindowFrame if a change occurs.
+	 *
+	 * @param hWnd Handle to the target window.
+	 * @param setExStyle `true` to set the flag, `false` to remove it.
+	 * @param exStyleFlag Extended style bit to modify.
+	 */
 	void setWindowExStyle(HWND hWnd, bool setExStyle, LONG_PTR exStyleFlag)
 	{
 		if (DarkMode::setWindowLongPtrStyle(hWnd, setExStyle, exStyleFlag, GWL_EXSTYLE) == TRUE)
@@ -6061,12 +7972,42 @@ namespace DarkMode
 		}
 	}
 
+	/**
+	 * @brief Replaces an extended edge (e.g. client edge) with a standard window border.
+	 *
+	 * The given `exStyleFlag` must be a valid edge-related extended window style:
+	 * - `WS_EX_CLIENTEDGE`
+	 * - `WS_EX_DLGMODALFRAME`
+	 * - `WS_EX_STATICEDGE`
+	 * - `WS_EX_WINDOWEDGE`
+	 * ...or any combination of these.
+	 *
+	 * If `replace` is `true`, the specified extended edge style(s) are removed and
+	 * `WS_BORDER` is applied. If `false`, the edge style(s) are restored and `WS_BORDER` is cleared.
+	 *
+	 * @param hWnd Handle to the target window.
+	 * @param replace `true` to apply standard border; `false` to restore extended edge(s).
+	 * @param exStyleFlag One or more valid edge-related extended styles.
+	 *
+	 * @see DarkMode::setWindowExStyle()
+	 * @see DarkMode::setWindowStyle()
+	 */
 	void replaceExEdgeWithBorder(HWND hWnd, bool replace, LONG_PTR exStyleFlag)
 	{
 		DarkMode::setWindowExStyle(hWnd, !replace, exStyleFlag);
 		DarkMode::setWindowStyle(hWnd, replace, WS_BORDER);
 	}
 
+	/**
+	 * @brief Safely toggles `WS_EX_CLIENTEDGE` with `WS_BORDER` based on dark mode state.
+	 *
+	 * If dark mode is enabled, removes `WS_EX_CLIENTEDGE` and applies `WS_BORDER`.
+	 * Otherwise restores the extended edge style.
+	 *
+	 * @param hWnd Handle to the target window. No action is taken if `hWnd` is `nullptr`.
+	 *
+	 * @see DarkMode::replaceExEdgeWithBorder()
+	 */
 	void replaceClientEdgeWithBorderSafe(HWND hWnd)
 	{
 		if (hWnd != nullptr)
@@ -6075,18 +8016,50 @@ namespace DarkMode
 		}
 	}
 
+	/**
+	 * @brief Applies classic-themed styling to a progress bar in non-classic mode.
+	 *
+	 * When dark mode is enabled, applies `WS_DLGFRAME`, removes visual styles
+	 * to allow to set custom background and fill colors using:
+	 * - Background: `DarkMode::getBackgroundColor()`
+	 * - Fill: Hardcoded green `0x06B025` via `PBM_SETBARCOLOR`
+	 *
+	 * Typically used for marquee style progress bar.
+	 *
+	 * @param hWnd Handle to the progress bar control.
+	 *
+	 * @see DarkMode::setWindowStyle()
+	 * @see DarkMode::disableVisualStyle()
+	 */
 	void setProgressBarClassicTheme(HWND hWnd)
 	{
 		DarkMode::setWindowStyle(hWnd, DarkMode::isEnabled(), WS_DLGFRAME);
 		DarkMode::disableVisualStyle(hWnd, DarkMode::isEnabled());
 		if (DarkMode::isEnabled())
 		{
-			::SendMessage(hWnd, PBM_SETBKCOLOR, 0, static_cast<LPARAM>(DarkMode::getBackgroundColor()));
-			static constexpr COLORREF greenFill = HEXRGB(0x06B025);
-			::SendMessage(hWnd, PBM_SETBARCOLOR, 0, static_cast<LPARAM>(greenFill));
-		}
-	}
-
+			::SendMessage(hWnd, PBM_SETBKCOLOR, 0, static_cast<LPARAM>(DarkMode::getCtrlBackgroundColor()));
+			static constexpr COLORREF greenLight = HEXRGB(0x06B025);
+			static constexpr COLORREF greenDark = HEXRGB(0x0F7B0F);
+			::SendMessage(hWnd, PBM_SETBARCOLOR, 0, static_cast<LPARAM>(DarkMode::isExperimentalActive() ? greenDark : greenLight));
+		}
+	}
+
+	/**
+	 * @brief Handles text and background colorizing for read-only controls.
+	 *
+	 * Sets the text color and background color on the provided HDC.
+	 * Returns the corresponding background brush for painting.
+	 * Typically used for read-only controls (e.g. edit control and combo box' list box).
+	 * Typically used in response to `WM_CTLCOLORSTATIC` or in `WM_CTLCOLORLISTBOX`
+	 * via @ref DarkMode::onCtlColorListbox
+	 *
+	 * @param hdc Handle to the device context (HDC) receiving the drawing instructions.
+	 * @return Background brush to use for painting, or `FALSE` (0) if classic mode is enabled
+	 *         and `_DARKMODELIB_DLG_PROC_CTLCOLOR_RETURNS` is defined.
+	 *
+	 * @see DarkMode::WindowCtlColorSubclass()
+	 * @see DarkMode::onCtlColorListbox()
+	 */
 	LRESULT onCtlColor(HDC hdc)
 	{
 #if defined(_DARKMODELIB_DLG_PROC_CTLCOLOR_RETURNS)
@@ -6100,6 +8073,21 @@ namespace DarkMode
 		return reinterpret_cast<LRESULT>(DarkMode::getBackgroundBrush());
 	}
 
+	/**
+	 * @brief Handles text and background colorizing for interactive controls.
+	 *
+	 * Sets the text and background colors on the provided HDC.
+	 * Returns the corresponding brush used to paint the background.
+	 * Typically used in response to `WM_CTLCOLOREDIT` and `WM_CTLCOLORLISTBOX`
+	 * via @ref DarkMode::onCtlColorListbox
+	 *
+	 * @param hdc Handle to the device context for the target control.
+	 * @return The background brush, or `FALSE` if dark mode is disabled and
+	 *         `_DARKMODELIB_DLG_PROC_CTLCOLOR_RETURNS` is defined.
+	 *
+	 * @see DarkMode::WindowCtlColorSubclass()
+	 * @see DarkMode::onCtlColorListbox()
+	 */
 	LRESULT onCtlColorCtrl(HDC hdc)
 	{
 #if defined(_DARKMODELIB_DLG_PROC_CTLCOLOR_RETURNS)
@@ -6114,6 +8102,21 @@ namespace DarkMode
 		return reinterpret_cast<LRESULT>(DarkMode::getCtrlBackgroundBrush());
 	}
 
+	/**
+	 * @brief Handles text and background colorizing for window and disabled non-text controls.
+	 *
+	 * Sets the text and background colors on the provided HDC.
+	 * Returns the corresponding brush used to paint the background.
+	 * Typically used in response to `WM_CTLCOLORDLG`, `WM_CTLCOLORSTATIC`
+	 * and `WM_CTLCOLORLISTBOX` via @ref DarkMode::onCtlColorListbox
+	 *
+	 * @param hdc Handle to the device context for the target control.
+	 * @return The background brush, or `FALSE` if dark mode is disabled and
+	 *         `_DARKMODELIB_DLG_PROC_CTLCOLOR_RETURNS` is defined.
+	 *
+	 * @see DarkMode::WindowCtlColorSubclass()
+	 * @see DarkMode::onCtlColorListbox()
+	 */
 	LRESULT onCtlColorDlg(HDC hdc)
 	{
 #if defined(_DARKMODELIB_DLG_PROC_CTLCOLOR_RETURNS)
@@ -6128,6 +8131,17 @@ namespace DarkMode
 		return reinterpret_cast<LRESULT>(DarkMode::getDlgBackgroundBrush());
 	}
 
+	/**
+	 * @brief Handles text and background colorizing for error state (for specific usage).
+	 *
+	 * Sets the text and background colors on the provided HDC.
+	 *
+	 * @param hdc Handle to the device context for the target control.
+	 * @return The background brush, or `FALSE` if dark mode is disabled and
+	 *         `_DARKMODELIB_DLG_PROC_CTLCOLOR_RETURNS` is defined.
+	 *
+	 * @see DarkMode::WindowCtlColorSubclass()
+	 */
 	LRESULT onCtlColorError(HDC hdc)
 	{
 #if defined(_DARKMODELIB_DLG_PROC_CTLCOLOR_RETURNS)
@@ -6142,6 +8156,20 @@ namespace DarkMode
 		return reinterpret_cast<LRESULT>(DarkMode::getErrorBackgroundBrush());
 	}
 
+	/**
+	 * @brief Handles text and background colorizing for static text controls.
+	 *
+	 * Sets the text and background colors on the provided HDC.
+	 * Colors depend on if control is enabled.
+	 * Returns the corresponding brush used to paint the background.
+	 * Typically used in response to `WM_CTLCOLORSTATIC`.
+	 *
+	 * @param hdc Handle to the device context for the target control.
+	 * @return The background brush, or `FALSE` if dark mode is disabled and
+	 *         `_DARKMODELIB_DLG_PROC_CTLCOLOR_RETURNS` is defined.
+	 *
+	 * @see DarkMode::WindowCtlColorSubclass()
+	 */
 	LRESULT onCtlColorDlgStaticText(HDC hdc, bool isTextEnabled)
 	{
 #if defined(_DARKMODELIB_DLG_PROC_CTLCOLOR_RETURNS)
@@ -6156,6 +8184,20 @@ namespace DarkMode
 		return reinterpret_cast<LRESULT>(DarkMode::getDlgBackgroundBrush());
 	}
 
+	/**
+	 * @brief Handles text and background colorizing for syslink controls.
+	 *
+	 * Sets the text and background colors on the provided HDC.
+	 * Colors depend on if control is enabled.
+	 * Returns the corresponding brush used to paint the background.
+	 * Typically used in response to `WM_CTLCOLORSTATIC`.
+	 *
+	 * @param hdc Handle to the device context for the target control.
+	 * @return The background brush, or `FALSE` if dark mode is disabled and
+	 *         `_DARKMODELIB_DLG_PROC_CTLCOLOR_RETURNS` is defined.
+	 *
+	 * @see DarkMode::WindowCtlColorSubclass()
+	 */
 	LRESULT onCtlColorDlgLinkText(HDC hdc, bool isTextEnabled)
 	{
 #if defined(_DARKMODELIB_DLG_PROC_CTLCOLOR_RETURNS)
@@ -6170,6 +8212,24 @@ namespace DarkMode
 		return reinterpret_cast<LRESULT>(DarkMode::getDlgBackgroundBrush());
 	}
 
+	/**
+	 * @brief Handles text and background colorizing for list box controls.
+	 *
+	 * Inspects the list box style flags to detect if it's part of a combo box (via `LBS_COMBOBOX`)
+	 * and whether experimental feature is active. Based on the context, delegates to:
+	 * - @ref DarkMode::onCtlColorCtrl for standard enabled listboxes
+	 * - @ref DarkMode::onCtlColorDlg for disabled ones or when dark mode is disabled
+	 * - @ref DarkMode::onCtlColor for combo box' listbox
+	 *
+	 * @param wParam WPARAM from `WM_CTLCOLORLISTBOX`, representing the HDC.
+	 * @param lParam LPARAM from `WM_CTLCOLORLISTBOX`, representing the HWND of the listbox.
+	 * @return The brush handle as LRESULT for background painting, or `FALSE` if not themed.
+	 *
+	 * @see DarkMode::WindowCtlColorSubclass()
+	 * @see DarkMode::onCtlColor()
+	 * @see DarkMode::onCtlColorCtrl()
+	 * @see DarkMode::onCtlColorDlg()
+	 */
 	LRESULT onCtlColorListbox(WPARAM wParam, LPARAM lParam)
 	{
 		auto hdc = reinterpret_cast<HDC>(wParam);
@@ -6188,11 +8248,14 @@ namespace DarkMode
 		return DarkMode::onCtlColor(hdc);
 	}
 
-	UINT_PTR CALLBACK HookDlgProc(HWND hWnd, UINT uMsg, WPARAM /*wParam*/, LPARAM /*lParam*/)
+	/**
+	 * @brief Hook procedure for customizing common dialogs with dark mode.
+	 */
+	UINT_PTR CALLBACK HookDlgProc(HWND hWnd, UINT uMsg, [[maybe_unused]] WPARAM wParam, [[maybe_unused]] LPARAM lParam)
 	{
 		if (uMsg == WM_INITDIALOG)
 		{
-			DarkMode::setDarkDlgSafe(hWnd);
+			DarkMode::setDarkWndSafe(hWnd);
 			return TRUE;
 		}
 		return FALSE;
diff --git a/DarkMode/src/DarkModeSubclass.h b/DarkMode/src/DarkModeSubclass.h
new file mode 100644
index 000000000..43b8a2217
--- /dev/null
+++ b/DarkMode/src/DarkModeSubclass.h
@@ -0,0 +1,655 @@
+// SPDX-License-Identifier: MPL-2.0
+
+/*
+ * Copyright (c) 2025 oZone10
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at https://mozilla.org/MPL/2.0/.
+ */
+
+// Based on the Notepad++ dark mode code licensed under GPLv3.
+// Originally by adzm / Adam D. Walling, with modifications by the Notepad++ team.
+// Heavily modified by oZone10 (Notepad++ contributor).
+// Used with permission to relicense under the Mozilla Public License, v. 2.0.
+
+
+#pragma once
+
+#include <windows.h>
+
+#if (NTDDI_VERSION >= NTDDI_VISTA) /*\
+	&& (defined(__x86_64__) || defined(_M_X64)\
+	|| defined(__arm64__) || defined(__arm64) || defined(_M_ARM64))*/
+
+#if defined(_MSC_VER)
+#pragma comment(lib, "dwmapi.lib")
+#pragma comment(lib, "uxtheme.lib")
+#pragma comment(lib, "Comctl32.lib")
+#pragma comment(lib, "Gdi32.lib")
+#endif
+
+namespace DarkMode
+{
+	struct Colors
+	{
+		COLORREF background = 0;
+		COLORREF ctrlBackground = 0;
+		COLORREF hotBackground = 0;
+		COLORREF dlgBackground = 0;
+		COLORREF errorBackground = 0;
+		COLORREF text = 0;
+		COLORREF darkerText = 0;
+		COLORREF disabledText = 0;
+		COLORREF linkText = 0;
+		COLORREF edge = 0;
+		COLORREF hotEdge = 0;
+		COLORREF disabledEdge = 0;
+	};
+
+	struct ColorsView
+	{
+		COLORREF background = 0;
+		COLORREF text = 0;
+		COLORREF gridlines = 0;
+		COLORREF headerBackground = 0;
+		COLORREF headerHotBackground = 0;
+		COLORREF headerText = 0;
+		COLORREF headerEdge = 0;
+	};
+
+	// unsigned char == std::uint8_t
+
+	/**
+	 * @brief Represents tooltip from different controls.
+	 */
+	enum class ToolTipsType : unsigned char
+	{
+		tooltip,   ///< Standard tooltip control.
+		toolbar,   ///< Tooltips associated with toolbar buttons.
+		listview,  ///< Tooltips associated with list views.
+		treeview,  ///< Tooltips associated with tree views.
+		tabbar,    ///< Tooltips associated with tab controls.
+		trackbar,  ///< Tooltips associated with trackbar (slider) controls.
+		rebar      ///< Tooltips associated with rebar controls.
+	};
+
+	/**
+	 * @brief Defines dark mode preset color tones.
+	 *
+	 * Used as preset to choose default colors in dark mode.
+	 * Value `max` is reserved for internal range checking,
+	 * do not use in application code.
+	 */
+	enum class ColorTone : unsigned char
+	{
+		black   = 0,  ///< Black
+		red     = 1,  ///< Red
+		green   = 2,  ///< Green
+		blue    = 3,  ///< Blue
+		purple  = 4,  ///< Purple
+		cyan    = 5,  ///< Cyan
+		olive   = 6,  ///< Olive
+		max     = 7   ///< Don't use, for internal checks
+	};
+
+	/**
+	 * @brief Defines the available visual styles for TreeView controls.
+	 *
+	 * Used to control theming behavior for TreeViews:
+	 * - `classic`: Legacy style without theming.
+	 * - `light`: Light mode appearance.
+	 * - `dark`: Dark mode appearance.
+	 *
+	 * Set via configuration and used by style evaluators (e.g. @ref DarkMode::calculateTreeViewStyle).
+	 *
+	 * @see DarkMode::calculateTreeViewStyle()
+	 */
+	enum class TreeViewStyle : unsigned char
+	{
+		classic,  ///< Non-themed legacy appearance.
+		light,    ///< Light mode.
+		dark      ///< Dark mode.
+	};
+
+	/**
+	 * @brief Describes metadata fields and compile-time features of the dark mode library.
+	 *
+	 * Values of this enum are used with @ref DarkMode::getLibInfo to retrieve version numbers and
+	 * determine whether specific features were enabled during compilation.
+	 *
+	 * @see DarkMode::getLibInfo()
+	 */
+	enum class LibInfo : unsigned char
+	{
+		featureCheck,     ///< Returns maxValue to verify enum coverage.
+		verMajor,         ///< Major version number of the library.
+		verMinor,         ///< Minor version number of the library.
+		verRevision,      ///< Revision/patch number of the library.
+		iathookExternal,  ///< Indicates if external IAT hooking is used.
+		iniConfigUsed,    ///< True if `.ini` file configuration is supported.
+		allowOldOS,       ///< True if older Windows versions are allowed.
+		useDlgProcCtl,    ///< True if WM_CTLCOLORxxx can be handled directly in dialog procedure.
+		preferTheme,      ///< True if theme is supported and can be used over subclass, e.g. combo box on Windows 10+.
+		maxValue          ///< Sentinel value for internal validation (not intended for use).
+	};
+
+	/**
+	 * @brief Defines the available dark mode types for manual configurations.
+	 *
+	 * Can be used in DarkMode::initDarkModeConfig and in DarkMode::setDarkModeConfig
+	 * with static_cast<UINT>(DarkModeType::'value').
+	 *
+	 * @note Also used internally to distinguish between light, dark, and classic modes.
+	 *
+	 * @see DarkMode::initDarkModeConfig()
+	 * @see DarkMode::setDarkModeConfig()
+	 */
+	enum class DarkModeType : unsigned char
+	{
+		light = 0,  ///< Light mode appearance.
+		dark = 1,   ///< Dark mode appearance.
+		classic = 3 ///< Classic (non-themed or system) appearance.
+	};
+
+	/**
+	 * @brief Returns library version information or compile-time feature flags.
+	 *
+	 * @param libInfoType The type of information to query.
+	 * @return Integer representing the requested value or feature flag.
+	 *
+	 * @see LibInfo
+	 */
+	[[nodiscard]] int getLibInfo(LibInfo libInfoType);
+
+	// ========================================================================
+	// Config
+	// ========================================================================
+
+	/**
+	 * @brief Initializes the dark mode configuration based on the selected mode.
+	 *
+	 * For convenience @ref DarkModeType enums values can be used.
+	 *
+	 * @param dmType Configuration mode:
+	 *        - 0: Light mode
+	 *        - 1: Dark mode
+	 *        - 3: Classic mode
+	 *
+	 * @note Values 2 and 4 are reserved for internal use only.
+	 *       Using them can cause visual glitches.
+	 */
+	void initDarkModeConfig(UINT dmType);
+
+	/// Sets the preferred window corner style on Windows 11. (DWM_WINDOW_CORNER_PREFERENCE values)
+	void setRoundCornerConfig(UINT roundCornerStyle);
+
+	/// Sets the preferred border color for window edge on Windows 11.
+	void setBorderColorConfig(COLORREF clr);
+
+	// Sets the Mica effects on Windows 11 setting. (DWM_SYSTEMBACKDROP_TYPE values)
+	void setMicaConfig(UINT mica);
+
+	/// Sets Mica effects on the full window setting.
+	void setMicaExtendedConfig(bool extendMica);
+
+	/// Sets dialog colors on title bar on Windows 11 setting.
+	void setColorizeTitleBarConfig(bool colorize);
+
+	/// Applies dark mode settings based on the given configuration type. (DarkModeType values)
+	void setDarkModeConfig(UINT dmType);
+
+	/// Applies dark mode settings based on system mode preference.
+	void setDarkModeConfig();
+
+	/// Initializes dark mode experimental features, colors, and other settings.
+	void initDarkMode(const wchar_t* iniName);
+
+	///Initializes dark mode without INI settings.
+	void initDarkMode();
+
+	// ========================================================================
+	// Basic checks
+	// ========================================================================
+
+	/// Checks if non-classic mode is enabled.
+	[[nodiscard]] bool isEnabled();
+
+	/// Checks if experimental dark mode features are currently active.
+	[[nodiscard]] bool isExperimentalActive();
+
+	/// Checks if experimental dark mode features are supported by the system.
+	[[nodiscard]] bool isExperimentalSupported();
+
+	/// Checks if follow the system mode behavior is enabled.
+	[[nodiscard]] bool isWindowsModeEnabled();
+
+	/// Checks if the host OS is at least Windows 10.
+	[[nodiscard]] bool isAtLeastWindows10();
+
+	/// Checks if the host OS is at least Windows 11.
+	[[nodiscard]] bool isAtLeastWindows11();
+
+	/// Retrieves the current Windows build number.
+	[[nodiscard]] DWORD getWindowsBuildNumber();
+
+	// ========================================================================
+	// System Events
+	// ========================================================================
+
+	/// Handles system setting changes related to dark mode.
+	bool handleSettingChange(LPARAM lParam);
+
+	/// Checks if dark mode is enabled in the Windows registry.
+	[[nodiscard]] bool isDarkModeReg();
+
+	// ========================================================================
+	// From DarkMode.h
+	// ========================================================================
+
+	/**
+	 * @brief Overrides a specific system color with a custom color.
+	 *
+	 * Currently supports:
+	 * - `COLOR_WINDOW`: Background of ComboBoxEx list.
+	 * - `COLOR_WINDOWTEXT`: Text color of ComboBoxEx list.
+	 * - `COLOR_BTNFACE`: Gridline color in ListView (when applicable).
+	 *
+	 * @param nIndex One of the supported system color indices.
+	 * @param color Custom `COLORREF` value to apply.
+	 */
+	void setSysColor(int nIndex, COLORREF color);
+
+	// ========================================================================
+	// Enhancements to DarkMode.h
+	// ========================================================================
+
+	/// Makes scroll bars on the specified window and all its children consistent.
+	void enableDarkScrollBarForWindowAndChildren(HWND hWnd);
+
+	// ========================================================================
+	// Colors
+	// ========================================================================
+
+	/// Sets the color tone and its color set for the active theme.
+	void setColorTone(ColorTone colorTone);
+
+	/// Retrieves the currently active color tone for the theme.
+	[[nodiscard]] ColorTone getColorTone();
+
+	COLORREF setBackgroundColor(COLORREF clrNew);
+	COLORREF setCtrlBackgroundColor(COLORREF clrNew);
+	COLORREF setHotBackgroundColor(COLORREF clrNew);
+	COLORREF setDlgBackgroundColor(COLORREF clrNew);
+	COLORREF setErrorBackgroundColor(COLORREF clrNew);
+
+	COLORREF setTextColor(COLORREF clrNew);
+	COLORREF setDarkerTextColor(COLORREF clrNew);
+	COLORREF setDisabledTextColor(COLORREF clrNew);
+	COLORREF setLinkTextColor(COLORREF clrNew);
+
+	COLORREF setEdgeColor(COLORREF clrNew);
+	COLORREF setHotEdgeColor(COLORREF clrNew);
+	COLORREF setDisabledEdgeColor(COLORREF clrNew);
+
+	void setThemeColors(Colors colors);
+	void updateThemeBrushesAndPens();
+
+	[[nodiscard]] COLORREF getBackgroundColor();
+	[[nodiscard]] COLORREF getCtrlBackgroundColor();
+	[[nodiscard]] COLORREF getHotBackgroundColor();
+	[[nodiscard]] COLORREF getDlgBackgroundColor();
+	[[nodiscard]] COLORREF getErrorBackgroundColor();
+
+	[[nodiscard]] COLORREF getTextColor();
+	[[nodiscard]] COLORREF getDarkerTextColor();
+	[[nodiscard]] COLORREF getDisabledTextColor();
+	[[nodiscard]] COLORREF getLinkTextColor();
+
+	[[nodiscard]] COLORREF getEdgeColor();
+	[[nodiscard]] COLORREF getHotEdgeColor();
+	[[nodiscard]] COLORREF getDisabledEdgeColor();
+
+	[[nodiscard]] HBRUSH getBackgroundBrush();
+	[[nodiscard]] HBRUSH getDlgBackgroundBrush();
+	[[nodiscard]] HBRUSH getCtrlBackgroundBrush();
+	[[nodiscard]] HBRUSH getHotBackgroundBrush();
+	[[nodiscard]] HBRUSH getErrorBackgroundBrush();
+
+	[[nodiscard]] HBRUSH getEdgeBrush();
+	[[nodiscard]] HBRUSH getHotEdgeBrush();
+	[[nodiscard]] HBRUSH getDisabledEdgeBrush();
+
+	[[nodiscard]] HPEN getDarkerTextPen();
+	[[nodiscard]] HPEN getEdgePen();
+	[[nodiscard]] HPEN getHotEdgePen();
+	[[nodiscard]] HPEN getDisabledEdgePen();
+
+	COLORREF setViewBackgroundColor(COLORREF clrNew);
+	COLORREF setViewTextColor(COLORREF clrNew);
+	COLORREF setViewGridlinesColor(COLORREF clrNew);
+
+	COLORREF setHeaderBackgroundColor(COLORREF clrNew);
+	COLORREF setHeaderHotBackgroundColor(COLORREF clrNew);
+	COLORREF setHeaderTextColor(COLORREF clrNew);
+	COLORREF setHeaderEdgeColor(COLORREF clrNew);
+
+	void setViewColors(ColorsView colors);
+	void updateViewBrushesAndPens();
+
+	[[nodiscard]] COLORREF getViewBackgroundColor();
+	[[nodiscard]] COLORREF getViewTextColor();
+	[[nodiscard]] COLORREF getViewGridlinesColor();
+
+	[[nodiscard]] COLORREF getHeaderBackgroundColor();
+	[[nodiscard]] COLORREF getHeaderHotBackgroundColor();
+	[[nodiscard]] COLORREF getHeaderTextColor();
+	[[nodiscard]] COLORREF getHeaderEdgeColor();
+
+	[[nodiscard]] HBRUSH getViewBackgroundBrush();
+	[[nodiscard]] HBRUSH getViewGridlinesBrush();
+
+	[[nodiscard]] HBRUSH getHeaderBackgroundBrush();
+	[[nodiscard]] HBRUSH getHeaderHotBackgroundBrush();
+
+	[[nodiscard]] HPEN getHeaderEdgePen();
+
+	/// Initializes default color set based on the current mode type.
+	void setDefaultColors(bool updateBrushesAndOther);
+
+	// ========================================================================
+	// Paint Helpers
+	// ========================================================================
+
+	/// Paints a rounded rectangle using the specified pen and brush.
+	void paintRoundRect(HDC hdc, const RECT& rect, HPEN hpen, HBRUSH hBrush, int width = 0, int height = 0);
+	/// Paints an unfilled rounded rectangle (frame only).
+	void paintRoundFrameRect(HDC hdc, const RECT& rect, HPEN hpen, int width = 0, int height = 0);
+
+	// ========================================================================
+	// Control Subclassing
+	// ========================================================================
+
+	/// Applies themed owner drawn subclassing to a checkbox, radio, or tri-state button control.
+	void setCheckboxOrRadioBtnCtrlSubclass(HWND hWnd);
+	/// Removes the owner drawn subclass from a a checkbox, radio, or tri-state button control.
+	void removeCheckboxOrRadioBtnCtrlSubclass(HWND hWnd);
+
+	/// Applies owner drawn subclassing to a groupbox button control.
+	void setGroupboxCtrlSubclass(HWND hWnd);
+	/// Removes the owner drawn subclass from a groupbox button control.
+	void removeGroupboxCtrlSubclass(HWND hWnd);
+
+	/// Applies owner drawn subclassing and theming to an updown (spinner) control.
+	void setUpDownCtrlSubclass(HWND hWnd);
+	/// Removes the owner drawn subclass from a updown (spinner) control.
+	void removeUpDownCtrlSubclass(HWND hWnd);
+
+	void setTabCtrlUpDownSubclass(HWND hWnd);
+	void removeTabCtrlUpDownSubclass(HWND hWnd);
+	void setTabCtrlSubclass(HWND hWnd);
+	void removeTabCtrlSubclass(HWND hWnd);
+
+	void setCustomBorderForListBoxOrEditCtrlSubclass(HWND hWnd);
+	void removeCustomBorderForListBoxOrEditCtrlSubclass(HWND hWnd);
+
+	void setComboBoxCtrlSubclass(HWND hWnd);
+	void removeComboBoxCtrlSubclass(HWND hWnd);
+
+	void setComboBoxExCtrlSubclass(HWND hWnd);
+	void removeComboBoxExCtrlSubclass(HWND hWnd);
+
+	void setListViewCtrlSubclass(HWND hWnd);
+	void removeListViewCtrlSubclass(HWND hWnd);
+
+	void setHeaderCtrlSubclass(HWND hWnd);
+	void removeHeaderCtrlSubclass(HWND hWnd);
+
+	void setStatusBarCtrlSubclass(HWND hWnd);
+	void removeStatusBarCtrlSubclass(HWND hWnd);
+
+	void setProgressBarCtrlSubclass(HWND hWnd);
+	void removeProgressBarCtrlSubclass(HWND hWnd);
+
+	void setStaticTextCtrlSubclass(HWND hWnd);
+	void removeStaticTextCtrlSubclass(HWND hWnd);
+
+	// ========================================================================
+	// Child Subclassing
+	// ========================================================================
+
+	void setChildCtrlsSubclassAndTheme(HWND hParent, bool subclass = true, bool theme = true);
+	void setChildCtrlsTheme(HWND hParent);
+
+	// ========================================================================
+	// Window, Parent, And Other Subclassing
+	// ========================================================================
+
+	/// Applies window subclassing to handle `WM_ERASEBKGND` message.
+	void setWindowEraseBgSubclass(HWND hWnd);
+	/// Removes the subclass used for `WM_ERASEBKGND` message handling.
+	void removeWindowEraseBgSubclass(HWND hWnd);
+
+	/// Applies window subclassing to handle `WM_CTLCOLOR*` messages.
+	void setWindowCtlColorSubclass(HWND hWnd);
+	/// Removes the subclass used for `WM_CTLCOLOR*` messages handling.
+	void removeWindowCtlColorSubclass(HWND hWnd);
+
+	/// Applies window subclassing for handling `NM_CUSTOMDRAW` notifications for custom drawing.
+	void setWindowNotifyCustomDrawSubclass(HWND hWnd);
+	/// Removes the subclass used for handling `NM_CUSTOMDRAW` notifications for custom drawing.
+	void removeWindowNotifyCustomDrawSubclass(HWND hWnd);
+
+	/// Applies window subclassing for menu bar themed custom drawing.
+	void setWindowMenuBarSubclass(HWND hWnd);
+	/// Removes the subclass used for menu bar themed custom drawing.
+	void removeWindowMenuBarSubclass(HWND hWnd);
+
+	/// Applies window subclassing to handle `WM_SETTINGCHANGE` message.
+	void setWindowSettingChangeSubclass(HWND hWnd);
+	/// Removes the subclass used for `WM_SETTINGCHANGE` message handling.
+	void removeWindowSettingChangeSubclass(HWND hWnd);
+
+	// ========================================================================
+	// Theme And Helpers
+	// ========================================================================
+
+	/// Configures the SysLink control to be affected by `WM_CTLCOLORSTATIC` message.
+	void enableSysLinkCtrlCtlColor(HWND hWnd);
+
+	/// Sets dark title bar and optional Windows 11 features.
+	void setDarkTitleBarEx(HWND hWnd, bool useWin11Features);
+	/// Sets dark mode title bar on supported Windows versions.
+	void setDarkTitleBar(HWND hWnd);
+
+	/// Applies an experimental visual style to the specified window, if supported.
+	void setDarkThemeExperimental(HWND hWnd, const wchar_t* themeClassName = L"Explorer");
+	/// Applies "DarkMode_Explorer" visual style if experimental mode is active.
+	void setDarkExplorerTheme(HWND hWnd);
+	/// Applies "DarkMode_Explorer" visual style to scroll bars.
+	void setDarkScrollBar(HWND hWnd);
+	/// Applies "DarkMode_Explorer" visual style to tooltip controls based on context.
+	void setDarkTooltips(HWND hWnd, ToolTipsType type = ToolTipsType::tooltip);
+
+	/// Sets the color of line above a toolbar control for non-classic mode.
+	void setDarkLineAbovePanelToolbar(HWND hWnd);
+	/// Applies an experimental Explorer visual style to a list view.
+	void setDarkListView(HWND hWnd);
+	/// Replaces default list view checkboxes with themed dark-mode versions on Windows 11.
+	void setDarkListViewCheckboxes(HWND hWnd);
+	/// Sets colors and edges for a RichEdit control.
+	void setDarkRichEdit(HWND hWnd);
+
+	/// Applies visual styles; ctl color message and child controls subclassings to a window safely.
+	void setDarkWndSafe(HWND hWnd, bool useWin11Features = true);
+	/// Applies visual styles; ctl color message, child controls, custom drawing, and setting change subclassings to a window safely.
+	void setDarkWndNotifySafeEx(HWND hWnd, bool setSettingChangeSubclass, bool useWin11Features);
+	/// Applies visual styles; ctl color message, child controls, and custom drawing subclassings to a window safely.
+	void setDarkWndNotifySafe(HWND hWnd, bool useWin11Features = true);
+
+	/// Enables or disables theme-based dialog background textures in classic mode.
+	void enableThemeDialogTexture(HWND hWnd, bool theme);
+
+	/// Enables or disables visual styles for a window.
+	void disableVisualStyle(HWND hWnd, bool doDisable);
+
+	/// Calculates perceptual lightness of a COLORREF color.
+	[[nodiscard]] double calculatePerceivedLightness(COLORREF clr);
+
+	/// Retrieves the current TreeView style configuration.
+	[[nodiscard]] const TreeViewStyle& getTreeViewStyle();
+
+	/// Determines appropriate TreeView style based on background perceived lightness.
+	void calculateTreeViewStyle();
+
+	/// Applies the appropriate window theme style to the specified TreeView.
+	void setTreeViewWindowTheme(HWND hWnd, bool force = false);
+
+	/// Retrieves the previous TreeView style configuration.
+	[[nodiscard]] const TreeViewStyle& getPrevTreeViewStyle();
+
+	/// Stores the current TreeView style as the previous style for later comparison.
+	void setPrevTreeViewStyle();
+
+	/// Checks whether the current theme is dark.
+	[[nodiscard]] bool isThemeDark();
+
+	/// Checks whether the color is dark.
+	[[nodiscard]] bool isColorDark(COLORREF clr);
+
+	/// Forces a window to redraw its non-client frame.
+	void redrawWindowFrame(HWND hWnd);
+	/// Sets a window's standard style flags and redraws window if needed.
+	void setWindowStyle(HWND hWnd, bool setStyle, LONG_PTR styleFlag);
+	/// Sets a window's extended style flags and redraws window if needed.
+	void setWindowExStyle(HWND hWnd, bool setExStyle, LONG_PTR exStyleFlag);
+	/// Replaces an extended edge (e.g. client edge) with a standard window border.
+	void replaceExEdgeWithBorder(HWND hWnd, bool replace, LONG_PTR exStyleFlag);
+	/// Safely toggles `WS_EX_CLIENTEDGE` with `WS_BORDER` based on dark mode state.
+	void replaceClientEdgeWithBorderSafe(HWND hWnd);
+
+	/// Applies classic-themed styling to a progress bar in non-classic mode.
+	void setProgressBarClassicTheme(HWND hWnd);
+
+	// ========================================================================
+	// Ctl Color
+	// ========================================================================
+
+	/// Handles text and background colorizing for read-only controls.
+	[[nodiscard]] LRESULT onCtlColor(HDC hdc);
+
+	/// Handles text and background colorizing for interactive controls.
+	[[nodiscard]] LRESULT onCtlColorCtrl(HDC hdc);
+
+	/// Handles text and background colorizing for window and disabled non-text controls.
+	[[nodiscard]] LRESULT onCtlColorDlg(HDC hdc);
+
+	/// Handles text and background colorizing for error state (for specific usage).
+	[[nodiscard]] LRESULT onCtlColorError(HDC hdc);
+
+	/// Handles text and background colorizing for static text controls.
+	[[nodiscard]] LRESULT onCtlColorDlgStaticText(HDC hdc, bool isTextEnabled);
+
+	/// Handles text and background colorizing for syslink controls.
+	[[nodiscard]] LRESULT onCtlColorDlgLinkText(HDC hdc, bool isTextEnabled = true);
+
+	/// Handles text and background colorizing for list box controls.
+	[[nodiscard]] LRESULT onCtlColorListbox(WPARAM wParam, LPARAM lParam);
+
+	// ========================================================================
+	// Hook Callback Dialog Procedure
+	// ========================================================================
+
+	/**
+	 * @brief Hook procedure for customizing common dialogs with dark mode.
+	 *
+	 * This function handles messages for all Windows common dialogs.
+	 * When initialized (`WM_INITDIALOG`), it applies dark mode styling to the dialog.
+	 *
+	 * ## Special Case: Font Dialog Workaround
+	 * - When a hook is used with `ChooseFont`, Windows **automatically falls back**
+	 *   to an **older template**, losing modern UI elements.
+	 * - To prevent this forced downgrade, a **modified template** (based on Font.dlg) is used.
+	 * - **CBS_OWNERDRAWFIXED should be removed** from the **Size** and **Script** combo boxes
+	 *   to restore proper visualization.
+	 * - **Custom owner-draw visuals remain** for other font combo boxes to allow font preview.
+	 * - Same for the `"AaBbYyZz"` sample text.
+	 * - However **Automatic system translation for captions and static texts is lost** in this workaround.
+	 *
+	 * ## Custom Font Dialog Template (Resource File)
+	 * ```rc
+	 * IDD_DARK_FONT_DIALOG DIALOG 13, 54, 243, 234
+	 * STYLE DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU |
+	 *       DS_3DLOOK
+	 * CAPTION "Font"
+	 * FONT 9, "Segoe UI"
+	 * BEGIN
+	 *     LTEXT           "&Font:", stc1, 7, 7, 98, 9
+	 *     COMBOBOX        cmb1, 7, 16, 98, 76,
+	 *                     CBS_SIMPLE | CBS_AUTOHSCROLL | CBS_DISABLENOSCROLL |
+	 *                     CBS_SORT | WS_VSCROLL | WS_TABSTOP | CBS_HASSTRINGS |
+	 *                     CBS_OWNERDRAWFIXED
+	 *
+	 *     LTEXT           "Font st&yle:", stc2, 114, 7, 74, 9
+	 *     COMBOBOX        cmb2, 114, 16, 74, 76,
+	 *                     CBS_SIMPLE | CBS_AUTOHSCROLL | CBS_DISABLENOSCROLL |
+	 *                     WS_VSCROLL | WS_TABSTOP | CBS_HASSTRINGS |
+	 *                     CBS_OWNERDRAWFIXED
+	 *
+	 *     LTEXT           "&Size:", stc3, 198, 7, 36, 9
+	 *     COMBOBOX        cmb3, 198, 16, 36, 76,
+	 *                     CBS_SIMPLE | CBS_AUTOHSCROLL | CBS_DISABLENOSCROLL |
+	 *                     CBS_SORT | WS_VSCROLL | WS_TABSTOP | CBS_HASSTRINGS |
+	 *                     CBS_OWNERDRAWFIXED // remove CBS_OWNERDRAWFIXED
+	 *
+	 *     GROUPBOX        "Effects", grp1, 7, 97, 98, 76, WS_GROUP
+	 *     AUTOCHECKBOX    "Stri&keout", chx1, 13, 111, 90, 10, WS_TABSTOP
+	 *     AUTOCHECKBOX    "&Underline", chx2, 13, 127, 90, 10
+	 *
+	 *     LTEXT           "&Color:", stc4, 13, 144, 89, 9
+	 *     COMBOBOX        cmb4, 13, 155, 85, 100,
+	 *                     CBS_DROPDOWNLIST | CBS_OWNERDRAWFIXED | CBS_AUTOHSCROLL |
+	 *                     CBS_HASSTRINGS | WS_BORDER | WS_VSCROLL | WS_TABSTOP
+	 *
+	 *     GROUPBOX        "Sample", grp2, 114, 97, 120, 43, WS_GROUP
+	 *     CTEXT           "AaBbYyZz", stc5, 116, 106, 117, 33,
+	 *                     SS_NOPREFIX | NOT WS_VISIBLE
+	 *     LTEXT           "", stc6, 7, 178, 227, 20, SS_NOPREFIX | NOT WS_GROUP
+	 *
+	 *     LTEXT           "Sc&ript:", stc7, 114, 145, 118, 9
+	 *     COMBOBOX        cmb5, 114, 155, 120, 30, CBS_DROPDOWNLIST |
+	 *                     CBS_OWNERDRAWFIXED | CBS_AUTOHSCROLL | CBS_HASSTRINGS | // remove CBS_OWNERDRAWFIXED
+	 *                     WS_BORDER | WS_VSCROLL | WS_TABSTOP
+	 *
+	 *     CONTROL         "<A>Show more fonts</A>", IDC_MANAGE_LINK, "SysLink",
+	 *                     WS_TABSTOP, 7, 199, 227, 9
+	 *
+	 *     DEFPUSHBUTTON   "OK", IDOK, 141, 215, 45, 14, WS_GROUP
+	 *     PUSHBUTTON      "Cancel", IDCANCEL, 190, 215, 45, 14, WS_GROUP
+	 *     PUSHBUTTON      "&Apply", psh3, 92, 215, 45, 14, WS_GROUP
+	 *     PUSHBUTTON      "&Help", pshHelp, 43, 215, 45, 14, WS_GROUP
+	 * END
+	 * ```
+	 *
+	 * ## Usage Example:
+	 * ```cpp
+	 * #define IDD_DARK_FONT_DIALOG 1000 // usually in resource.h or other header
+	 *
+	 * CHOOSEFONT cf{};
+	 * cf.Flags |= CF_ENABLEHOOK | CF_ENABLETEMPLATE;
+	 * cf.lpfnHook = static_cast<LPCFHOOKPROC>(DarkMode::HookDlgProc);
+	 * cf.hInstance = GetModuleHandle(nullptr);
+	 * cf.lpTemplateName = MAKEINTRESOURCE(IDD_DARK_FONT_DIALOG);
+	 * ```
+	 *
+	 * @param hWnd Handle to the dialog window.
+	 * @param uMsg Message identifier.
+	 * @param wParam First message parameter (unused).
+	 * @param lParam Second message parameter (unused).
+	 * @return A value defined by the hook procedure.
+	 */
+	UINT_PTR CALLBACK HookDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
+} // namespace DarkMode
+
+#else
+#define _DARKMODELIB_NOT_USED
+#endif // (NTDDI_VERSION >= NTDDI_VISTA) //&& (x64 or arm64)
diff --git a/DarkMode/IatHook.h b/DarkMode/src/IatHook.h
similarity index 100%
rename from DarkMode/IatHook.h
rename to DarkMode/src/IatHook.h
diff --git a/DarkMode/StdAfx.h b/DarkMode/src/StdAfx.h
similarity index 100%
rename from DarkMode/StdAfx.h
rename to DarkMode/src/StdAfx.h
diff --git a/DarkMode/UAHMenuBar.h b/DarkMode/src/UAHMenuBar.h
similarity index 100%
rename from DarkMode/UAHMenuBar.h
rename to DarkMode/src/UAHMenuBar.h
diff --git a/DarkMode/src/Version.h b/DarkMode/src/Version.h
new file mode 100644
index 000000000..44e52c95a
--- /dev/null
+++ b/DarkMode/src/Version.h
@@ -0,0 +1,16 @@
+// SPDX-License-Identifier: MPL-2.0
+
+/*
+ * Copyright (c) 2025 oZone10
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at https://mozilla.org/MPL/2.0/.
+ */
+
+
+#define DM_VERSION_MAJOR    0
+#define DM_VERSION_MINOR    10
+#define DM_VERSION_REVISION 0
+
+#define DM_VERSION   "Dark mode v0.10.0"
+#define DM_COPYRIGHT "Copyright (c) 2024-2025 ozone10"
diff --git a/LICENSE.md b/LICENSE.md
index 93392f4c2..906bff06a 100644
--- a/LICENSE.md
+++ b/LICENSE.md
@@ -1,631 +1,191 @@
-### GNU GENERAL PUBLIC LICENSE
-
-Version 3, 29 June 2007
-
-Copyright (C) 2007 Free Software Foundation, Inc.
-<https://fsf.org/>
-
-Everyone is permitted to copy and distribute verbatim copies of this
-license document, but changing it is not allowed.
-
-### Preamble
-
-The GNU General Public License is a free, copyleft license for
-software and other kinds of works.
-
-The licenses for most software and other practical works are designed
-to take away your freedom to share and change the works. By contrast,
-the GNU General Public License is intended to guarantee your freedom
-to share and change all versions of a program--to make sure it remains
-free software for all its users. We, the Free Software Foundation, use
-the GNU General Public License for most of our software; it applies
-also to any other work released this way by its authors. You can apply
-it to your programs, too.
-
-When we speak of free software, we are referring to freedom, not
-price. Our General Public Licenses are designed to make sure that you
-have the freedom to distribute copies of free software (and charge for
-them if you wish), that you receive source code or can get it if you
-want it, that you can change the software or use pieces of it in new
-free programs, and that you know you can do these things.
-
-To protect your rights, we need to prevent others from denying you
-these rights or asking you to surrender the rights. Therefore, you
-have certain responsibilities if you distribute copies of the
-software, or if you modify it: responsibilities to respect the freedom
-of others.
-
-For example, if you distribute copies of such a program, whether
-gratis or for a fee, you must pass on to the recipients the same
-freedoms that you received. You must make sure that they, too, receive
-or can get the source code. And you must show them these terms so they
-know their rights.
-
-Developers that use the GNU GPL protect your rights with two steps:
-(1) assert copyright on the software, and (2) offer you this License
-giving you legal permission to copy, distribute and/or modify it.
-
-For the developers' and authors' protection, the GPL clearly explains
-that there is no warranty for this free software. For both users' and
-authors' sake, the GPL requires that modified versions be marked as
-changed, so that their problems will not be attributed erroneously to
-authors of previous versions.
-
-Some devices are designed to deny users access to install or run
-modified versions of the software inside them, although the
-manufacturer can do so. This is fundamentally incompatible with the
-aim of protecting users' freedom to change the software. The
-systematic pattern of such abuse occurs in the area of products for
-individuals to use, which is precisely where it is most unacceptable.
-Therefore, we have designed this version of the GPL to prohibit the
-practice for those products. If such problems arise substantially in
-other domains, we stand ready to extend this provision to those
-domains in future versions of the GPL, as needed to protect the
-freedom of users.
-
-Finally, every program is threatened constantly by software patents.
-States should not allow patents to restrict development and use of
-software on general-purpose computers, but in those that do, we wish
-to avoid the special danger that patents applied to a free program
-could make it effectively proprietary. To prevent this, the GPL
-assures that patents cannot be used to render the program non-free.
-
-The precise terms and conditions for copying, distribution and
-modification follow.
-
-### TERMS AND CONDITIONS
-
-#### 0. Definitions
-
-"This License" refers to version 3 of the GNU General Public License.
-
-"Copyright" also means copyright-like laws that apply to other kinds
-of works, such as semiconductor masks.
-
-"The Program" refers to any copyrightable work licensed under this
-License. Each licensee is addressed as "you". "Licensees" and
-"recipients" may be individuals or organizations.
-
-To "modify" a work means to copy from or adapt all or part of the work
-in a fashion requiring copyright permission, other than the making of
-an exact copy. The resulting work is called a "modified version" of
-the earlier work or a work "based on" the earlier work.
-
-A "covered work" means either the unmodified Program or a work based
-on the Program.
-
-To "propagate" a work means to do anything with it that, without
-permission, would make you directly or secondarily liable for
-infringement under applicable copyright law, except executing it on a
-computer or modifying a private copy. Propagation includes copying,
-distribution (with or without modification), making available to the
-public, and in some countries other activities as well.
-
-To "convey" a work means any kind of propagation that enables other
-parties to make or receive copies. Mere interaction with a user
-through a computer network, with no transfer of a copy, is not
-conveying.
-
-An interactive user interface displays "Appropriate Legal Notices" to
-the extent that it includes a convenient and prominently visible
-feature that (1) displays an appropriate copyright notice, and (2)
-tells the user that there is no warranty for the work (except to the
-extent that warranties are provided), that licensees may convey the
-work under this License, and how to view a copy of this License. If
-the interface presents a list of user commands or options, such as a
-menu, a prominent item in the list meets this criterion.
-
-#### 1. Source Code
-
-The "source code" for a work means the preferred form of the work for
-making modifications to it. "Object code" means any non-source form of
-a work.
-
-A "Standard Interface" means an interface that either is an official
-standard defined by a recognized standards body, or, in the case of
-interfaces specified for a particular programming language, one that
-is widely used among developers working in that language.
-
-The "System Libraries" of an executable work include anything, other
-than the work as a whole, that (a) is included in the normal form of
-packaging a Major Component, but which is not part of that Major
-Component, and (b) serves only to enable use of the work with that
-Major Component, or to implement a Standard Interface for which an
-implementation is available to the public in source code form. A
-"Major Component", in this context, means a major essential component
-(kernel, window system, and so on) of the specific operating system
-(if any) on which the executable work runs, or a compiler used to
-produce the work, or an object code interpreter used to run it.
-
-The "Corresponding Source" for a work in object code form means all
-the source code needed to generate, install, and (for an executable
-work) run the object code and to modify the work, including scripts to
-control those activities. However, it does not include the work's
-System Libraries, or general-purpose tools or generally available free
-programs which are used unmodified in performing those activities but
-which are not part of the work. For example, Corresponding Source
-includes interface definition files associated with source files for
-the work, and the source code for shared libraries and dynamically
-linked subprograms that the work is specifically designed to require,
-such as by intimate data communication or control flow between those
-subprograms and other parts of the work.
-
-The Corresponding Source need not include anything that users can
-regenerate automatically from other parts of the Corresponding Source.
-
-The Corresponding Source for a work in source code form is that same
-work.
-
-#### 2. Basic Permissions
-
-All rights granted under this License are granted for the term of
-copyright on the Program, and are irrevocable provided the stated
-conditions are met. This License explicitly affirms your unlimited
-permission to run the unmodified Program. The output from running a
-covered work is covered by this License only if the output, given its
-content, constitutes a covered work. This License acknowledges your
-rights of fair use or other equivalent, as provided by copyright law.
-
-You may make, run and propagate covered works that you do not convey,
-without conditions so long as your license otherwise remains in force.
-You may convey covered works to others for the sole purpose of having
-them make modifications exclusively for you, or provide you with
-facilities for running those works, provided that you comply with the
-terms of this License in conveying all material for which you do not
-control copyright. Those thus making or running the covered works for
-you must do so exclusively on your behalf, under your direction and
-control, on terms that prohibit them from making any copies of your
-copyrighted material outside their relationship with you.
-
-Conveying under any other circumstances is permitted solely under the
-conditions stated below. Sublicensing is not allowed; section 10 makes
-it unnecessary.
-
-#### 3. Protecting Users' Legal Rights From Anti-Circumvention Law
-
-No covered work shall be deemed part of an effective technological
-measure under any applicable law fulfilling obligations under article
-11 of the WIPO copyright treaty adopted on 20 December 1996, or
-similar laws prohibiting or restricting circumvention of such
-measures.
-
-When you convey a covered work, you waive any legal power to forbid
-circumvention of technological measures to the extent such
-circumvention is effected by exercising rights under this License with
-respect to the covered work, and you disclaim any intention to limit
-operation or modification of the work as a means of enforcing, against
-the work's users, your or third parties' legal rights to forbid
-circumvention of technological measures.
-
-#### 4. Conveying Verbatim Copies
-
-You may convey verbatim copies of the Program's source code as you
-receive it, in any medium, provided that you conspicuously and
-appropriately publish on each copy an appropriate copyright notice;
-keep intact all notices stating that this License and any
-non-permissive terms added in accord with section 7 apply to the code;
-keep intact all notices of the absence of any warranty; and give all
-recipients a copy of this License along with the Program.
-
-You may charge any price or no price for each copy that you convey,
-and you may offer support or warranty protection for a fee.
-
-#### 5. Conveying Modified Source Versions
-
-You may convey a work based on the Program, or the modifications to
-produce it from the Program, in the form of source code under the
-terms of section 4, provided that you also meet all of these
-conditions:
-
--   a) The work must carry prominent notices stating that you modified
-    it, and giving a relevant date.
-
--   b) The work must carry prominent notices stating that it is
-    released under this License and any conditions added under
-    section 7. This requirement modifies the requirement in section 4
-    to "keep intact all notices".
-
--   c) You must license the entire work, as a whole, under this
-    License to anyone who comes into possession of a copy. This
-    License will therefore apply, along with any applicable section 7
-    additional terms, to the whole of the work, and all its parts,
-    regardless of how they are packaged. This License gives no
-    permission to license the work in any other way, but it does not
-    invalidate such permission if you have separately received it.
-
--   d) If the work has interactive user interfaces, each must display
-    Appropriate Legal Notices; however, if the Program has interactive
-    interfaces that do not display Appropriate Legal Notices, your
-    work need not make them do so.
-
-A compilation of a covered work with other separate and independent
-works, which are not by their nature extensions of the covered work,
-and which are not combined with it such as to form a larger program,
-in or on a volume of a storage or distribution medium, is called an
-"aggregate" if the compilation and its resulting copyright are not
-used to limit the access or legal rights of the compilation's users
-beyond what the individual works permit. Inclusion of a covered work
-in an aggregate does not cause this License to apply to the other
-parts of the aggregate.
-
-#### 6. Conveying Non-Source Forms
-
-You may convey a covered work in object code form under the terms of
-sections 4 and 5, provided that you also convey the machine-readable
-Corresponding Source under the terms of this License, in one of these
-ways:
-
--   a) Convey the object code in, or embodied in, a physical product
-    (including a physical distribution medium), accompanied by the
-    Corresponding Source fixed on a durable physical medium
-    customarily used for software interchange.
-
--   b) Convey the object code in, or embodied in, a physical product
-    (including a physical distribution medium), accompanied by a
-    written offer, valid for at least three years and valid for as
-    long as you offer spare parts or customer support for that product
-    model, to give anyone who possesses the object code either (1) a
-    copy of the Corresponding Source for all the software in the
-    product that is covered by this License, on a durable physical
-    medium customarily used for software interchange, for a price no
-    more than your reasonable cost of physically performing this
-    conveying of source, or (2) access to copy the Corresponding
-    Source from a network server at no charge.
-
--   c) Convey individual copies of the object code with a copy of the
-    written offer to provide the Corresponding Source. This
-    alternative is allowed only occasionally and noncommercially, and
-    only if you received the object code with such an offer, in accord
-    with subsection 6b.
-
--   d) Convey the object code by offering access from a designated
-    place (gratis or for a charge), and offer equivalent access to the
-    Corresponding Source in the same way through the same place at no
-    further charge. You need not require recipients to copy the
-    Corresponding Source along with the object code. If the place to
-    copy the object code is a network server, the Corresponding Source
-    may be on a different server (operated by you or a third party)
-    that supports equivalent copying facilities, provided you maintain
-    clear directions next to the object code saying where to find the
-    Corresponding Source. Regardless of what server hosts the
-    Corresponding Source, you remain obligated to ensure that it is
-    available for as long as needed to satisfy these requirements.
-
--   e) Convey the object code using peer-to-peer transmission,
-    provided you inform other peers where the object code and
-    Corresponding Source of the work are being offered to the general
-    public at no charge under subsection 6d.
-
-A separable portion of the object code, whose source code is excluded
-from the Corresponding Source as a System Library, need not be
-included in conveying the object code work.
-
-A "User Product" is either (1) a "consumer product", which means any
-tangible personal property which is normally used for personal,
-family, or household purposes, or (2) anything designed or sold for
-incorporation into a dwelling. In determining whether a product is a
-consumer product, doubtful cases shall be resolved in favor of
-coverage. For a particular product received by a particular user,
-"normally used" refers to a typical or common use of that class of
-product, regardless of the status of the particular user or of the way
-in which the particular user actually uses, or expects or is expected
-to use, the product. A product is a consumer product regardless of
-whether the product has substantial commercial, industrial or
-non-consumer uses, unless such uses represent the only significant
-mode of use of the product.
-
-"Installation Information" for a User Product means any methods,
-procedures, authorization keys, or other information required to
-install and execute modified versions of a covered work in that User
-Product from a modified version of its Corresponding Source. The
-information must suffice to ensure that the continued functioning of
-the modified object code is in no case prevented or interfered with
-solely because modification has been made.
-
-If you convey an object code work under this section in, or with, or
-specifically for use in, a User Product, and the conveying occurs as
-part of a transaction in which the right of possession and use of the
-User Product is transferred to the recipient in perpetuity or for a
-fixed term (regardless of how the transaction is characterized), the
-Corresponding Source conveyed under this section must be accompanied
-by the Installation Information. But this requirement does not apply
-if neither you nor any third party retains the ability to install
-modified object code on the User Product (for example, the work has
-been installed in ROM).
-
-The requirement to provide Installation Information does not include a
-requirement to continue to provide support service, warranty, or
-updates for a work that has been modified or installed by the
-recipient, or for the User Product in which it has been modified or
-installed. Access to a network may be denied when the modification
-itself materially and adversely affects the operation of the network
-or violates the rules and protocols for communication across the
-network.
-
-Corresponding Source conveyed, and Installation Information provided,
-in accord with this section must be in a format that is publicly
-documented (and with an implementation available to the public in
-source code form), and must require no special password or key for
-unpacking, reading or copying.
-
-#### 7. Additional Terms
-
-"Additional permissions" are terms that supplement the terms of this
-License by making exceptions from one or more of its conditions.
-Additional permissions that are applicable to the entire Program shall
-be treated as though they were included in this License, to the extent
-that they are valid under applicable law. If additional permissions
-apply only to part of the Program, that part may be used separately
-under those permissions, but the entire Program remains governed by
-this License without regard to the additional permissions.
-
-When you convey a copy of a covered work, you may at your option
-remove any additional permissions from that copy, or from any part of
-it. (Additional permissions may be written to require their own
-removal in certain cases when you modify the work.) You may place
-additional permissions on material, added by you to a covered work,
-for which you have or can give appropriate copyright permission.
-
-Notwithstanding any other provision of this License, for material you
-add to a covered work, you may (if authorized by the copyright holders
-of that material) supplement the terms of this License with terms:
-
--   a) Disclaiming warranty or limiting liability differently from the
-    terms of sections 15 and 16 of this License; or
-
--   b) Requiring preservation of specified reasonable legal notices or
-    author attributions in that material or in the Appropriate Legal
-    Notices displayed by works containing it; or
-
--   c) Prohibiting misrepresentation of the origin of that material,
-    or requiring that modified versions of such material be marked in
-    reasonable ways as different from the original version; or
-
--   d) Limiting the use for publicity purposes of names of licensors
-    or authors of the material; or
-
--   e) Declining to grant rights under trademark law for use of some
-    trade names, trademarks, or service marks; or
-
--   f) Requiring indemnification of licensors and authors of that
-    material by anyone who conveys the material (or modified versions
-    of it) with contractual assumptions of liability to the recipient,
-    for any liability that these contractual assumptions directly
-    impose on those licensors and authors.
-
-All other non-permissive additional terms are considered "further
-restrictions" within the meaning of section 10. If the Program as you
-received it, or any part of it, contains a notice stating that it is
-governed by this License along with a term that is a further
-restriction, you may remove that term. If a license document contains
-a further restriction but permits relicensing or conveying under this
-License, you may add to a covered work material governed by the terms
-of that license document, provided that the further restriction does
-not survive such relicensing or conveying.
-
-If you add terms to a covered work in accord with this section, you
-must place, in the relevant source files, a statement of the
-additional terms that apply to those files, or a notice indicating
-where to find the applicable terms.
-
-Additional terms, permissive or non-permissive, may be stated in the
-form of a separately written license, or stated as exceptions; the
-above requirements apply either way.
-
-#### 8. Termination
-
-You may not propagate or modify a covered work except as expressly
-provided under this License. Any attempt otherwise to propagate or
-modify it is void, and will automatically terminate your rights under
-this License (including any patent licenses granted under the third
-paragraph of section 11).
-
-However, if you cease all violation of this License, then your license
-from a particular copyright holder is reinstated (a) provisionally,
-unless and until the copyright holder explicitly and finally
-terminates your license, and (b) permanently, if the copyright holder
-fails to notify you of the violation by some reasonable means prior to
-60 days after the cessation.
-
-Moreover, your license from a particular copyright holder is
-reinstated permanently if the copyright holder notifies you of the
-violation by some reasonable means, this is the first time you have
-received notice of violation of this License (for any work) from that
-copyright holder, and you cure the violation prior to 30 days after
-your receipt of the notice.
-
-Termination of your rights under this section does not terminate the
-licenses of parties who have received copies or rights from you under
-this License. If your rights have been terminated and not permanently
-reinstated, you do not qualify to receive new licenses for the same
-material under section 10.
-
-#### 9. Acceptance Not Required for Having Copies
-
-You are not required to accept this License in order to receive or run
-a copy of the Program. Ancillary propagation of a covered work
-occurring solely as a consequence of using peer-to-peer transmission
-to receive a copy likewise does not require acceptance. However,
-nothing other than this License grants you permission to propagate or
-modify any covered work. These actions infringe copyright if you do
-not accept this License. Therefore, by modifying or propagating a
-covered work, you indicate your acceptance of this License to do so.
-
-#### 10. Automatic Licensing of Downstream Recipients
-
-Each time you convey a covered work, the recipient automatically
-receives a license from the original licensors, to run, modify and
-propagate that work, subject to this License. You are not responsible
-for enforcing compliance by third parties with this License.
-
-An "entity transaction" is a transaction transferring control of an
-organization, or substantially all assets of one, or subdividing an
-organization, or merging organizations. If propagation of a covered
-work results from an entity transaction, each party to that
-transaction who receives a copy of the work also receives whatever
-licenses to the work the party's predecessor in interest had or could
-give under the previous paragraph, plus a right to possession of the
-Corresponding Source of the work from the predecessor in interest, if
-the predecessor has it or can get it with reasonable efforts.
-
-You may not impose any further restrictions on the exercise of the
-rights granted or affirmed under this License. For example, you may
-not impose a license fee, royalty, or other charge for exercise of
-rights granted under this License, and you may not initiate litigation
-(including a cross-claim or counterclaim in a lawsuit) alleging that
-any patent claim is infringed by making, using, selling, offering for
-sale, or importing the Program or any portion of it.
-
-#### 11. Patents
-
-A "contributor" is a copyright holder who authorizes use under this
-License of the Program or a work on which the Program is based. The
-work thus licensed is called the contributor's "contributor version".
-
-A contributor's "essential patent claims" are all patent claims owned
-or controlled by the contributor, whether already acquired or
-hereafter acquired, that would be infringed by some manner, permitted
-by this License, of making, using, or selling its contributor version,
-but do not include claims that would be infringed only as a
-consequence of further modification of the contributor version. For
-purposes of this definition, "control" includes the right to grant
-patent sublicenses in a manner consistent with the requirements of
-this License.
-
-Each contributor grants you a non-exclusive, worldwide, royalty-free
-patent license under the contributor's essential patent claims, to
-make, use, sell, offer for sale, import and otherwise run, modify and
-propagate the contents of its contributor version.
-
-In the following three paragraphs, a "patent license" is any express
-agreement or commitment, however denominated, not to enforce a patent
-(such as an express permission to practice a patent or covenant not to
-sue for patent infringement). To "grant" such a patent license to a
-party means to make such an agreement or commitment not to enforce a
-patent against the party.
-
-If you convey a covered work, knowingly relying on a patent license,
-and the Corresponding Source of the work is not available for anyone
-to copy, free of charge and under the terms of this License, through a
-publicly available network server or other readily accessible means,
-then you must either (1) cause the Corresponding Source to be so
-available, or (2) arrange to deprive yourself of the benefit of the
-patent license for this particular work, or (3) arrange, in a manner
-consistent with the requirements of this License, to extend the patent
-license to downstream recipients. "Knowingly relying" means you have
-actual knowledge that, but for the patent license, your conveying the
-covered work in a country, or your recipient's use of the covered work
-in a country, would infringe one or more identifiable patents in that
-country that you have reason to believe are valid.
-
-If, pursuant to or in connection with a single transaction or
-arrangement, you convey, or propagate by procuring conveyance of, a
-covered work, and grant a patent license to some of the parties
-receiving the covered work authorizing them to use, propagate, modify
-or convey a specific copy of the covered work, then the patent license
-you grant is automatically extended to all recipients of the covered
-work and works based on it.
-
-A patent license is "discriminatory" if it does not include within the
-scope of its coverage, prohibits the exercise of, or is conditioned on
-the non-exercise of one or more of the rights that are specifically
-granted under this License. You may not convey a covered work if you
-are a party to an arrangement with a third party that is in the
-business of distributing software, under which you make payment to the
-third party based on the extent of your activity of conveying the
-work, and under which the third party grants, to any of the parties
-who would receive the covered work from you, a discriminatory patent
-license (a) in connection with copies of the covered work conveyed by
-you (or copies made from those copies), or (b) primarily for and in
-connection with specific products or compilations that contain the
-covered work, unless you entered into that arrangement, or that patent
-license was granted, prior to 28 March 2007.
-
-Nothing in this License shall be construed as excluding or limiting
-any implied license or other defenses to infringement that may
-otherwise be available to you under applicable patent law.
-
-#### 12. No Surrender of Others' Freedom
-
-If conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License. If you cannot convey a
-covered work so as to satisfy simultaneously your obligations under
-this License and any other pertinent obligations, then as a
-consequence you may not convey it at all. For example, if you agree to
-terms that obligate you to collect a royalty for further conveying
-from those to whom you convey the Program, the only way you could
-satisfy both those terms and this License would be to refrain entirely
-from conveying the Program.
-
-#### 13. Use with the GNU Affero General Public License
-
-Notwithstanding any other provision of this License, you have
-permission to link or combine any covered work with a work licensed
-under version 3 of the GNU Affero General Public License into a single
-combined work, and to convey the resulting work. The terms of this
-License will continue to apply to the part which is the covered work,
-but the special requirements of the GNU Affero General Public License,
-section 13, concerning interaction through a network will apply to the
-combination as such.
-
-#### 14. Revised Versions of this License
-
-The Free Software Foundation may publish revised and/or new versions
-of the GNU General Public License from time to time. Such new versions
-will be similar in spirit to the present version, but may differ in
-detail to address new problems or concerns.
-
-Each version is given a distinguishing version number. If the Program
-specifies that a certain numbered version of the GNU General Public
-License "or any later version" applies to it, you have the option of
-following the terms and conditions either of that numbered version or
-of any later version published by the Free Software Foundation. If the
-Program does not specify a version number of the GNU General Public
-License, you may choose any version ever published by the Free
-Software Foundation.
-
-If the Program specifies that a proxy can decide which future versions
-of the GNU General Public License can be used, that proxy's public
-statement of acceptance of a version permanently authorizes you to
-choose that version for the Program.
-
-Later license versions may give you additional or different
-permissions. However, no additional obligations are imposed on any
-author or copyright holder as a result of your choosing to follow a
-later version.
-
-#### 15. Disclaimer of Warranty
-
-THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
-APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
-HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT
-WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT
-LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND
-PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE
-DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR
-CORRECTION.
-
-#### 16. Limitation of Liability
-
-IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR
-CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
-INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES
-ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT
-NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR
-LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM
-TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER
-PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
-
-#### 17. Interpretation of Sections 15 and 16
-
-If the disclaimer of warranty and limitation of liability provided
-above cannot be given local legal effect according to their terms,
-reviewing courts shall apply local law that most closely approximates
-an absolute waiver of all civil liability in connection with the
-Program, unless a warranty or assumption of liability accompanies a
-copy of the Program in return for a fee.
-
-END OF TERMS AND CONDITIONS
+## License
+The license for use and distribution is the same as that of the original 7-Zip.  
+Additionally, code in `DarkMode` folder is from [darkmodelib](https://github.com/ozone10/darkmodelib) which is licensed under the MIT License or the Mozilla Public License, version 2.0.  
+
+## Dark mode source code (darkmodelib)
+
+Copyright (c) 2024-2025 oZone10
+
+Mozilla Public License Version 2.0
+--------------------
+
+    Copyright (c) 2025 oZone10
+    This Source Code Form is subject to the terms of the Mozilla Public
+    License, v. 2.0. If a copy of the MPL was not distributed with this
+    file, You can obtain one at https://mozilla.org/MPL/2.0/.
+
+MIT License
+--------------------
+
+    Copyright (c) 2024-2025 ozone10
+
+    Permission is hereby granted, free of charge, to any person obtaining a copy
+    of this software and associated documentation files (the "Software"), to deal
+    in the Software without restriction, including without limitation the rights
+    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+    copies of the Software, and to permit persons to whom the Software is
+    furnished to do so, subject to the following conditions:
+
+    The above copyright notice and this permission notice shall be included in all
+    copies or substantial portions of the Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+    SOFTWARE.
+
+## 7-Zip source code
+
+### License for use and distribution
+
+
+7-Zip Copyright (C) 1999-2024 Igor Pavlov.
+
+The licenses for files are:
+
+- CPP/7zip/Compress/Rar* files: the "GNU LGPL" with "unRAR license restriction"
+- CPP/7zip/Compress/LzfseDecoder.cpp: the "BSD 3-clause License"
+- C/ZstdDec.c: the "BSD 3-clause License"
+- C/Xxh64.c: the "BSD 2-clause License"
+- Some files are "public domain" files, if "public domain" status is stated in source file.
+- the "GNU LGPL" for all other files. If there is no license information in
+    some source file, that file is under the "GNU LGPL".
+
+The "GNU LGPL" with "unRAR license restriction" means that you must follow both 
+"GNU LGPL" rules and "unRAR license restriction" rules.
+
+
+
+
+GNU LGPL information
+--------------------
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, 
+    you can get a copy of the GNU Lesser General Public License from
+    http://www.gnu.org/
+
+
+
+
+BSD 3-clause License in 7-Zip code
+----------------------------------
+
+The "BSD 3-clause License" is used for the following code in 7z.dll
+1. LZFSE data decompression.
+        CPP/7zip/Compress/LzfseDecoder.cpp.
+    That code was derived from the code in the "LZFSE compression library" developed by Apple Inc,
+    that also uses the "BSD 3-clause License".
+2. ZSTD data decompression.
+        C/ZstdDec.c
+    that code was developed using original zstd decoder code as reference code.
+    The original zstd decoder code was developed by Facebook Inc,
+    that also uses the "BSD 3-clause License".
+
+Copyright (c) 2015-2016, Apple Inc. All rights reserved.  
+Copyright (c) Facebook, Inc. All rights reserved.  
+Copyright (c) 2023-2024 Igor Pavlov.  
+
+Text of the "BSD 3-clause License"
+----------------------------------
+
+        Redistribution and use in source and binary forms, with or without modification,
+        are permitted provided that the following conditions are met:
+
+        1. Redistributions of source code must retain the above copyright notice, this
+        list of conditions and the following disclaimer.
+
+        2. Redistributions in binary form must reproduce the above copyright notice,
+        this list of conditions and the following disclaimer in the documentation
+        and/or other materials provided with the distribution.
+
+        3. Neither the name of the copyright holder nor the names of its contributors may
+        be used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+        ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+        WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+        DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+        ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+        (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+        LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+        ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+        (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+        SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+---
+
+
+
+
+BSD 2-clause License in 7-Zip code
+----------------------------------
+
+  The "BSD 2-clause License" is used for the XXH64 code in 7-Zip.
+    C/Xxh64.c
+
+  XXH64 code in 7-Zip was derived from the original XXH64 code developed by Yann Collet.
+
+  Copyright (c) 2012-2021 Yann Collet.  
+  Copyright (c) 2023-2024 Igor Pavlov.
+
+Text of the "BSD 2-clause License"
+----------------------------------
+
+        Redistribution and use in source and binary forms, with or without modification,
+        are permitted provided that the following conditions are met:
+
+        1. Redistributions of source code must retain the above copyright notice, this
+        list of conditions and the following disclaimer.
+
+        2. Redistributions in binary form must reproduce the above copyright notice,
+        this list of conditions and the following disclaimer in the documentation
+        and/or other materials provided with the distribution.
+
+        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+        ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+        WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+        DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+        ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+        (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+        LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+        ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+        (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+        SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+---
+
+
+
+
+unRAR license restriction
+-------------------------
+
+The decompression engine for RAR archives was developed using source
+code of unRAR program.  
+All copyrights to original unRAR code are owned by Alexander Roshal.
+
+The license for original unRAR code has the following restriction:
+
+    The unRAR sources cannot be used to re-create the RAR compression algorithm,
+    which is proprietary. Distribution of modified unRAR sources in separate form
+    or as a part of other software is permitted, provided that it is clearly
+    stated in the documentation and source comments that the code may
+    not be used to develop a RAR (WinRAR) compatible archiver.
+
+--
+
diff --git a/README.md b/README.md
index 31305c01d..37675fea4 100644
--- a/README.md
+++ b/README.md
@@ -4,12 +4,12 @@
 [![Build status](https://img.shields.io/github/actions/workflow/status/ozone10/7zip-Dark7zip/build_win.yml?logo=Github)](https://github.com/ozone10/7zip-Dark7zip/actions)
 [![Latest release](https://img.shields.io/github/v/release/ozone10/7zip-Dark7zip?include_prereleases)](https://github.com/ozone10/7zip-Dark7zip/releases/latest)
 [![Total downloads](https://img.shields.io/github/downloads/ozone10/7zip-Dark7zip/total.svg)](https://github.com/ozone10/7zip-Dark7zip/releases)
-[![License](https://img.shields.io/github/license/ozone10/7zip-Dark7zip?color=green)](https://www.gnu.org/licenses/gpl-3.0.en.html)
-[![License-MIT](https://img.shields.io/badge/license-MIT-green)](./LICENSE-MIT.md)
+[![License](https://img.shields.io/badge/License-7--Zip-black?logo=data:image/svg%2bxml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0IiBmaWxsPSIjRkZGRkZGIj48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xMi43NSAyLjc1YS43NS43NSAwIDAwLTEuNSAwVjQuNUg5LjI3NmExLjc1IDEuNzUgMCAwMC0uOTg1LjMwM0w2LjU5NiA1Ljk1N0EuMjUuMjUgMCAwMTYuNDU1IDZIMi4zNTNhLjc1Ljc1IDAgMTAwIDEuNUgzLjkzTC41NjMgMTUuMThhLjc2Mi43NjIgMCAwMC4yMS44OGMuMDguMDY0LjE2MS4xMjUuMzA5LjIyMS4xODYuMTIxLjQ1Mi4yNzguNzkyLjQzMy42OC4zMTEgMS42NjIuNjIgMi44NzYuNjJhNi45MTkgNi45MTkgMCAwMDIuODc2LS42MmMuMzQtLjE1NS42MDYtLjMxMi43OTItLjQzMy4xNS0uMDk3LjIzLS4xNTguMzEtLjIyM2EuNzUuNzUgMCAwMC4yMDktLjg3OEw1LjU2OSA3LjVoLjg4NmMuMzUxIDAgLjY5NC0uMTA2Ljk4NC0uMzAzbDEuNjk2LTEuMTU0QS4yNS4yNSAwIDAxOS4yNzUgNmgxLjk3NXYxNC41SDYuNzYzYS43NS43NSAwIDAwMCAxLjVoMTAuNDc0YS43NS43NSAwIDAwMC0xLjVIMTIuNzVWNmgxLjk3NGMuMDUgMCAuMS4wMTUuMTQuMDQzbDEuNjk3IDEuMTU0Yy4yOS4xOTcuNjMzLjMwMy45ODQuMzAzaC44ODZsLTMuMzY4IDcuNjhhLjc1Ljc1IDAgMDAuMjMuODk2Yy4wMTIuMDA5IDAgMCAuMDAyIDBhMy4xNTQgMy4xNTQgMCAwMC4zMS4yMDZjLjE4NS4xMTIuNDUuMjU2Ljc5LjRhNy4zNDMgNy4zNDMgMCAwMDIuODU1LjU2OCA3LjM0MyA3LjM0MyAwIDAwMi44NTYtLjU2OWMuMzM4LS4xNDMuNjA0LS4yODcuNzktLjM5OWEzLjUgMy41IDAgMDAuMzEtLjIwNi43NS43NSAwIDAwLjIzLS44OTZMMjAuMDcgNy41aDEuNTc4YS43NS43NSAwIDAwMC0xLjVoLTQuMTAyYS4yNS4yNSAwIDAxLS4xNC0uMDQzbC0xLjY5Ny0xLjE1NGExLjc1IDEuNzUgMCAwMC0uOTg0LS4zMDNIMTIuNzVWMi43NXpNMi4xOTMgMTUuMTk4YTUuNDE4IDUuNDE4IDAgMDAyLjU1Ny42MzUgNS40MTggNS40MTggMCAwMDIuNTU3LS42MzVMNC43NSA5LjM2OGwtMi41NTcgNS44M3ptMTQuNTEtLjAyNGMuMDgyLjA0LjE3NC4wODMuMjc1LjEyNi41My4yMjMgMS4zMDUuNDUgMi4yNzIuNDVhNS44NDYgNS44NDYgMCAwMDIuNTQ3LS41NzZMMTkuMjUgOS4zNjdsLTIuNTQ3IDUuODA3eiI+PC9wYXRoPjwvc3ZnPg==
+)](LICENSE.md)
 [![PayPal.me](https://img.shields.io/badge/PayPal-me-blue.svg?maxAge=2592000)](https://paypal.me/ozone10/)
 ---
 
-Dark7zip is project to experiment with dark mode for [7-Zip](https://github.com/ip7z/7zip) and its fork [7-Zip-zstd](#7-zip-zstd).  
+Dark7zip is project to experiment with dark mode via [darkmodelib](https://github.com/ozone10/darkmodelib) library for [7-Zip](https://github.com/ip7z/7zip) and its fork [7-Zip-zstd](#7-zip-zstd).  
 It is mainly for Windows 10 and Windows 11. Some controls might, might not use dark/custom colors on older OS.
 
 * * *
@@ -101,6 +101,9 @@ Replace 7z original files (e.g. `C:\Program Files\7-Zip\`) with files from downl
     - 2 - apply Mica material
     - 3 - apply "acrylic" effect
     - 4 - apply Mica Alt material
+  - colorizeTitleBar - on Windows 11 applies same colors as dialog background and static text on title bar, with `micaExtend=1` this option will be ignored
+    - 0 - Use system colors (default)
+    - 1 - Use custom colors (backgroundDlg and text)
 
 Values for custom colors are in RGB hex format - RRGGBB.
 
@@ -142,6 +145,7 @@ roundCorner = 0
 borderColor = "FFFFFF"
 mica = 0
 micaExtend = 0
+colorizeTitleBar = 0
 
 [dark.colors]
 background =            "202020"
@@ -168,6 +172,7 @@ edgeHeader =            "646464"
 roundCorner = 0
 borderColor = "FFFFFF"
 mica = 0
+colorizeTitleBar = 0
 
 [light.colors]
 background =            "F0F0F0"
@@ -207,10 +212,12 @@ Source code for dark mode for it is in [7z-zstd](https://github.com/ozone10/7zip
 For more information about 7-Zip-zstd fork check [7-Zip-zstd](https://github.com/mcmilk/7-Zip-zstd).
 
 ## License
+The license for use and distribution is the same as that of the original 7-Zip.  
+Additionally, code related to dark mode in `DarkMode` folder is licensed under the MIT License or the Mozilla Public License, version 2.0.  
+[MPL-2.0](DarkMode\LICENSE.md)  
+[MIT](DarkMode\LICENSE-MIT.md)
 
-Most code related to dark mode is under license MIT, or GPLv3 or later version.
-
-For 7-Zip check DOC folder for information on used license.  
+For details on the 7-Zip license, see the `DOC` folder.  
 [License.txt](DOC/License.txt)  
 [readme.txt](DOC/readme.txt)
 
diff --git a/build.cmd b/build.cmd
index 7a94bb446..f0e930995 100644
--- a/build.cmd
+++ b/build.cmd
@@ -49,14 +49,15 @@ if not exist "%PLATFORM%-bin\" mkdir "%PLATFORM%-bin"
 copy "CPP\7zip\Bundles\SFXWin\%PLATFORM%\7z.sfx" "%PLATFORM%-bin"
 copy "CPP\7zip\UI\FileManager\%PLATFORM%\7zFM.exe" "%PLATFORM%-bin"
 copy "CPP\7zip\UI\GUI\%PLATFORM%\7zG.exe" "%PLATFORM%-bin"
-copy "DarkMode\7zDark.ini" "%PLATFORM%-bin"
+copy "DarkMode\7zRes\7zDark.ini" "%PLATFORM%-bin"
+copy "LICENSE.md" "%PLATFORM%-bin"
 
 rem Build the fluent version only for x64
 if "%PLATFORM%" == "x64" (
   echo Building fluent version
   if not exist "tmp\" mkdir "tmp"
   move "CPP\7zip\UI\FileManager\*.bmp" "tmp" >nul
-  xcopy "DarkMode\icons\*.bmp" "CPP\7zip\UI\FileManager" /Y >nul
+  xcopy "DarkMode\7zRes\icons\*.bmp" "CPP\7zip\UI\FileManager" /Y >nul
   
   if exist "CPP\7zip\UI\FileManager\%PLATFORM%\resource.res" (
     del /F /Q "CPP\7zip\UI\FileManager\%PLATFORM%\resource.res"
@@ -70,7 +71,8 @@ if "%PLATFORM%" == "x64" (
   copy "CPP\7zip\Bundles\SFXWin\%PLATFORM%\7z.sfx" "%PLATFORM%-fluent-bin"
   copy "CPP\7zip\UI\FileManager\%PLATFORM%\7zFM.exe" "%PLATFORM%-fluent-bin"
   copy "CPP\7zip\UI\GUI\%PLATFORM%\7zG.exe" "%PLATFORM%-fluent-bin"
-  copy "DarkMode\7zDark.ini" "%PLATFORM%-fluent-bin"
+  copy "DarkMode\7zRes\7zDark.ini" "%PLATFORM%-fluent-bin"
+  copy "LICENSE.md" "%PLATFORM%-fluent-bin"
 
   xcopy "tmp\*.bmp" "CPP\7zip\UI\FileManager" /Y >nul
   rmdir /S /Q "tmp"
