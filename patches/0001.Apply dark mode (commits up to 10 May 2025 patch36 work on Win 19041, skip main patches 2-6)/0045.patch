From 1c38cef89ef6ea61a8562c7419732242d95b727e Mon Sep 17 00:00:00 2001
From: ozone10 <positronix10@gmail.com>
Date: Wed, 4 Jun 2025 07:50:55 +0200
Subject: [PATCH] Tweaks

---
 DarkMode/DarkMode.cpp         |  26 +++---
 DarkMode/DarkModeSubclass.cpp | 171 ++++++++++++++++++++--------------
 DarkMode/DarkModeSubclass.h   |   4 +-
 DarkMode/IatHook.h            |  12 +--
 4 files changed, 122 insertions(+), 91 deletions(-)

diff --git a/DarkMode/DarkMode.cpp b/DarkMode/DarkMode.cpp
index 11f3d3bf1..fc6b92977 100644
--- a/DarkMode/DarkMode.cpp
+++ b/DarkMode/DarkMode.cpp
@@ -37,6 +37,8 @@ extern PIMAGE_THUNK_DATA FindDelayLoadThunkInModule(void* moduleBase, const char
 
 #if defined(_MSC_VER) && _MSC_VER >= 1800
 #pragma warning(disable : 4191)
+#elif defined(__GNUC__)
+#include <cwchar>
 #endif
 
 template <typename P>
@@ -45,7 +47,7 @@ static auto ReplaceFunction(IMAGE_THUNK_DATA* addr, P newFunction) -> P
 	DWORD oldProtect = 0;
 	if (VirtualProtect(addr, sizeof(IMAGE_THUNK_DATA), PAGE_READWRITE, &oldProtect) == FALSE)
 		return nullptr;
-	uintptr_t oldFunction = addr->u1.Function;
+	const uintptr_t oldFunction = addr->u1.Function;
 	addr->u1.Function = reinterpret_cast<uintptr_t>(newFunction);
 	VirtualProtect(addr, sizeof(IMAGE_THUNK_DATA), oldProtect, &oldProtect);
 	return reinterpret_cast<P>(oldFunction);
@@ -259,7 +261,7 @@ void RefreshTitleBarThemeColor(HWND hWnd)
 bool IsColorSchemeChangeMessage(LPARAM lParam)
 {
 	bool isMsg = false;
-	if ((lParam != static_cast<LPARAM>(NULL))
+	if ((lParam != 0) // NULL
 		&& (lstrcmpiW(reinterpret_cast<LPCWSTR>(lParam), L"ImmersiveColorSet") == 0)
 		&& _RefreshImmersiveColorPolicyState != nullptr)
 	{
@@ -318,33 +320,31 @@ static bool IsWindowOrParentUsingDarkScrollBar(HWND hWnd)
 #else
 		return container.count(hWndToCheck) != 0;
 #endif
-		};
+	};
 
 	if (hasElement(g_darkScrollBarWindows, hWnd))
 		return true;
 
-	if (hWnd != hRoot && hasElement(g_darkScrollBarWindows, hRoot))
-		return true;
-	return false;
+	return (hWnd != hRoot && hasElement(g_darkScrollBarWindows, hRoot));
 }
 
 static HTHEME WINAPI MyOpenNcThemeData(HWND hWnd, LPCWSTR pszClassList)
 {
-	if (wcscmp(pszClassList, WC_SCROLLBAR) == 0)
+	if (std::wcscmp(pszClassList, WC_SCROLLBAR) == 0)
 	{
 		if (IsWindowOrParentUsingDarkScrollBar(hWnd))
 		{
 			hWnd = nullptr;
 			pszClassList = L"Explorer::ScrollBar";
 		}
-		else if (g_darkModeEnabled)
-		{
-			hWnd = nullptr;
-			pszClassList = L"DarkMode_Explorer::ScrollBar";
-		}
+		//else if (g_darkModeEnabled)
+		//{
+		//	hWnd = nullptr;
+		//	pszClassList = L"DarkMode_Explorer::ScrollBar";
+		//}
 	}
 	return _OpenNcThemeData(hWnd, pszClassList);
-};
+}
 
 static void FixDarkScrollBar()
 {
diff --git a/DarkMode/DarkModeSubclass.cpp b/DarkMode/DarkModeSubclass.cpp
index 0261485d7..0e1d8134c 100644
--- a/DarkMode/DarkModeSubclass.cpp
+++ b/DarkMode/DarkModeSubclass.cpp
@@ -52,7 +52,12 @@
 
 #include "Version.h"
 
-#ifdef __GNUC__
+#if defined(_MSC_VER)
+#pragma comment(lib, "dwmapi.lib")
+#pragma comment(lib, "uxtheme.lib")
+#pragma comment(lib, "Comctl32.lib")
+#pragma comment(lib, "Gdi32.lib")
+#elif defined(__GNUC__)
 #include <cstdint>
 #define DWMWA_USE_IMMERSIVE_DARK_MODE 20
 constexpr int CP_DROPDOWNITEM = 9; // for some reason mingw use only enum up to 8
@@ -74,13 +79,6 @@ constexpr int CP_DROPDOWNITEM = 9; // for some reason mingw use only enum up to
 //#define WM_GETDPISCALEDSIZE 0x02E4
 //#endif
 
-#ifdef _MSC_VER
-#pragma comment(lib, "dwmapi.lib")
-#pragma comment(lib, "uxtheme.lib")
-#pragma comment(lib, "Comctl32.lib")
-#pragma comment(lib, "Gdi32.lib")
-#endif
-
 static constexpr COLORREF HEXRGB(DWORD rrggbb)
 {
 	// from 0xRRGGBB like natural #RRGGBB
@@ -107,20 +105,23 @@ static bool cmpWndClassName(HWND hWnd, const wchar_t* classNameToCmp)
 #if !defined(_DARKMODELIB_NO_INI_CONFIG)
 static std::wstring getIniPath(const std::wstring& iniFilename)
 {
-	wchar_t buffer[MAX_PATH]{};
-	::GetModuleFileName(nullptr, buffer, MAX_PATH);
+	std::array<wchar_t, MAX_PATH> buffer{};
+	const auto strLen = static_cast<size_t>(::GetModuleFileNameW(nullptr, buffer.data(), MAX_PATH));
+	if (strLen == 0)
+	{
+		return L"";
+	}
 
-	wchar_t* lastSlash = wcsrchr(buffer, L'\\');
-	if (lastSlash != nullptr)
+	wchar_t* lastSlash = std::wcsrchr(buffer.data(), L'\\');
+	if (lastSlash == nullptr)
 	{
-		*lastSlash = L'\0';
-		std::wstring iniPath(buffer);
-		iniPath += L"\\";
-		iniPath += iniFilename;
-		iniPath += L".ini";
-		return iniPath;
+		return L"";
 	}
-	return L"";
+
+	*lastSlash = L'\0';
+	std::wstring iniPath(buffer.data());
+	iniPath += L"\\" + iniFilename + L".ini";
+	return iniPath;
 }
 
 static bool fileExists(const std::wstring& filePath)
@@ -172,24 +173,24 @@ static bool setClrFromIni(const std::wstring& sectionName, const std::wstring& k
 
 namespace DarkMode
 {
-	int getLibInfo(LibInfoType libInfoType)
+	int getLibInfo(LibInfo libInfoType)
 	{
 		switch (libInfoType)
 		{
-			case LibInfoType::maxValue:
-			case LibInfoType::featureCheck:
-				return static_cast<int>(LibInfoType::maxValue);
+			case LibInfo::maxValue:
+			case LibInfo::featureCheck:
+				return static_cast<int>(LibInfo::maxValue);
 
-			case LibInfoType::verMajor:
+			case LibInfo::verMajor:
 				return DM_VERSION_MAJOR;
 
-			case LibInfoType::verMinor:
+			case LibInfo::verMinor:
 				return DM_VERSION_MINOR;
 
-			case LibInfoType::verRevision:
+			case LibInfo::verRevision:
 				return DM_VERSION_REVISION;
 
-			case LibInfoType::iathookExternal:
+			case LibInfo::iathookExternal:
 			{
 #if defined(_DARKMODELIB_EXTERNAL_IATHOOK)
 				return TRUE;
@@ -198,7 +199,7 @@ namespace DarkMode
 #endif
 			}
 
-			case LibInfoType::iniConfigUsed:
+			case LibInfo::iniConfigUsed:
 			{
 #if !defined(_DARKMODELIB_NO_INI_CONFIG)
 				return TRUE;
@@ -207,7 +208,7 @@ namespace DarkMode
 #endif
 			}
 
-			case LibInfoType::allowOldOS:
+			case LibInfo::allowOldOS:
 			{
 #if defined(_DARKMODELIB_ALLOW_OLD_OS)
 				return TRUE;
@@ -216,7 +217,7 @@ namespace DarkMode
 #endif
 			}
 
-			case LibInfoType::useDlgProcCtl:
+			case LibInfo::useDlgProcCtl:
 			{
 #if defined(_DARKMODELIB_DLG_PROC_CTLCOLOR_RETURNS)
 				return TRUE;
@@ -224,10 +225,8 @@ namespace DarkMode
 				return FALSE;
 #endif
 			}
-
-			default:
-				return -1;
 		}
+		return -1; // should never happen
 	}
 
 	enum class DarkModeType : std::uint8_t
@@ -261,7 +260,7 @@ namespace DarkMode
 		settingChange   = 17
 	};
 
-	enum class WinModeType : std::uint8_t
+	enum class WinMode : std::uint8_t
 	{
 		disabled,
 		light,
@@ -283,7 +282,7 @@ namespace DarkMode
 		TreeViewStyle _treeViewStyle = TreeViewStyle::classic;
 		bool _micaExtend = false;
 		DarkModeType _dmType = DarkModeType::dark;
-		WinModeType _windowsModeType = WinModeType::disabled;
+		WinMode _windowsMode = WinMode::disabled;
 		bool _isInit = false;
 		bool _isInitExperimental = false;
 
@@ -293,7 +292,7 @@ namespace DarkMode
 #endif
 	} g_dmCfg;
 
-	// range to determine when it should be better to use classic style
+	// range to determine when it should be better to use classic style for tree view
 	constexpr double MiddleGrayRange = 2.0;
 
 	static struct
@@ -590,44 +589,43 @@ namespace DarkMode
 
 			switch (_tone)
 			{
-				case DarkMode::ColorTone::red:
+				case ColorTone::red:
 				{
 					_colors = darkRedColors;
 					break;
 				}
 
-				case DarkMode::ColorTone::green:
+				case ColorTone::green:
 				{
 					_colors = darkGreenColors;
 					break;
 				}
 
-				case DarkMode::ColorTone::blue:
+				case ColorTone::blue:
 				{
 					_colors = darkBlueColors;
 					break;
 				}
 
-				case DarkMode::ColorTone::purple:
+				case ColorTone::purple:
 				{
 					_colors = darkPurpleColors;
 					break;
 				}
 
-				case DarkMode::ColorTone::cyan:
+				case ColorTone::cyan:
 				{
 					_colors = darkCyanColors;
 					break;
 				}
 
-				case DarkMode::ColorTone::olive:
+				case ColorTone::olive:
 				{
 					_colors = darkOliveColors;
 					break;
 				}
 
-				case DarkMode::ColorTone::black:
-				default:
+				case ColorTone::black:
 				{
 					_colors = darkColors;
 					break;
@@ -889,28 +887,28 @@ namespace DarkMode
 			case 0:
 			{
 				g_dmCfg._dmType = DarkModeType::light;
-				g_dmCfg._windowsModeType = WinModeType::disabled;
+				g_dmCfg._windowsMode = WinMode::disabled;
 				break;
 			}
 
 			case 2:
 			{
 				g_dmCfg._dmType = DarkMode::isDarkModeReg() ? DarkModeType::dark : DarkModeType::light;
-				g_dmCfg._windowsModeType = WinModeType::light;
+				g_dmCfg._windowsMode = WinMode::light;
 				break;
 			}
 
 			case 3:
 			{
 				g_dmCfg._dmType = DarkModeType::classic;
-				g_dmCfg._windowsModeType = WinModeType::disabled;
+				g_dmCfg._windowsMode = WinMode::disabled;
 				break;
 			}
 
 			case 4:
 			{
 				g_dmCfg._dmType = DarkMode::isDarkModeReg() ? DarkModeType::dark : DarkModeType::classic;
-				g_dmCfg._windowsModeType = WinModeType::classic;
+				g_dmCfg._windowsMode = WinMode::classic;
 				break;
 			}
 
@@ -918,7 +916,7 @@ namespace DarkMode
 			default:
 			{
 				g_dmCfg._dmType = DarkModeType::dark;
-				g_dmCfg._windowsModeType = WinModeType::disabled;
+				g_dmCfg._windowsMode = WinMode::disabled;
 				break;
 			}
 		}
@@ -1182,7 +1180,7 @@ namespace DarkMode
 
 	bool isWindowsModeEnabled()
 {
-	return g_dmCfg._windowsModeType != WinModeType::disabled;
+	return g_dmCfg._windowsMode != WinMode::disabled;
 }
 
 	bool isWindows10()
@@ -1608,7 +1606,7 @@ namespace DarkMode
 		::GetThemeBackgroundContentRect(hTheme, hdc, iPartID, iStateID, &rcClient, &rcText);
 
 		RECT rcBackground{ rcClient };
-		if ((dtFlags & DT_SINGLELINE) == DT_SINGLELINE)
+		if (!isMultiline)
 		{
 			rcBackground.top += (rcText.bottom - rcText.top - szBox.cy) / 2;
 		}
@@ -1856,7 +1854,7 @@ namespace DarkMode
 		const auto& hTheme = buttonData._themeData.getHTheme();
 
 		const bool isDisabled = ::IsWindowEnabled(hWnd) == FALSE;
-		const int iPartID = BP_GROUPBOX;
+		constexpr int iPartID = BP_GROUPBOX;
 		const int iStateID = isDisabled ? GBS_DISABLED : GBS_NORMAL;
 
 		bool isFontCreated = false;
@@ -1936,7 +1934,7 @@ namespace DarkMode
 
 			DWORD dtFlags = isCenter ? DT_CENTER : DT_LEFT;
 
-			if (::SendMessage(hWnd, WM_QUERYUISTATE, 0, 0) != static_cast<LRESULT>(NULL))
+			if (::SendMessage(hWnd, WM_QUERYUISTATE, 0, 0) != 0) // NULL
 			{
 				dtFlags |= DT_HIDEPREFIX;
 			}
@@ -2212,7 +2210,7 @@ namespace DarkMode
 			}
 
 			DarkMode::paintRoundRect(hdc, rect, hPen, hBrush, roundness, roundness);
-			};
+		};
 
 		paintUpDownBtn(upDownData._rcPrev, isHotPrev);
 		paintUpDownBtn(upDownData._rcNext, isHotNext);
@@ -2458,8 +2456,20 @@ namespace DarkMode
 					// would be better, than getCtrlBackgroundBrush(),
 					// however default getBackgroundBrush() has same color
 					// as getDlgBackgroundBrush()
-					HBRUSH hBrush = isSelectedTab ? DarkMode::getDlgBackgroundBrush() : (isHot ? DarkMode::getHotBackgroundBrush() : DarkMode::getCtrlBackgroundBrush());
-					::FillRect(hdc, &rcItem, hBrush);
+					auto getBrush = [&]() -> HBRUSH {
+						if (isSelectedTab)
+						{
+							return DarkMode::getDlgBackgroundBrush();
+						}
+
+						if (isHot)
+						{
+							return DarkMode::getHotBackgroundBrush();
+						}
+						return DarkMode::getCtrlBackgroundBrush();
+					};
+
+					::FillRect(hdc, &rcItem, getBrush());
 					::SetTextColor(hdc, (isHot || isSelectedTab) ? DarkMode::getTextColor() : DarkMode::getDarkerTextColor());
 				}
 
@@ -2934,7 +2944,20 @@ namespace DarkMode
 		RECT rcArrow{ cbi.rcButton };
 		rcArrow.left -= 1;
 
-		HBRUSH hBrush = isDisabled ? DarkMode::getDlgBackgroundBrush() : (isHot ? DarkMode::getHotBackgroundBrush() : DarkMode::getCtrlBackgroundBrush());
+		auto getBrush = [&]() -> HBRUSH {
+			if (isDisabled)
+			{
+				return DarkMode::getDlgBackgroundBrush();
+			}
+
+			if (isHot)
+			{
+				return DarkMode::getHotBackgroundBrush();
+			}
+			return DarkMode::getCtrlBackgroundBrush();
+		};
+
+		HBRUSH hBrush = getBrush();
 
 		// CBS_DROPDOWN and CBS_SIMPLE text is handled by parent by WM_CTLCOLOREDIT
 		if (comboboxData._cbStyle == CBS_DROPDOWNLIST)
@@ -2942,7 +2965,7 @@ namespace DarkMode
 			// erase background on item change
 			::FillRect(hdc, &rcClient, hBrush);
 
-			auto index = static_cast<int>(::SendMessage(hWnd, CB_GETCURSEL, 0, 0));
+			const auto index = static_cast<int>(::SendMessage(hWnd, CB_GETCURSEL, 0, 0));
 			if (index != CB_ERR)
 			{
 				const auto bufferLen = static_cast<size_t>(::SendMessage(hWnd, CB_GETLBTEXTLEN, static_cast<WPARAM>(index), 0));
@@ -3006,8 +3029,20 @@ namespace DarkMode
 			}
 			else
 			{
-				const COLORREF clrText = isDisabled ? DarkMode::getDisabledTextColor() : (isHot ? DarkMode::getTextColor() : DarkMode::getDarkerTextColor());
-				::SetTextColor(hdc, clrText);
+				auto getTextClr = [&]() -> COLORREF {
+					if (isDisabled)
+					{
+						return DarkMode::getDisabledTextColor();
+					}
+
+					if (isHot)
+					{
+						return DarkMode::getTextColor();
+					}
+					return DarkMode::getDarkerTextColor();
+				};
+
+				::SetTextColor(hdc, getTextClr());
 				::DrawText(hdc, L"Ë…", -1, &rcArrow, DT_NOPREFIX | DT_CENTER | DT_VCENTER | DT_SINGLELINE | DT_NOCLIP);
 			}
 		}
@@ -3422,7 +3457,6 @@ namespace DarkMode
 								return CDRF_DODEFAULT;
 						}
 					}
-					break;
 				}
 				break;
 			}
@@ -4086,7 +4120,7 @@ namespace DarkMode
 		}
 	}
 
-	static void paintProgressBar(HWND hWnd, HDC hdc, ProgressBarData& progressBarData)
+	static void paintProgressBar(HWND hWnd, HDC hdc, const ProgressBarData& progressBarData)
 	{
 		const auto& hTheme = progressBarData._themeData.getHTheme();
 
@@ -4842,7 +4876,7 @@ namespace DarkMode
 				const LONG paddingLeft = DarkMode::isThemeDark() ? 1 : 0;
 				const LONG paddingRight = DarkMode::isThemeDark() ? 2 : 1;
 
-				LVITEMINDEX lvii{ static_cast<int>(lplvcd->nmcd.dwItemSpec), 0 };
+				const LVITEMINDEX lvii{ static_cast<int>(lplvcd->nmcd.dwItemSpec), 0 };
 				RECT rcSubitem{
 					lplvcd->nmcd.rc.left
 					, lplvcd->nmcd.rc.top
@@ -5749,7 +5783,7 @@ namespace DarkMode
 				return colorChannel / 12.92;
 			}
 			return std::pow(((colorChannel + 0.055) / 1.055), 2.4);
-			};
+		};
 
 		const double r = linearValue(static_cast<double>(GetRValue(clr)));
 		const double g = linearValue(static_cast<double>(GetGValue(clr)));
@@ -6028,13 +6062,10 @@ namespace DarkMode
 
 	UINT_PTR CALLBACK HookDlgProc(HWND hWnd, UINT uMsg, WPARAM /*wParam*/, LPARAM /*lParam*/)
 	{
-		switch (uMsg)
+		if (uMsg == WM_INITDIALOG)
 		{
-			case WM_INITDIALOG:
-			{
-				DarkMode::setDarkDlgSafe(hWnd);
-				return TRUE;
-			}
+			DarkMode::setDarkDlgSafe(hWnd);
+			return TRUE;
 		}
 		return FALSE;
 	}
diff --git a/DarkMode/DarkModeSubclass.h b/DarkMode/DarkModeSubclass.h
index f299d8dbd..913ed1ee1 100644
--- a/DarkMode/DarkModeSubclass.h
+++ b/DarkMode/DarkModeSubclass.h
@@ -82,7 +82,7 @@ namespace DarkMode
 		dark
 	};
 
-	enum LibInfoType
+	enum LibInfo
 	{
 		featureCheck    = 0,
 		verMajor        = 1,
@@ -95,7 +95,7 @@ namespace DarkMode
 		maxValue        = 8
 	};
 
-	[[nodiscard]] int getLibInfo(LibInfoType libInfoType);
+	[[nodiscard]] int getLibInfo(LibInfo libInfoType);
 
 	// enum DarkModeType { light = 0, dark = 1, classic = 3 }; values
 	void initDarkModeConfig(UINT dmType);
diff --git a/DarkMode/IatHook.h b/DarkMode/IatHook.h
index e738388b1..4a0a82d6a 100644
--- a/DarkMode/IatHook.h
+++ b/DarkMode/IatHook.h
@@ -20,12 +20,12 @@ template <typename T>
 constexpr T DataDirectoryFromModuleBase(void* moduleBase, size_t entryID)
 {
 	auto dosHdr = static_cast<PIMAGE_DOS_HEADER>(moduleBase);
-	auto ntHdr = RVA2VA<PIMAGE_NT_HEADERS>(moduleBase, dosHdr->e_lfanew);
+	auto ntHdr = RVA2VA<PIMAGE_NT_HEADERS>(moduleBase, static_cast<DWORD>(dosHdr->e_lfanew));
 	auto dataDir = ntHdr->OptionalHeader.DataDirectory;
 	return RVA2VA<T>(moduleBase, dataDir[entryID].VirtualAddress);
 }
 
-PIMAGE_THUNK_DATA FindAddressByName(void* moduleBase, PIMAGE_THUNK_DATA impName, PIMAGE_THUNK_DATA impAddr, const char* funcName)
+inline PIMAGE_THUNK_DATA FindAddressByName(void* moduleBase, PIMAGE_THUNK_DATA impName, PIMAGE_THUNK_DATA impAddr, const char* funcName)
 {
 	for (; impName->u1.Ordinal; ++impName, ++impAddr)
 	{
@@ -40,7 +40,7 @@ PIMAGE_THUNK_DATA FindAddressByName(void* moduleBase, PIMAGE_THUNK_DATA impName,
 	return nullptr;
 }
 
-PIMAGE_THUNK_DATA FindAddressByOrdinal(void* /*moduleBase*/, PIMAGE_THUNK_DATA impName, PIMAGE_THUNK_DATA impAddr, uint16_t ordinal)
+inline PIMAGE_THUNK_DATA FindAddressByOrdinal(void* /*moduleBase*/, PIMAGE_THUNK_DATA impName, PIMAGE_THUNK_DATA impAddr, uint16_t ordinal)
 {
 	for (; impName->u1.Ordinal; ++impName, ++impAddr)
 	{
@@ -50,7 +50,7 @@ PIMAGE_THUNK_DATA FindAddressByOrdinal(void* /*moduleBase*/, PIMAGE_THUNK_DATA i
 	return nullptr;
 }
 
-PIMAGE_THUNK_DATA FindIatThunkInModule(void* moduleBase, const char* dllName, const char* funcName)
+inline PIMAGE_THUNK_DATA FindIatThunkInModule(void* moduleBase, const char* dllName, const char* funcName)
 {
 	auto imports = DataDirectoryFromModuleBase<PIMAGE_IMPORT_DESCRIPTOR>(moduleBase, IMAGE_DIRECTORY_ENTRY_IMPORT);
 	for (; imports->Name; ++imports)
@@ -65,7 +65,7 @@ PIMAGE_THUNK_DATA FindIatThunkInModule(void* moduleBase, const char* dllName, co
 	return nullptr;
 }
 
-PIMAGE_THUNK_DATA FindDelayLoadThunkInModule(void* moduleBase, const char* dllName, const char* funcName)
+inline PIMAGE_THUNK_DATA FindDelayLoadThunkInModule(void* moduleBase, const char* dllName, const char* funcName)
 {
 	auto imports = DataDirectoryFromModuleBase<PIMAGE_DELAYLOAD_DESCRIPTOR>(moduleBase, IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT);
 	for (; imports->DllNameRVA; ++imports)
@@ -80,7 +80,7 @@ PIMAGE_THUNK_DATA FindDelayLoadThunkInModule(void* moduleBase, const char* dllNa
 	return nullptr;
 }
 
-PIMAGE_THUNK_DATA FindDelayLoadThunkInModule(void* moduleBase, const char* dllName, uint16_t ordinal)
+inline PIMAGE_THUNK_DATA FindDelayLoadThunkInModule(void* moduleBase, const char* dllName, uint16_t ordinal)
 {
 	auto imports = DataDirectoryFromModuleBase<PIMAGE_DELAYLOAD_DESCRIPTOR>(moduleBase, IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT);
 	for (; imports->DllNameRVA; ++imports)
