From 52731eabb368c65bc5db9d84a9d36fbcb4f73e8f Mon Sep 17 00:00:00 2001
From: ozone10 <positronix10@gmail.com>
Date: Sat, 10 May 2025 17:49:55 +0200
Subject: [PATCH] Tweaks

---
 DarkMode/DarkMode.cpp         | 167 +++++++++++-----------
 DarkMode/DarkModeSubclass.cpp | 262 ++++++++++++++++++----------------
 DarkMode/DarkModeSubclass.h   |   4 +-
 3 files changed, 222 insertions(+), 211 deletions(-)

diff --git a/DarkMode/DarkMode.cpp b/DarkMode/DarkMode.cpp
index 9e785b44a..448f837a3 100644
--- a/DarkMode/DarkMode.cpp
+++ b/DarkMode/DarkMode.cpp
@@ -10,6 +10,9 @@
 #ifndef WIN32_LEAN_AND_MEAN
 #define WIN32_LEAN_AND_MEAN
 #endif
+#ifndef VC_EXTRALEAN
+#define VC_EXTRALEAN
+#endif
 #ifndef NOMINMAX
 #define NOMINMAX
 #endif
@@ -102,17 +105,17 @@ struct WINDOWCOMPOSITIONATTRIBDATA
 template <typename P>
 static auto ptrFn(HMODULE handle, P& pointer, const char* name) -> bool
 {
-	auto p = reinterpret_cast<P>(::GetProcAddress(handle, name));
-	if (p != nullptr)
+	auto ptr = reinterpret_cast<P>(::GetProcAddress(handle, name));
+	if (ptr != nullptr)
 	{
-		pointer = p;
+		pointer = ptr;
 		return true;
 	}
 	return false;
 }
 
 template <typename P>
-bool ptrFn(HMODULE handle, P& pointer, WORD index)
+static auto ptrFn(HMODULE handle, P& pointer, WORD index) -> bool
 {
 	return ptrFn(handle, pointer, MAKEINTRESOURCEA(index));
 }
@@ -129,9 +132,9 @@ using fnIsDarkModeAllowedForWindow = bool (WINAPI*)(HWND hWnd); // ordinal 137
 using fnGetIsImmersiveColorUsingHighContrast = bool (WINAPI*)(IMMERSIVE_HC_CACHE_MODE mode); // ordinal 106
 using fnOpenNcThemeData = HTHEME (WINAPI*)(HWND hWnd, LPCWSTR pszClassList); // ordinal 49
 // 1903 18362
-using fnShouldSystemUseDarkMode = bool (WINAPI*)(); // ordinal 138
+//using fnShouldSystemUseDarkMode = bool (WINAPI*)(); // ordinal 138
 using fnSetPreferredAppMode = PreferredAppMode (WINAPI*)(PreferredAppMode appMode); // ordinal 135, in 1903
-using fnIsDarkModeAllowedForApp = bool (WINAPI*)(); // ordinal 139
+//using fnIsDarkModeAllowedForApp = bool (WINAPI*)(); // ordinal 139
 
 static fnSetWindowCompositionAttribute _SetWindowCompositionAttribute = nullptr;
 static fnShouldAppsUseDarkMode _ShouldAppsUseDarkMode = nullptr;
@@ -152,17 +155,16 @@ static DWORD g_buildNumber = 0;
 
 bool ShouldAppsUseDarkMode()
 {
-	if (!_ShouldAppsUseDarkMode)
+	if (_ShouldAppsUseDarkMode == nullptr)
 	{
 		return false;
 	}
-
 	return _ShouldAppsUseDarkMode();
 }
 
 bool AllowDarkModeForWindow(HWND hWnd, bool allow)
 {
-	if (g_darkModeSupported && _AllowDarkModeForWindow)
+	if (g_darkModeSupported && (_AllowDarkModeForWindow != nullptr))
 		return _AllowDarkModeForWindow(hWnd, allow);
 	return false;
 }
@@ -171,7 +173,7 @@ bool IsHighContrast()
 {
 	HIGHCONTRASTW highContrast{};
 	highContrast.cbSize = sizeof(HIGHCONTRASTW);
-	if (SystemParametersInfoW(SPI_GETHIGHCONTRAST, sizeof(HIGHCONTRASTW), &highContrast, FALSE))
+	if (SystemParametersInfoW(SPI_GETHIGHCONTRAST, sizeof(HIGHCONTRASTW), &highContrast, FALSE) == TRUE)
 		return (highContrast.dwFlags & HCF_HIGHCONTRASTON) == HCF_HIGHCONTRASTON;
 	return false;
 }
@@ -180,7 +182,7 @@ void SetTitleBarThemeColor(HWND hWnd, BOOL dark)
 {
 	if (g_buildNumber < 18362)
 		SetPropW(hWnd, L"UseImmersiveDarkModeColors", reinterpret_cast<HANDLE>(static_cast<intptr_t>(dark)));
-	else if (_SetWindowCompositionAttribute)
+	else if (_SetWindowCompositionAttribute != nullptr)
 	{
 		WINDOWCOMPOSITIONATTRIBDATA data{ WCA_USEDARKMODECOLORS, &dark, sizeof(dark) };
 		_SetWindowCompositionAttribute(hWnd, &data);
@@ -190,7 +192,7 @@ void SetTitleBarThemeColor(HWND hWnd, BOOL dark)
 void RefreshTitleBarThemeColor(HWND hWnd)
 {
 	BOOL dark = FALSE;
-	if (_IsDarkModeAllowedForWindow && _ShouldAppsUseDarkMode)
+	if (_IsDarkModeAllowedForWindow != nullptr && _ShouldAppsUseDarkMode != nullptr)
 	{
 		if (_IsDarkModeAllowedForWindow(hWnd) && _ShouldAppsUseDarkMode() && !IsHighContrast())
 		{
@@ -203,15 +205,15 @@ void RefreshTitleBarThemeColor(HWND hWnd)
 
 bool IsColorSchemeChangeMessage(LPARAM lParam)
 {
-	bool is = false;
-	if (lParam && (0 == lstrcmpi(reinterpret_cast<LPCWCH>(lParam), L"ImmersiveColorSet")) && _RefreshImmersiveColorPolicyState)
+	bool isMsg = false;
+	if ((lParam != NULL) && (0 == lstrcmpi(reinterpret_cast<LPCWCH>(lParam), L"ImmersiveColorSet")) && _RefreshImmersiveColorPolicyState != nullptr)
 	{
 		_RefreshImmersiveColorPolicyState();
-		is = true;
+		isMsg = true;
 	}
-	if (_GetIsImmersiveColorUsingHighContrast)
+	if (_GetIsImmersiveColorUsingHighContrast != nullptr)
 		_GetIsImmersiveColorUsingHighContrast(IHCM_REFRESH);
-	return is;
+	return isMsg;
 }
 
 bool IsColorSchemeChangeMessage(UINT message, LPARAM lParam)
@@ -223,15 +225,15 @@ bool IsColorSchemeChangeMessage(UINT message, LPARAM lParam)
 
 void AllowDarkModeForApp(bool allow)
 {
-	if (_AllowDarkModeForApp)
+	if (_AllowDarkModeForApp != nullptr)
 		_AllowDarkModeForApp(allow);
-	else if (_SetPreferredAppMode)
+	else if (_SetPreferredAppMode != nullptr)
 		_SetPreferredAppMode(allow ? PreferredAppMode::ForceDark : PreferredAppMode::Default);
 }
 
 static void FlushMenuThemes()
 {
-	if (_FlushMenuThemes)
+	if (_FlushMenuThemes != nullptr)
 	{
 		_FlushMenuThemes();
 	}
@@ -253,15 +255,19 @@ static bool IsWindowOrParentUsingDarkScrollBar(HWND hwnd)
 	HWND hwndRoot = GetAncestor(hwnd, GA_ROOT);
 
 	std::lock_guard<std::mutex> lock(g_darkScrollBarMutex);
-	if (g_darkScrollBarWindows.count(hwnd))
-	{
+	auto hasElement = [](const auto& container, HWND hwndToCheck) -> bool {
+#if (defined(_MSC_VER) && (_MSVC_LANG >= 202002L)) || (__cplusplus >= 202002L)
+		return container.contains(hwndToCheck);
+#else
+		return container.count(hwndToCheck) != 0;
+#endif
+		};
+
+	if (hasElement(g_darkScrollBarWindows, hwnd))
 		return true;
-	}
 
-	if (hwnd != hwndRoot && g_darkScrollBarWindows.count(hwndRoot))
-	{
+	if (hwnd != hwndRoot && hasElement(g_darkScrollBarWindows, hwndRoot))
 		return true;
-	}
 	return false;
 }
 
@@ -274,7 +280,7 @@ static void FixDarkScrollBar()
 		if (addr)
 		{
 			DWORD oldProtect = 0;
-			if (VirtualProtect(addr, sizeof(IMAGE_THUNK_DATA), PAGE_READWRITE, &oldProtect) && _OpenNcThemeData)
+			if ((VirtualProtect(addr, sizeof(IMAGE_THUNK_DATA), PAGE_READWRITE, &oldProtect) == TRUE) && (_OpenNcThemeData != nullptr))
 			{
 				auto MyOpenThemeData = [](HWND hWnd, LPCWSTR classList) WINAPI_LAMBDA_RETURN(HTHEME)
 				{
@@ -332,15 +338,11 @@ void InitDarkMode()
 		return;
 
 	fnRtlGetNtVersionNumbers RtlGetNtVersionNumbers = nullptr;
-	HMODULE hNtdllModule = GetModuleHandle(L"ntdll.dll");
-	if (hNtdllModule != nullptr)
-	{
-		ptrFn(hNtdllModule, RtlGetNtVersionNumbers, "RtlGetNtVersionNumbers");
-	}
-
-	if (RtlGetNtVersionNumbers != nullptr)
+	HMODULE hNtdll = GetModuleHandle(L"ntdll.dll");
+	if (hNtdll != nullptr && ptrFn(hNtdll, RtlGetNtVersionNumbers, "RtlGetNtVersionNumbers"))
 	{
-		DWORD major, minor;
+		DWORD major = 0;
+		DWORD minor = 0;
 		RtlGetNtVersionNumbers(&major, &minor, &g_buildNumber);
 		g_buildNumber &= ~0xF0000000;
 		if (major == 10 && minor == 0 && CheckBuildNumber(g_buildNumber))
@@ -348,38 +350,35 @@ void InitDarkMode()
 			HMODULE hUxtheme = LoadLibraryEx(L"uxtheme.dll", nullptr, LOAD_LIBRARY_SEARCH_SYSTEM32);
 			if (hUxtheme != nullptr)
 			{
-				ptrFn(hUxtheme, _OpenNcThemeData, 49);
-				ptrFn(hUxtheme, _RefreshImmersiveColorPolicyState, 104);
-				ptrFn(hUxtheme, _GetIsImmersiveColorUsingHighContrast, 106);
-				ptrFn(hUxtheme, _ShouldAppsUseDarkMode, 132);
-				ptrFn(hUxtheme, _AllowDarkModeForWindow, 133);
-
+				bool ptrFnOrd135NotNullptr = false;
 				if (g_buildNumber < 18362)
-					ptrFn(hUxtheme, _AllowDarkModeForApp, 135);
+					ptrFnOrd135NotNullptr = ptrFn(hUxtheme, _AllowDarkModeForApp, 135);
 				else
-					ptrFn(hUxtheme, _SetPreferredAppMode, 135);
-
-				ptrFn(hUxtheme, _FlushMenuThemes, 136);
-				ptrFn(hUxtheme, _IsDarkModeAllowedForWindow, 137);
-
-				HMODULE hUser32 = GetModuleHandleW(L"user32.dll");
-				if (hUser32 != nullptr)
+					ptrFnOrd135NotNullptr = ptrFn(hUxtheme, _SetPreferredAppMode, 135);
+
+				if (ptrFnOrd135NotNullptr &&
+					ptrFn(hUxtheme, _OpenNcThemeData, 49) &&
+					ptrFn(hUxtheme, _RefreshImmersiveColorPolicyState, 104) &&
+					ptrFn(hUxtheme, _ShouldAppsUseDarkMode, 132) &&
+					ptrFn(hUxtheme, _AllowDarkModeForWindow, 133) &&
+					ptrFn(hUxtheme, _FlushMenuThemes, 136) &&
+					ptrFn(hUxtheme, _IsDarkModeAllowedForWindow, 137))
 				{
-					ptrFn(hUser32, _SetWindowCompositionAttribute, "SetWindowCompositionAttribute");
+					g_darkModeSupported = true;
 				}
 
-				isInit = true;
+				ptrFn(hUxtheme, _GetIsImmersiveColorUsingHighContrast, 106);
 
-				if (_OpenNcThemeData != nullptr &&
-					_RefreshImmersiveColorPolicyState != nullptr &&
-					_ShouldAppsUseDarkMode != nullptr &&
-					_AllowDarkModeForWindow != nullptr &&
-					(_AllowDarkModeForApp != nullptr || _SetPreferredAppMode != nullptr) &&
-					_FlushMenuThemes != nullptr &&
-					_IsDarkModeAllowedForWindow != nullptr)
+				if (g_buildNumber < 19041)
 				{
-					g_darkModeSupported = true;
+					HMODULE hUser32 = GetModuleHandleW(L"user32.dll");
+					if (hUser32 != nullptr)
+					{
+						ptrFn(hUser32, _SetWindowCompositionAttribute, "SetWindowCompositionAttribute");
+					}
 				}
+
+				isInit = true;
 			}
 		}
 	}
@@ -402,16 +401,16 @@ void SetDarkMode(bool useDark, bool fixDarkScrollbar)
 
 // Hooking GetSysColor for comboboxex listbox
 
-using fnGetSysColor = DWORD (WINAPI*)(int nIndex);
+using fnGetSysColor = auto (WINAPI*)(int nIndex) -> DWORD;
 
 static fnGetSysColor _GetSysColor = nullptr;
 
-static COLORREF _clrWindow = RGB(32, 32, 32);
-static COLORREF _clrText = RGB(224, 224, 224);
-static COLORREF _clrTGridlines = RGB(100, 100, 100);
+static COLORREF g_clrWindow = RGB(32, 32, 32);
+static COLORREF g_clrText = RGB(224, 224, 224);
+static COLORREF g_clrTGridlines = RGB(100, 100, 100);
 
-static bool isGetSysColorHooked = false;
-static int hookRef = 0;
+static bool g_isGetSysColorHooked = false;
+static int g_hookRef = 0;
 
 void SetMySysColor(int nIndex, COLORREF clr)
 {
@@ -419,19 +418,19 @@ void SetMySysColor(int nIndex, COLORREF clr)
 	{
 		case COLOR_WINDOW:
 		{
-			_clrWindow = clr;
+			g_clrWindow = clr;
 			break;
 		}
 
 		case COLOR_WINDOWTEXT:
 		{
-			_clrText = clr;
+			g_clrText = clr;
 			break;
 		}
 
 		case COLOR_BTNFACE:
 		{
-			_clrTGridlines = clr;
+			g_clrTGridlines = clr;
 			break;
 		}
 
@@ -448,13 +447,13 @@ static DWORD WINAPI MyGetSysColor(int nIndex)
 	switch (nIndex)
 	{
 		case COLOR_WINDOW:
-			return _clrWindow;
+			return g_clrWindow;
 
 		case COLOR_WINDOWTEXT:
-			return _clrText;
+			return g_clrText;
 
 		case COLOR_BTNFACE:
-			return _clrTGridlines;
+			return g_clrTGridlines;
 
 		default:
 			return GetSysColor(nIndex);
@@ -465,8 +464,8 @@ template <typename P>
 static auto ReplaceFunction(IMAGE_THUNK_DATA* addr, P newFunction) -> P
 {
 	DWORD oldProtect = 0;
-	if (!VirtualProtect(addr, sizeof(IMAGE_THUNK_DATA), PAGE_READWRITE, &oldProtect))
-		return 0;
+	if (VirtualProtect(addr, sizeof(IMAGE_THUNK_DATA), PAGE_READWRITE, &oldProtect) == FALSE)
+		return nullptr;
 	uintptr_t oldFunction = addr->u1.Function;
 	addr->u1.Function = reinterpret_cast<uintptr_t>(newFunction);
 	VirtualProtect(addr, sizeof(IMAGE_THUNK_DATA), oldProtect, &oldProtect);
@@ -478,13 +477,13 @@ bool HookSysColor()
 	HMODULE hComctl = LoadLibraryEx(L"comctl32.dll", nullptr, LOAD_LIBRARY_SEARCH_SYSTEM32);
 	if (hComctl != nullptr)
 	{
-		if (_GetSysColor == nullptr || !isGetSysColorHooked)
+		if (_GetSysColor == nullptr || !g_isGetSysColorHooked)
 		{
 			auto addr = FindIatThunkInModule(hComctl, "user32.dll", "GetSysColor");
 			if (addr)
 			{
 				_GetSysColor = ReplaceFunction(addr, static_cast<fnGetSysColor>(MyGetSysColor));
-				isGetSysColorHooked = true;
+				g_isGetSysColorHooked = true;
 			}
 			else
 			{
@@ -493,9 +492,9 @@ bool HookSysColor()
 			}
 		}
 
-		if (isGetSysColorHooked)
+		if (g_isGetSysColorHooked)
 		{
-			++hookRef;
+			++g_hookRef;
 		}
 
 		FreeLibrary(hComctl);
@@ -509,20 +508,20 @@ void UnhookSysColor()
 	HMODULE hComctl = LoadLibraryEx(L"comctl32.dll", nullptr, LOAD_LIBRARY_SEARCH_SYSTEM32);
 	if (hComctl != nullptr)
 	{
-		if (isGetSysColorHooked)
+		if (g_isGetSysColorHooked)
 		{
-			if (hookRef > 0)
+			if (g_hookRef > 0)
 			{
-				--hookRef;
+				--g_hookRef;
 			}
 
-			if (hookRef == 0)
+			if (g_hookRef == 0)
 			{
-				auto addr = FindIatThunkInModule(hComctl, "user32.dll", "GetSysColor");
-				if (addr)
+				auto* addr = FindIatThunkInModule(hComctl, "user32.dll", "GetSysColor");
+				if (addr != nullptr)
 				{
 					ReplaceFunction(addr, _GetSysColor);
-					isGetSysColorHooked = false;
+					g_isGetSysColorHooked = false;
 				}
 			}
 		}
diff --git a/DarkMode/DarkModeSubclass.cpp b/DarkMode/DarkModeSubclass.cpp
index 71ef81b5c..1df657f7f 100644
--- a/DarkMode/DarkModeSubclass.cpp
+++ b/DarkMode/DarkModeSubclass.cpp
@@ -24,6 +24,9 @@
 #ifndef WIN32_LEAN_AND_MEAN
 #define WIN32_LEAN_AND_MEAN
 #endif
+#ifndef VC_EXTRALEAN
+#define VC_EXTRALEAN
+#endif
 #ifndef NOMINMAX
 #define NOMINMAX
 #endif
@@ -125,8 +128,8 @@ static std::wstring getIniPath(const std::wstring& iniFilename)
 
 static bool fileExists(const std::wstring& filePath)
 {
-	DWORD dwAttrib = ::GetFileAttributes(filePath.c_str());
-	return (dwAttrib != INVALID_FILE_ATTRIBUTES && !(dwAttrib & FILE_ATTRIBUTE_DIRECTORY));
+	const DWORD dwAttrib = ::GetFileAttributes(filePath.c_str());
+	return (dwAttrib != INVALID_FILE_ATTRIBUTES && ((dwAttrib & FILE_ATTRIBUTE_DIRECTORY) != FILE_ATTRIBUTE_DIRECTORY));
 }
 
 static bool setClrFromIni(const std::wstring& sectionName, const std::wstring& keyName, const std::wstring& iniFilePath, COLORREF* clr)
@@ -136,7 +139,7 @@ static bool setClrFromIni(const std::wstring& sectionName, const std::wstring& k
 
 	::GetPrivateProfileString(sectionName.c_str(), keyName.c_str(), L"", buffer, maxStringLength, iniFilePath.c_str());
 
-	size_t length = wcslen(buffer);
+	const size_t length = wcslen(buffer);
 	if (length != maxStringLength - 1)
 	{
 		return false;
@@ -144,7 +147,7 @@ static bool setClrFromIni(const std::wstring& sectionName, const std::wstring& k
 
 	for (size_t i = 0; i < length; ++i)
 	{
-		if (!iswxdigit(buffer[i]))
+		if (iswxdigit(buffer[i]) == 0)
 		{
 			return false;
 		}
@@ -835,7 +838,7 @@ namespace DarkMode
 	}
 
 #if !defined(_DARKMODELIB_NO_INI_CONFIG)
-	static std::wstring g_iniName = L"";
+	static std::wstring g_iniName;
 
 	static void initOptions(const std::wstring& iniName = L"")
 	{
@@ -1064,7 +1067,7 @@ namespace DarkMode
 		::EnableDarkScrollBarForWindowAndChildren(hWnd);
 	}
 
-	void paintRoundRect(HDC hdc, const RECT rect, const HPEN hpen, const HBRUSH hBrush, int width, int height)
+	void paintRoundRect(HDC hdc, const RECT& rect, HPEN hpen, HBRUSH hBrush, int width, int height)
 	{
 		auto holdBrush = ::SelectObject(hdc, hBrush);
 		auto holdPen = ::SelectObject(hdc, hpen);
@@ -1073,6 +1076,6 @@ namespace DarkMode
 		::SelectObject(hdc, holdPen);
 	}
-	void paintRoundFrameRect(HDC hdc, const RECT rect, const HPEN hpen, int width, int height)
+	void paintRoundFrameRect(HDC hdc, const RECT& rect, HPEN hpen, int width, int height)
 	{
 		DarkMode::paintRoundRect(hdc, rect, hpen, static_cast<HBRUSH>(::GetStockObject(NULL_BRUSH)), width, height);
 	}
@@ -1098,7 +1101,7 @@ namespace DarkMode
 
 		bool ensureTheme(HWND hWnd)
 		{
-			if (!_hTheme && _themeClass)
+			if (_hTheme == nullptr && _themeClass != nullptr)
 			{
 				_hTheme = ::OpenThemeData(hWnd, _themeClass);
 			}
@@ -1107,7 +1110,7 @@ namespace DarkMode
 
 		void closeTheme()
 		{
-			if (_hTheme)
+			if (_hTheme != nullptr)
 			{
 				::CloseThemeData(_hTheme);
 				_hTheme = nullptr;
@@ -1148,7 +1151,7 @@ namespace DarkMode
 
 		void releaseBuffer()
 		{
-			if (_hMemDC)
+			if (_hMemDC != nullptr)
 			{
 				::SelectObject(_hMemDC, _hOldBmp);
 				::DeleteObject(_hMemBmp);
@@ -1242,7 +1245,7 @@ namespace DarkMode
 
 	struct ButtonData
 	{
-		ThemeData _themeData{};
+		ThemeData _themeData;
 		SIZE _szBtn{};
 
 		int _iStateID = 0;
@@ -1308,17 +1311,29 @@ namespace DarkMode
 
 		hOldFont = static_cast<HFONT>(::SelectObject(hdc, hFont));
 
+		const bool isMultiline = (nStyle & BS_MULTILINE) == BS_MULTILINE;
+		const bool isTop = (nStyle & BS_TOP) == BS_TOP;
+		const bool isBottom = (nStyle & BS_BOTTOM) == BS_BOTTOM;
+		const bool isCenter = (nStyle & BS_CENTER) == BS_CENTER;
+		const bool isRight = (nStyle & BS_RIGHT) == BS_RIGHT;
+		const bool isVCenter = (nStyle & BS_VCENTER) == BS_VCENTER;
+
 		DWORD dtFlags = DT_LEFT; // DT_LEFT is 0
-		dtFlags |= (nStyle & BS_MULTILINE) ? DT_WORDBREAK : DT_SINGLELINE;
-		dtFlags |= ((nStyle & BS_CENTER) == BS_CENTER) ? DT_CENTER : (nStyle & BS_RIGHT) ? DT_RIGHT : 0;
-		dtFlags |= ((nStyle & BS_VCENTER) == BS_VCENTER) ? DT_VCENTER : (nStyle & BS_BOTTOM) ? DT_BOTTOM : 0;
-		dtFlags |= (uiState & UISF_HIDEACCEL) ? DT_HIDEPREFIX : 0;
+		dtFlags |= isMultiline ? DT_WORDBREAK : DT_SINGLELINE;
+		dtFlags |= isCenter ? DT_CENTER : (isRight ? DT_RIGHT : 0);
+		dtFlags |= isVCenter ? DT_VCENTER : (isBottom ? DT_BOTTOM : 0);
 
-		if (!(nStyle & BS_MULTILINE) && !(nStyle & BS_BOTTOM) && !(nStyle & BS_TOP))
+		if (!isMultiline && !isBottom && !isTop)
 		{
 			dtFlags |= DT_VCENTER;
 		}
 
+		const bool hidePrefix = (uiState & UISF_HIDEACCEL) == UISF_HIDEACCEL;
+		if (hidePrefix)
+		{
+			dtFlags |= DT_HIDEPREFIX;
+		}
+
 		::GetClientRect(hWnd, &rcClient);
 		::GetWindowText(hWnd, szText, _countof(szText));
 
@@ -1359,7 +1374,8 @@ namespace DarkMode
 			::DrawFocusRect(hdc, &rcFocus);
 		}
 
-		if (hCreatedFont) ::DeleteObject(hCreatedFont);
+		if (hCreatedFont != nullptr)
+			::DeleteObject(hCreatedFont);
 		::SelectObject(hdc, hOldFont);
 	}
 
@@ -1426,13 +1442,13 @@ namespace DarkMode
 		HDC hdcFrom = nullptr;
 		HDC hdcTo = nullptr;
 		HANIMATIONBUFFER hbpAnimation = ::BeginBufferedAnimation(hWnd, hdc, &rcClient, BPBF_COMPATIBLEBITMAP, nullptr, &animParams, &hdcFrom, &hdcTo);
-		if (hbpAnimation)
+		if (hbpAnimation != nullptr)
 		{
-			if (hdcFrom)
+			if (hdcFrom != nullptr)
 			{
 				DarkMode::renderButton(hWnd, hdcFrom, hTheme, iPartID, buttonData._iStateID);
 			}
-			if (hdcTo)
+			if (hdcTo != nullptr)
 			{
 				DarkMode::renderButton(hWnd, hdcTo, hTheme, iPartID, iStateID);
 			}
@@ -1488,14 +1504,14 @@ namespace DarkMode
 				{
 					PAINTSTRUCT ps{};
 					HDC hdc = reinterpret_cast<HDC>(wParam);
-					if (!hdc)
+					if (hdc == nullptr)
 					{
 						hdc = ::BeginPaint(hWnd, &ps);
 					}
 
 					DarkMode::paintButton(hWnd, hdc, *pButtonData);
 
-					if (ps.hdc)
+					if (ps.hdc != nullptr)
 					{
 						::EndPaint(hWnd, &ps);
 					}
@@ -1529,9 +1545,9 @@ namespace DarkMode
 				if (DarkMode::isEnabled())
 				{
 					// skip the button's normal wndproc so it won't redraw out of wm_paint
-					LRESULT lr = ::DefWindowProc(hWnd, uMsg, wParam, lParam);
+					LRESULT retVal = ::DefWindowProc(hWnd, uMsg, wParam, lParam);
 					::InvalidateRect(hWnd, nullptr, FALSE);
-					return lr;
+					return retVal;
 				}
 				break;
 			}
@@ -1563,8 +1579,8 @@ namespace DarkMode
 		const auto& hTheme = buttonData._themeData._hTheme;
 
 		const bool isDisabled = ::IsWindowEnabled(hWnd) == FALSE;
-		int iPartID = BP_GROUPBOX;
-		int iStateID = isDisabled ? GBS_DISABLED : GBS_NORMAL;
+		const int iPartID = BP_GROUPBOX;
+		const int iStateID = isDisabled ? GBS_DISABLED : GBS_NORMAL;
 
 		RECT rcClient{};
 		::GetClientRect(hWnd, &rcClient);
@@ -1584,7 +1600,7 @@ namespace DarkMode
 			hFont = hCreatedFont;
 		}
 
-		if (!hFont)
+		if (hFont == nullptr)
 		{
 			hFont = reinterpret_cast<HFONT>(::SendMessage(hWnd, WM_GETFONT, 0, 0));
 		}
@@ -1602,7 +1618,7 @@ namespace DarkMode
 			SIZE textSize{};
 			::GetTextExtentPoint32(hdc, szText, static_cast<int>(wcslen(szText)), &textSize);
 
-			int centerPosX = isCenter ? ((rcClient.right - rcClient.left - textSize.cx) / 2) : 7;
+			const int centerPosX = isCenter ? ((rcClient.right - rcClient.left - textSize.cx) / 2) : 7;
 
 			rcBackground.top += textSize.cy / 2;
 			rcText.left += centerPosX;
@@ -1648,7 +1664,7 @@ namespace DarkMode
 			::DrawThemeTextEx(hTheme, hdc, BP_GROUPBOX, iStateID, szText, -1, dtFlags | DT_SINGLELINE, &rcText, &dtto);
 		}
 
-		if (hCreatedFont)
+		if (hCreatedFont != nullptr)
 			::DeleteObject(hCreatedFont);
 		::SelectObject(hdc, hOldFont);
 	}
@@ -1692,14 +1708,14 @@ namespace DarkMode
 				{
 					PAINTSTRUCT ps{};
 					HDC hdc = reinterpret_cast<HDC>(wParam);
-					if (!hdc)
+					if (hdc == nullptr)
 					{
 						hdc = ::BeginPaint(hWnd, &ps);
 					}
 
 					DarkMode::paintGroupbox(hWnd, hdc, *pButtonData);
 
-					if (ps.hdc)
+					if (ps.hdc != nullptr)
 					{
 						::EndPaint(hWnd, &ps);
 					}
@@ -1803,8 +1819,8 @@ namespace DarkMode
 
 	struct UpDownData
 	{
-		ThemeData _themeData{};
-		BufferData _bufferData{};
+		ThemeData _themeData;
+		BufferData _bufferData;
 
 		RECT _rcClient{};
 		RECT _rcPrev{};
@@ -1846,7 +1862,7 @@ namespace DarkMode
 			}
 			else
 			{
-				const LONG offset = 2;
+				constexpr LONG offset = 2;
 
 				RECT rcArrowTop{
 					_rcClient.left + offset, _rcClient.top,
@@ -1896,14 +1912,14 @@ namespace DarkMode
 		::GetCursorPos(&ptCursor);
 		::ScreenToClient(hWnd, &ptCursor);
 
-		const bool isHotPrev = ::PtInRect(&upDownData._rcPrev, ptCursor);
-		const bool isHotNext = ::PtInRect(&upDownData._rcNext, ptCursor);
+		const bool isHotPrev = ::PtInRect(&upDownData._rcPrev, ptCursor) == TRUE;
+		const bool isHotNext = ::PtInRect(&upDownData._rcNext, ptCursor) == TRUE;
 
 		upDownData._wasHotNext = isHotNext;
 
 		if (hasTheme)
 		{
-			auto stateID = isDisabled ? PBS_DISABLED : PBS_NORMAL;
+			const auto stateID = isDisabled ? PBS_DISABLED : PBS_NORMAL;
 			::DrawThemeBackground(hTheme, hdc, BP_PUSHBUTTON, isHotPrev ? PBS_HOT : stateID, &upDownData._rcPrev, nullptr);
 			::DrawThemeBackground(hTheme, hdc, BP_PUSHBUTTON, isHotNext ? PBS_HOT : stateID, &upDownData._rcNext, nullptr);
 		}
@@ -1914,14 +1930,14 @@ namespace DarkMode
 			::FillRect(hdc, &upDownData._rcNext, isHotNext ? DarkMode::getHotBackgroundBrush() : hBrush);
 		}
 
-		constexpr auto arrowTextFlags = DT_NOPREFIX | DT_CENTER | DT_VCENTER | DT_SINGLELINE | DT_NOCLIP;
-		COLORREF clrText = isDisabled ? DarkMode::getDisabledTextColor() : DarkMode::getDarkerTextColor();
+		constexpr UINT dtFlags = DT_NOPREFIX | DT_CENTER | DT_VCENTER | DT_SINGLELINE | DT_NOCLIP;
+		const COLORREF clrText = isDisabled ? DarkMode::getDisabledTextColor() : DarkMode::getDarkerTextColor();
 
 		::SetTextColor(hdc, isHotPrev ? DarkMode::getTextColor() : clrText);
-		::DrawText(hdc, upDownData._isHorizontal ? L"<" : L"˄", -1, &upDownData._rcPrev, arrowTextFlags);
+		::DrawText(hdc, upDownData._isHorizontal ? L"<" : L"˄", -1, &upDownData._rcPrev, dtFlags);
 
 		::SetTextColor(hdc, isHotNext ? DarkMode::getTextColor() : clrText);
-		::DrawText(hdc, upDownData._isHorizontal ? L">" : L"˅", -1, &upDownData._rcNext, arrowTextFlags);
+		::DrawText(hdc, upDownData._isHorizontal ? L">" : L"˅", -1, &upDownData._rcNext, dtFlags);
 
 		if (!hasTheme)
 		{
@@ -2050,7 +2066,7 @@ namespace DarkMode
 				::GetCursorPos(&ptCursor);
 				::ScreenToClient(hWnd, &ptCursor);
 
-				const bool isHotPrev = ::PtInRect(&pUpDownData->_rcPrev, ptCursor);
+				const bool isHotPrev = ::PtInRect(&pUpDownData->_rcPrev, ptCursor) == TRUE;
 
 				if ((isHotPrev && pUpDownData->_wasHotNext))
 				{
@@ -2100,9 +2116,9 @@ namespace DarkMode
 		}
 	}
 
-	static void paintTab(HWND hWnd, HDC hdc, RECT& rc)
+	static void paintTab(HWND hWnd, HDC hdc, const RECT& rect)
 	{
-		::FillRect(hdc, &rc, DarkMode::getDlgBackgroundBrush());
+		::FillRect(hdc, &rect, DarkMode::getDlgBackgroundBrush());
 
 		auto holdPen = static_cast<HPEN>(::SelectObject(hdc, DarkMode::getEdgePen()));
 
@@ -2120,9 +2136,9 @@ namespace DarkMode
 		::GetCursorPos(&ptCursor);
 		::ScreenToClient(hWnd, &ptCursor);
 
-		int nTabs = TabCtrl_GetItemCount(hWnd);
+		const int nTabs = TabCtrl_GetItemCount(hWnd);
 
-		int nSelTab = TabCtrl_GetCurSel(hWnd);
+		const int iSelTab = TabCtrl_GetCurSel(hWnd);
 		for (int i = 0; i < nTabs; ++i)
 		{
 			RECT rcItem{};
@@ -2130,10 +2146,10 @@ namespace DarkMode
 			RECT rcFrame{ rcItem };
 
 			RECT rcIntersect{};
-			if (::IntersectRect(&rcIntersect, &rc, &rcItem))
+			if (::IntersectRect(&rcIntersect, &rect, &rcItem))
 			{
-				const bool bHot = ::PtInRect(&rcItem, ptCursor);
-				const bool isSelectedTab = (i == nSelTab);
+				const bool bHot = ::PtInRect(&rcItem, ptCursor) == TRUE;
+				const bool isSelectedTab = (i == iSelTab);
 
 				::SetBkMode(hdc, TRANSPARENT);
 
@@ -2166,7 +2182,8 @@ namespace DarkMode
 					// would be better, than getCtrlBackgroundBrush(),
 					// however default getBackgroundBrush() has same color
 					// as getDlgBackgroundBrush()
-					::FillRect(hdc, &rcItem, isSelectedTab ? DarkMode::getDlgBackgroundBrush() : bHot ? DarkMode::getHotBackgroundBrush() : DarkMode::getCtrlBackgroundBrush());
+					HBRUSH hBrush = isSelectedTab ? DarkMode::getDlgBackgroundBrush() : (bHot ? DarkMode::getHotBackgroundBrush() : DarkMode::getCtrlBackgroundBrush());
+					::FillRect(hdc, &rcItem, hBrush);
 					::SetTextColor(hdc, (bHot || isSelectedTab) ? DarkMode::getTextColor() : DarkMode::getDarkerTextColor());
 				}
 
@@ -2190,9 +2207,9 @@ namespace DarkMode
 					int cx = 0;
 					int cy = 0;
 					auto hImagelist = TabCtrl_GetImageList(hWnd);
-					int offset = 2;
+					constexpr int offset = 2;
 					::ImageList_GetIconSize(hImagelist, &cx, &cy);
-					::ImageList_Draw(hImagelist, tci.iImage, hdc, rcText.left + offset, rcText.top + ((rcText.bottom - rcText.top) - cy) / 2, ILD_NORMAL);
+					::ImageList_Draw(hImagelist, tci.iImage, hdc, rcText.left + offset, rcText.top + (((rcText.bottom - rcText.top) - cy) / 2), ILD_NORMAL);
 					rcText.left += cx;
 				}
 
@@ -2206,7 +2223,7 @@ namespace DarkMode
 
 		::SelectObject(hdc, hOldFont);
 		::SelectClipRgn(hdc, holdClip);
-		if (holdClip)
+		if (holdClip != nullptr)
 		{
 			::DeleteObject(holdClip);
 			holdClip = nullptr;
@@ -2462,7 +2479,7 @@ namespace DarkMode
 				::GetCursorPos(&ptCursor);
 				::ScreenToClient(hWnd, &ptCursor);
 
-				const bool isHot = ::PtInRect(&rcClient, ptCursor);
+				const bool isHot = ::PtInRect(&rcClient, ptCursor) == TRUE;
 				const bool hasFocus = ::GetFocus() == hWnd;
 
 				HPEN hEnabledPen = ((pBorderMetricsData->_isHot && isHot) || hasFocus ? DarkMode::getHotEdgePen() : DarkMode::getEdgePen());
@@ -2598,8 +2615,8 @@ namespace DarkMode
 
 	struct ComboboxData
 	{
-		ThemeData _themeData{};
-		BufferData _bufferData{};
+		ThemeData _themeData;
+		BufferData _bufferData;
 
 		LONG_PTR _cbStyle = CBS_SIMPLE;
 
@@ -2655,8 +2672,8 @@ namespace DarkMode
 			auto index = static_cast<int>(::SendMessage(hWnd, CB_GETCURSEL, 0, 0));
 			if (index != CB_ERR)
 			{
-				auto bufferLen = static_cast<size_t>(::SendMessage(hWnd, CB_GETLBTEXTLEN, static_cast<WPARAM>(index), 0));
-				wchar_t* buffer = new wchar_t[(bufferLen + 1)];
+				const auto bufferLen = static_cast<size_t>(::SendMessage(hWnd, CB_GETLBTEXTLEN, static_cast<WPARAM>(index), 0));
+				auto buffer = new wchar_t[(bufferLen + 1)];
 				::SendMessage(hWnd, CB_GETLBTEXT, static_cast<WPARAM>(index), reinterpret_cast<LPARAM>(buffer));
 
 				RECT rcText{ cbi.rcItem };
@@ -2707,7 +2724,7 @@ namespace DarkMode
 			{
 				const auto clrText = isDisabled ? DarkMode::getDisabledTextColor() : (isHot ? DarkMode::getTextColor() : DarkMode::getDarkerTextColor());
 				::SetTextColor(hdc, clrText);
-				wchar_t arrow[] = L"˅";
+				const wchar_t arrow[] = L"˅";
 				::DrawText(hdc, arrow, -1, &rcArrow, DT_NOPREFIX | DT_CENTER | DT_VCENTER | DT_SINGLELINE | DT_NOCLIP);
 			}
 		}
@@ -2844,9 +2861,9 @@ namespace DarkMode
 					break;
 				}
 
-				LRESULT lr = ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
+				LRESULT retVal = ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
 				::RedrawWindow(hWnd, nullptr, nullptr, RDW_INVALIDATE);
-				return lr;
+				return retVal;
 			}
 
 			case WM_DPICHANGED:
@@ -3039,9 +3056,9 @@ namespace DarkMode
 				if (hasGridlines)
 				{
 					DarkMode::hookSysColor();
-					LRESULT lr = ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
+					LRESULT retVal = ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
 					DarkMode::unhookSysColor();
-					return lr;
+					return retVal;
 				}
 				break;
 			}
@@ -3125,9 +3142,9 @@ namespace DarkMode
 
 	struct HeaderData
 	{
-		ThemeData _themeData{};
-		BufferData _bufferData{};
-		FontData _fontData{};
+		ThemeData _themeData;
+		BufferData _bufferData;
+		FontData _fontData;
 
 		POINT _pt{ LONG_MIN, LONG_MIN };
 		bool _isHot = false;
@@ -3135,8 +3152,7 @@ namespace DarkMode
 		bool _isPressed = false;
 
 		HeaderData()
-			: _themeData(VSCLASS_HEADER),
-			_hasBtnStyle(true)
+			: _themeData(VSCLASS_HEADER)
 		{}
 
 		explicit HeaderData(bool hasBtnStyle)
@@ -3196,7 +3212,7 @@ namespace DarkMode
 		for (int i = 0; i < count; i++)
 		{
 			Header_GetItemRect(hWnd, i, &rcItem);
-			const bool isOnItem = ::PtInRect(&rcItem, headerData._pt);
+			const bool isOnItem = ::PtInRect(&rcItem, headerData._pt) == TRUE;
 
 			if (headerData._hasBtnStyle && isOnItem)
 			{
@@ -3224,7 +3240,7 @@ namespace DarkMode
 				&& ((hdi.fmt & HDF_SORTUP) == HDF_SORTUP
 					|| (hdi.fmt & HDF_SORTDOWN) == HDF_SORTDOWN))
 			{
-				int iStateID = ((hdi.fmt & HDF_SORTUP) == HDF_SORTUP) ? HSAS_SORTEDUP : HSAS_SORTEDDOWN;
+				const int iStateID = ((hdi.fmt & HDF_SORTUP) == HDF_SORTUP) ? HSAS_SORTEDUP : HSAS_SORTEDDOWN;
 				RECT rcArrow{ rcItem };
 				SIZE szArrow{};
 				if (SUCCEEDED(::GetThemePartSize(hTheme, hdc, HP_HEADERSORTARROW, iStateID, nullptr, TS_DRAW, &szArrow)))
@@ -3415,7 +3431,7 @@ namespace DarkMode
 				if (!pHeaderData->_hasBtnStyle)
 					break;
 
-				LRESULT result = ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
+				LRESULT retVal = ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
 
 				pHeaderData->_isHot = false;
 				pHeaderData->_pt.x = LONG_MIN;
@@ -3423,7 +3439,7 @@ namespace DarkMode
 
 				::InvalidateRect(hWnd, nullptr, TRUE);
 
-				return result;
+				return retVal;
 			}
 		}
 		return ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
@@ -3442,9 +3458,9 @@ namespace DarkMode
 
 	struct StatusBarData
 	{
-		ThemeData _themeData{};
-		BufferData _bufferData{};
-		FontData _fontData{};
+		ThemeData _themeData;
+		BufferData _bufferData;
+		FontData _fontData;
 
 		StatusBarData()
 			: _themeData(VSCLASS_STATUS)
@@ -3495,7 +3511,7 @@ namespace DarkMode
 			}
 
 			const int lastDiv = hasSizeGrip ? 1 : 0;
-			if (i < nParts - lastDiv && !(nParts < 2 && hasSizeGrip))
+			if ((i < nParts - lastDiv) && (nParts >= 2 || !hasSizeGrip))
 			{
 				POINT edges[]{
 					{rcPart.right - borders.between, rcPart.top + 1},
@@ -3703,8 +3719,8 @@ namespace DarkMode
 
 	struct ProgressBarData
 	{
-		BufferData _bufferData{};
-		ThemeData _themeData{};
+		BufferData _bufferData;
+		ThemeData _themeData;
 
 		int _iStateID = PBFS_PARTIAL; // PBFS_PARTIAL for cyan color
 
@@ -3724,7 +3740,7 @@ namespace DarkMode
 		const int currPos = pos - iMin;
 		if (currPos != 0)
 		{
-			int totalWidth = rcEmpty->right - rcEmpty->left;
+			const int totalWidth = rcEmpty->right - rcEmpty->left;
 			rcFilled->left = rcEmpty->left;
 			rcFilled->top = rcEmpty->top;
 			rcFilled->bottom = rcEmpty->bottom;
@@ -3752,7 +3768,7 @@ namespace DarkMode
 		::FillRect(hdc, &rcClient, DarkMode::getCtrlBackgroundBrush());
 	}
 
-	const UINT_PTR g_progressBarSubclassID = static_cast<UINT_PTR>(DarkMode::SubclassID::progress);
+	constexpr UINT_PTR g_progressBarSubclassID = static_cast<UINT_PTR>(DarkMode::SubclassID::progress);
 
 	static LRESULT CALLBACK ProgressBarSubclass(
 		HWND hWnd,
@@ -4286,7 +4302,7 @@ namespace DarkMode
 		{
 			case CDDS_PREPAINT:
 			{
-				LRESULT lr = CDRF_DODEFAULT;
+				LRESULT retVal = CDRF_DODEFAULT;
 				if (DarkMode::isEnabled())
 				{
 					if (DarkMode::isWindows11())
@@ -4295,10 +4311,10 @@ namespace DarkMode
 					}
 
 					::FillRect(lptbcd->nmcd.hdc, &lptbcd->nmcd.rc, DarkMode::getDlgBackgroundBrush());
-					lr |= CDRF_NOTIFYITEMDRAW | CDRF_NOTIFYPOSTPAINT;
+					retVal |= CDRF_NOTIFYITEMDRAW | CDRF_NOTIFYPOSTPAINT;
 				}
 
-				return lr;
+				return retVal;
 			}
 
 			case CDDS_ITEMPREPAINT:
@@ -4369,18 +4385,18 @@ namespace DarkMode
 					lptbcd->nmcd.uItemState &= ~CDIS_CHECKED;
 				}
 
-				LRESULT lr = TBCDRF_USECDCOLORS;
+				LRESULT retVal = TBCDRF_USECDCOLORS;
 				if ((lptbcd->nmcd.uItemState & CDIS_SELECTED) == CDIS_SELECTED)
 				{
-					lr |= TBCDRF_NOBACKGROUND;
+					retVal |= TBCDRF_NOBACKGROUND;
 				}
 
 				if (isDropDown)
 				{
-					lr |= CDRF_NOTIFYPOSTPAINT;
+					retVal |= CDRF_NOTIFYPOSTPAINT;
 				}
 
-				return lr;
+				return retVal;
 			}
 
 			case CDDS_ITEMPOSTPAINT:
@@ -4402,10 +4418,8 @@ namespace DarkMode
 				rcArrow.left += 1;
 				rcArrow.bottom -= 3;
 
-				COLORREF clrArrow = DarkMode::getTextColor();
-
 				::SetBkMode(lptbcd->nmcd.hdc, TRANSPARENT);
-				::SetTextColor(lptbcd->nmcd.hdc, clrArrow);
+				::SetTextColor(lptbcd->nmcd.hdc, DarkMode::getTextColor());
 				::DrawText(lptbcd->nmcd.hdc, L"⏷", -1, &rcArrow, DT_NOPREFIX | DT_CENTER | DT_VCENTER | DT_SINGLELINE | DT_NOCLIP);
 				::SelectObject(lptbcd->nmcd.hdc, holdFont);
 
@@ -4538,7 +4552,7 @@ namespace DarkMode
 
 			case CDDS_ITEMPREPAINT:
 			{
-				LRESULT lr = CDRF_DODEFAULT;
+				LRESULT retVal = CDRF_DODEFAULT;
 
 				if (DarkMode::isEnabled())
 				{
@@ -4548,7 +4562,7 @@ namespace DarkMode
 						lptvcd->clrTextBk = DarkMode::getCtrlBackgroundColor();
 						::FillRect(lptvcd->nmcd.hdc, &lptvcd->nmcd.rc, DarkMode::getCtrlBackgroundBrush());
 
-						lr |= CDRF_NEWFONT | CDRF_NOTIFYPOSTPAINT;
+						retVal |= CDRF_NEWFONT | CDRF_NOTIFYPOSTPAINT;
 					}
 					else if ((lptvcd->nmcd.uItemState & CDIS_HOT) == CDIS_HOT)
 					{
@@ -4558,13 +4572,13 @@ namespace DarkMode
 						if (DarkMode::isWindows10() || g_treeViewStyle == TreeViewStyle::light)
 						{
 							::FillRect(lptvcd->nmcd.hdc, &lptvcd->nmcd.rc, DarkMode::getHotBackgroundBrush());
-							lr |= CDRF_NOTIFYPOSTPAINT;
+							retVal |= CDRF_NOTIFYPOSTPAINT;
 						}
-						lr |= CDRF_NEWFONT;
+						retVal |= CDRF_NEWFONT;
 					}
 				}
 
-				return lr;
+				return retVal;
 			}
 
 			case CDDS_ITEMPOSTPAINT:
@@ -4596,7 +4610,7 @@ namespace DarkMode
 
 	static LRESULT darkTrackBarNotifyCustomDraw(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
 	{
-		LPNMCUSTOMDRAW lpnmcd = reinterpret_cast<LPNMCUSTOMDRAW>(lParam);
+		auto lpnmcd = reinterpret_cast<LPNMCUSTOMDRAW>(lParam);
 
 		switch (lpnmcd->dwDrawStage)
 		{
@@ -4665,7 +4679,7 @@ namespace DarkMode
 				rbBand.fMask = RBBIM_STYLE | RBBIM_CHEVRONLOCATION | RBBIM_CHEVRONSTATE;
 				::SendMessage(lpnmcd->hdr.hwndFrom, RB_GETBANDINFO, 0, reinterpret_cast<LPARAM>(&rbBand));
 
-				LRESULT lr = CDRF_DODEFAULT;
+				LRESULT retVal = CDRF_DODEFAULT;
 
 				if ((rbBand.fStyle & RBBS_USECHEVRON) == RBBS_USECHEVRON
 					&& (rbBand.rcChevronLocation.right - rbBand.rcChevronLocation.left) > 0)
@@ -4694,9 +4708,9 @@ namespace DarkMode
 					constexpr auto dtFlags = DT_NOPREFIX | DT_CENTER | DT_TOP | DT_SINGLELINE | DT_NOCLIP;
 					::DrawText(lpnmcd->hdc, L"»", -1, &rbBand.rcChevronLocation, dtFlags);
 
-					lr = CDRF_SKIPDEFAULT;
+					retVal = CDRF_SKIPDEFAULT;
 				}
-				return lr;
+				return retVal;
 			}
 
 			default:
@@ -4791,7 +4805,7 @@ namespace DarkMode
 	{
 		MENUBARINFO mbi{};
 		mbi.cbSize = sizeof(MENUBARINFO);
-		if (!::GetMenuBarInfo(hWnd, OBJID_MENU, 0, &mbi))
+		if (::GetMenuBarInfo(hWnd, OBJID_MENU, 0, &mbi) == FALSE)
 		{
 			return;
 		}
@@ -4846,25 +4860,22 @@ namespace DarkMode
 			case WM_UAHDRAWMENU:
 			{
 				auto pUDM = reinterpret_cast<UAHMENU*>(lParam);
-				RECT rc{};
 
 				// get the menubar rect
-				{
-					MENUBARINFO mbi{};
-					mbi.cbSize = sizeof(MENUBARINFO);
-					::GetMenuBarInfo(hWnd, OBJID_MENU, 0, &mbi);
+				MENUBARINFO mbi{};
+				mbi.cbSize = sizeof(MENUBARINFO);
+				::GetMenuBarInfo(hWnd, OBJID_MENU, 0, &mbi);
 
-					RECT rcWindow{};
-					::GetWindowRect(hWnd, &rcWindow);
+				RECT rcWindow{};
+				::GetWindowRect(hWnd, &rcWindow);
 
-					// the rcBar is offset by the window rect
-					rc = mbi.rcBar;
-					::OffsetRect(&rc, -rcWindow.left, -rcWindow.top);
+				// the rcBar is offset by the window rect
+				RECT rcBar{ mbi.rcBar };
+				::OffsetRect(&rcBar, -rcWindow.left, -rcWindow.top);
 
-					rc.top -= 1;
-				}
+				rcBar.top -= 1;
 
-				::FillRect(pUDM->hdc, &rc, DarkMode::getDlgBackgroundBrush());
+				::FillRect(pUDM->hdc, &rcBar, DarkMode::getDlgBackgroundBrush());
 
 				return 0;
 			}
@@ -4979,7 +4990,7 @@ namespace DarkMode
 					}
 				}
 
-				::DrawThemeTextEx(hTheme, pUDMI->um.hdc, MENU_BARITEM, iTextStateID, menuString, mii.cch, dwFlags, &pUDMI->dis.rcItem, &dttopts);
+				::DrawThemeTextEx(hTheme, pUDMI->um.hdc, MENU_BARITEM, iTextStateID, menuString, static_cast<int>(mii.cch), dwFlags, &pUDMI->dis.rcItem, &dttopts);
 
 				return 0;
 			}
@@ -5000,9 +5011,9 @@ namespace DarkMode
 			case WM_NCACTIVATE:
 			case WM_NCPAINT:
 			{
-				LRESULT result = ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
+				LRESULT retVal = ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
 				DarkMode::drawUAHMenuNCBottomLine(hWnd);
-				return result;
+				return retVal;
 			}
 		}
 		return ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
@@ -5244,31 +5255,32 @@ namespace DarkMode
 			return std::pow(((colorChannel + 0.055) / 1.055), 2.4);
 			};
 
-		double r = linearValue(static_cast<double>(GetRValue(clr)));
-		double g = linearValue(static_cast<double>(GetGValue(clr)));
-		double b = linearValue(static_cast<double>(GetBValue(clr)));
+		const double r = linearValue(static_cast<double>(GetRValue(clr)));
+		const double g = linearValue(static_cast<double>(GetGValue(clr)));
+		const double b = linearValue(static_cast<double>(GetBValue(clr)));
 
-		double luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b;
+		const double luminance = (0.2126 * r) + (0.7152 * g) + (0.0722 * b);
 
-		double lightness = (luminance <= 216.0 / 24389.0) ? (luminance * 24389.0 / 27.0) : (std::pow(luminance, (1.0 / 3.0)) * 116.0 - 16.0);
+		const double lightness = (luminance <= 216.0 / 24389.0) ? (luminance * 24389.0 / 27.0) : ((std::pow(luminance, (1.0 / 3.0)) * 116.0) - 16.0);
 		return lightness;
 	}
 
 	void calculateTreeViewStyle()
 	{
-		COLORREF bgColor = DarkMode::getViewBackgroundColor();
+		constexpr double middle = 50.0;
+		const COLORREF bgColor = DarkMode::getViewBackgroundColor();
 
-		if (g_treeViewBg != bgColor || g_lightnessTreeView == 50.0)
+		if (g_treeViewBg != bgColor || g_lightnessTreeView == middle)
 		{
 			g_lightnessTreeView = calculatePerceivedLightness(bgColor);
 			g_treeViewBg = bgColor;
 		}
 
-		if (g_lightnessTreeView < (50.0 - g_middleGrayRange))
+		if (g_lightnessTreeView < (middle - g_middleGrayRange))
 		{
 			g_treeViewStyle = TreeViewStyle::dark;
 		}
-		else if (g_lightnessTreeView > (50.0 + g_middleGrayRange))
+		else if (g_lightnessTreeView > (middle + g_middleGrayRange))
 		{
 			g_treeViewStyle = TreeViewStyle::light;
 		}
diff --git a/DarkMode/DarkModeSubclass.h b/DarkMode/DarkModeSubclass.h
index 714ab6c5a..eaaf209f6 100644
--- a/DarkMode/DarkModeSubclass.h
+++ b/DarkMode/DarkModeSubclass.h
@@ -216,8 +216,8 @@ namespace DarkMode
 
 	// paint helper
 
-	void paintRoundRect(HDC hdc, const RECT rect, const HPEN hpen, const HBRUSH hBrush, int width = 0, int height = 0);
-	inline void paintRoundFrameRect(HDC hdc, const RECT rect, const HPEN hpen, int width = 0, int height = 0);
+	void paintRoundRect(HDC hdc, const RECT& rect, HPEN hpen, HBRUSH hBrush, int width = 0, int height = 0);
+	inline void paintRoundFrameRect(HDC hdc, const RECT& rect, HPEN hpen, int width = 0, int height = 0);
 
 	// control subclassing
 
