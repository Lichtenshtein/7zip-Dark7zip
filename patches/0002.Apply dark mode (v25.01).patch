From 01a2d72546a62c37de1f7b109e9be2ca701dad76 Mon Sep 17 00:00:00 2001
From: ozone10 <positronix10@gmail.com>
Date: Sat, 1 Feb 2025 09:10:14 +0100
Subject: [PATCH] Apply dark mode (25.01)

---
 .github/FUNDING.yml                     |    1 -
 .github/workflows/build_win.yml      |   37 +
 .gitignore                              |    6 +
 C/Precomp.h                             |    2 +
 CPP/7zip/7zip.mak                       |    4 +
 CPP/7zip/UI/FileManager/AboutDialog.rc  |    3 +
 CPP/7zip/UI/FileManager/App.cpp         |   19 +-
 CPP/7zip/UI/FileManager/MenuPage.cpp    |    4 +
 CPP/Build.mak                           |    6 +-
 CPP/Windows/Control/Dialog.cpp          |    8 +-
 CPP/Windows/Control/PropertyPage.cpp    |   10 +-
 CPP/Windows/Shell.cpp                   |    3 +
 DarkMode/7zRes/7zDark.ini               |   57 +
 DarkMode/7zRes/7zDark.mak               |   13 +
 DarkMode/7zRes/7zDarkObj.mak            |    9 +
 DarkMode/LICENSE-MIT.md                 |   21 +
 DarkMode/LICENSE.md                     |  357 +
 DarkMode/docs/Dark.ini                  |  166 +
 DarkMode/docs/LICENSE-PolyHook_2_0.md   |   21 +
 DarkMode/docs/LICENSE-UAHMenuBar.md     |   21 +
 DarkMode/docs/LICENSE-win32-darkmode.md |   21 +
 DarkMode/src/DarkMode.cpp               |  640 ++
 DarkMode/src/DarkMode.h                 |   45 +
 DarkMode/src/DarkModeSubclass.cpp       | 8288 +++++++++++++++++++++++
 DarkMode/src/DarkModeSubclass.h         |  656 ++
 DarkMode/src/IatHook.h                  |  112 +
 DarkMode/src/StdAfx.h                   |    1 +
 DarkMode/src/UAHMenuBar.h               |   78 +
 DarkMode/src/Version.h                  |   16 +
 LICENSE.md                              |   39 +
 README.md                               |  231 +
 build.cmd                               |   45 +
 32 files changed, 10933 insertions(+), 7 deletions(-)
 delete mode 100644 .github/FUNDING.yml
 create mode 100644 .github/workflows/build_win.yml
 create mode 100644 DarkMode/7zRes/7zDark.ini
 create mode 100644 DarkMode/7zRes/7zDark.mak
 create mode 100644 DarkMode/7zRes/7zDarkObj.mak
 create mode 100644 DarkMode/LICENSE-MIT.md
 create mode 100644 DarkMode/LICENSE.md
 create mode 100644 DarkMode/docs/Dark.ini
 create mode 100644 DarkMode/docs/LICENSE-PolyHook_2_0.md
 create mode 100644 DarkMode/docs/LICENSE-UAHMenuBar.md
 create mode 100644 DarkMode/docs/LICENSE-win32-darkmode.md
 create mode 100644 DarkMode/src/DarkMode.cpp
 create mode 100644 DarkMode/src/DarkMode.h
 create mode 100644 DarkMode/src/DarkModeSubclass.cpp
 create mode 100644 DarkMode/src/DarkModeSubclass.h
 create mode 100644 DarkMode/src/IatHook.h
 create mode 100644 DarkMode/src/StdAfx.h
 create mode 100644 DarkMode/src/UAHMenuBar.h
 create mode 100644 DarkMode/src/Version.h
 create mode 100644 LICENSE.md
 create mode 100644 build.cmd

diff --git a/.github/FUNDING.yml b/.github/FUNDING.yml
deleted file mode 100644
index 9ab249a21..000000000
--- a/.github/FUNDING.yml
+++ /dev/null
@@ -1 +0,0 @@
-custom: ['https://www.paypal.me/TinoReichardt']
diff --git a/.github/workflows/build_win.yml b/.github/workflows/build_win.yml
new file mode 100644
index 0000000..568ce52
--- /dev/null
+++ b/.github/workflows/build_win.yml
@@ -0,0 +1,105 @@
+name: Build Windows binaries
+on:
+#  pull_request:
+#    branches:
+#      - main
+#      - Dark7z-zstd
+#  push:
+#    branches:
+#      - main
+#      - Dark7z-zstd
+  workflow_dispatch:
+
+jobs:
+  build:
+    runs-on: windows-latest
+
+    strategy:
+      matrix:
+        arch: [ amd64 ]
+# arch: [ amd64, amd64_x86, amd64_arm64 ]
+        include:
+#          - arch: amd64_x86
+#            subsys: "5.01"
+#            platform: "x86"
+          - arch: amd64
+            subsys: "5.02"
+            platform: "x64"
+#          - arch: amd64_arm64
+#            subsys: "6.02"
+#            platform: "arm64"
+    steps:
+      - uses: actions/checkout@v3
+
+      - name: Add msbuild to PATH
+        uses: microsoft/setup-msbuild@v2
+
+      - name: Enable Developer Command Prompt
+        uses: ilammy/msvc-dev-cmd@v1.13.0
+        with:
+          arch: ${{ matrix.arch }}
+
+      - name: Compiling ${{ matrix.arch }}
+        shell: cmd
+        run: |
+          set WDIR=%cd%
+          set PLATFORM=${{matrix.platform}}
+          set SUBSYS=${{matrix.subsys}}
+          set ROOT=%cd%\CPP\7zip
+          set OUTDIR=%WDIR%\build\bin-%PLATFORM%
+          set LFLAGS=/SUBSYSTEM:WINDOWS,%SUBSYS%
+          set ERRFILE=
+          set STOP_ON_ERROR=1
+
+          echo "********"
+          echo "Working Dir: %WDIR%"
+          echo "Platform:    %PLATFORM%"
+          echo "SUBSYS:      %SUBSYS%"
+
+          @echo off
+
+          call CPP\build-it.cmd -no-init
+          IF %errorlevel% NEQ 0 EXIT 1
+
+          REM Will be by the do-release action
+          copy %WDIR%\.github\workflows\do-release.cmd %WDIR%\build\do-release.cmd
+
+      - name: Test
+        shell: cmd
+        run: |
+          set PLATFORM=${{matrix.platform}}
+          set 7Z_PATH=build\bin-%PLATFORM%\7z.exe
+          tclsh tests\7z-test.tcl -verbose tpsem
+
+      - name: Upload a Build Artifact
+        uses: actions/upload-artifact@v4
+        with:
+          path: ${{ github.workspace }}\build\**\*
+          name: binary-${{ matrix.arch }}
+
+  do-release:
+    runs-on: windows-latest
+    needs: build
+    steps:
+    - uses: actions/download-artifact@v4
+      with:
+        path: artifact
+        pattern: binary-*
+        merge-multiple: true    
+
+    - name: Generate binaries for release
+      shell: cmd
+      run: |
+        cd artifact
+        do-release.cmd
+
+    - uses: geekyeggo/delete-artifact@v5
+      with:
+          name: binary-*
+
+    - uses: actions/upload-artifact@v4
+      with:
+        name: 7-Zip ZS Release binaries
+        path: |
+          artifact\*.exe
+          artifact\*.7z
diff --git a/.gitignore b/.gitignore
index c92c68481..5b5fab4b4 100644
--- a/.gitignore
+++ b/.gitignore
@@ -6,4 +6,10 @@
 *.pch
 *.exp
 *.lib
+*.sfx
 
+# Folders
+*.vscode
+**/x86-bin
+**/x64-bin
+**/arm64-bin
diff --git a/C/Precomp.h b/C/Precomp.h
index 7747fdd74..1d44a003a 100644
--- a/C/Precomp.h
+++ b/C/Precomp.h
@@ -21,6 +21,8 @@
     _UNICODE 1
 */
 
+#define Z7_WIN32_WINNT_MIN  0x0600
+
 #include "Compiler.h"
 
 #ifdef _MSC_VER
diff --git a/CPP/7zip/7zip.mak b/CPP/7zip/7zip.mak
index 6e51b9927..8601d6fad 100644
--- a/CPP/7zip/7zip.mak
+++ b/CPP/7zip/7zip.mak
@@ -38,10 +38,14 @@ OBJS = \
   $(ASM_OBJS) \
   $O\resource.res \
 
+!include "../../../../DarkMode/7zRes/7zDarkObj.mak"
+
 !include "../../../Build.mak"
 
 # MAK_SINGLE_FILE = 1
 
+!include "../../../../DarkMode/7zRes/7zDark.mak"
+
 !IFDEF MAK_SINGLE_FILE
 
 !IFDEF CURRENT_OBJS
diff --git a/CPP/7zip/UI/FileManager/AboutDialog.rc b/CPP/7zip/UI/FileManager/AboutDialog.rc
index 763f755a8..d12da9467 100644
--- a/CPP/7zip/UI/FileManager/AboutDialog.rc
+++ b/CPP/7zip/UI/FileManager/AboutDialog.rc
@@ -1,6 +1,7 @@
 #include "AboutDialogRes.h"
 #include "../../GuiCommon.rc"
 #include "../../MyVersion.h"
+#include "../../../../DarkMode/src/Version.h"
 
 #define xc 316
 #define yc 144
@@ -24,4 +25,6 @@ CAPTION "About 7-Zip"
   LTEXT  "", IDT_ABOUT_DATE, m, 67, xc, 8
   LTEXT  MY_COPYRIGHT_CR, -1, m, 80, xc, 8
   LTEXT  "7-Zip is free software", IDT_ABOUT_INFO, m, y, xc, (by - y - 1)
+  LTEXT  DM_VERSION, -1, m, 106, xc, 8
+  LTEXT  DM_COPYRIGHT, -1, m, 119, xc, 8
 }
diff --git a/CPP/7zip/UI/FileManager/App.cpp b/CPP/7zip/UI/FileManager/App.cpp
index 5b7d6167c..8ac07c3bb 100644
--- a/CPP/7zip/UI/FileManager/App.cpp
+++ b/CPP/7zip/UI/FileManager/App.cpp
@@ -29,6 +29,8 @@
 
 #include "PropertyNameRes.h"
 
+#include "../../../../DarkMode/src/DarkModeSubclass.h"
+
 using namespace NWindows;
 using namespace NFile;
 using namespace NDir;
@@ -285,6 +287,8 @@ HRESULT CApp::Create(HWND hwnd, const UString &mainPath, const UString &arcForma
 {
   _window.Attach(hwnd);
 
+  DarkMode::initDarkMode(L"7zDark");
+
   #ifdef UNDER_CE
   _commandBar.Create(g_hInstance, hwnd, 1);
   #endif
@@ -350,7 +354,20 @@ HRESULT CApp::Create(HWND hwnd, const UString &mainPath, const UString &arcForma
       }
     }
   }
-  
+
+  DarkMode::setWindowEraseBgSubclass(hwnd);
+  DarkMode::setDarkWndNotifySafeEx(hwnd, true, true);
+  DarkMode::setWindowMenuBarSubclass(hwnd);
+
+  for (i = 0; i < kNumPanelsMax; i++)
+  {
+    DarkMode::setWindowEraseBgSubclass(Panels[i]);
+    DarkMode::setWindowCtlColorSubclass(Panels[i]);
+    DarkMode::setWindowEraseBgSubclass(Panels[i]._headerReBar);
+    DarkMode::setWindowCtlColorSubclass(Panels[i]._headerReBar);
+    DarkMode::setWindowNotifyCustomDrawSubclass(Panels[i]);
+  }
+
   SetFocusedPanel(LastFocusedPanel);
   Panels[LastFocusedPanel].SetFocusToList();
   return S_OK;
diff --git a/CPP/7zip/UI/FileManager/MenuPage.cpp b/CPP/7zip/UI/FileManager/MenuPage.cpp
index 2f5e1767a..af8a4c48d 100644
--- a/CPP/7zip/UI/FileManager/MenuPage.cpp
+++ b/CPP/7zip/UI/FileManager/MenuPage.cpp
@@ -22,6 +22,8 @@
 #include "MenuPage.h"
 #include "MenuPageRes.h"
 
+#include "../../../../DarkMode/src/DarkModeSubclass.h"
+
 
 using namespace NWindows;
 using namespace NContextMenuFlags;
@@ -283,6 +285,8 @@ bool CMenuPage::OnInit()
   _listView.SetColumnWidthAuto(0);
   _initMode = false;
 
+  DarkMode::setDarkListViewCheckboxes(_listView);
+
   return CPropertyPage::OnInit();
 }
 
diff --git a/CPP/Build.mak b/CPP/Build.mak
index ab5611304..cb37ae47a 100644
--- a/CPP/Build.mak
+++ b/CPP/Build.mak
@@ -71,7 +71,7 @@ CFLAGS_WARN_LEVEL = -Wall
 !ENDIF
 
 # CFLAGS = $(CFLAGS) -nologo -c -Fo$O/ $(CFLAGS_WARN_LEVEL) -WX -EHsc -Gy -MT -MP -GR- -GL -Gw
-CFLAGS = $(CFLAGS) -nologo -c -Fo$O/ -W4 -WX -EHsc -Gy -MT -MP -GR- -GL -Gw
+CFLAGS = $(CFLAGS) -nologo -c -Fo$O/ -W4 -WX -EHsc -Gy -MT -MP -GR- -GL -Gw -std:c++20
 
 !IF "$(CC)" == "clang-cl"
 
@@ -145,7 +145,7 @@ CFLAGS_O2 = $(CFLAGS) -O2 /Ob3
 LFLAGS = $(LFLAGS) -nologo -OPT:REF -OPT:ICF -INCREMENTAL:NO
 
 !IFNDEF UNDER_CE
-LFLAGS = $(LFLAGS) /LTCG /LARGEADDRESSAWARE
+LFLAGS = $(LFLAGS) /LTCG /LARGEADDRESSAWARE /DEPENDENTLOADFLAG:0x800
 !ENDIF
 
 !IFDEF DEF_FILE
@@ -158,7 +158,7 @@ LFLAGS = $(LFLAGS) -DLL -DEF:$(DEF_FILE)
 !ENDIF
 !IFDEF SUB_SYS_VER
 
-MY_SUB_SYS_VER=5.02
+MY_SUB_SYS_VER=6.00
 
 !IFDEF MY_CONSOLE
 LFLAGS = $(LFLAGS) /SUBSYSTEM:console,$(MY_SUB_SYS_VER)
diff --git a/CPP/Windows/Control/Dialog.cpp b/CPP/Windows/Control/Dialog.cpp
index cbb000bb2..75ebe2eee 100644
--- a/CPP/Windows/Control/Dialog.cpp
+++ b/CPP/Windows/Control/Dialog.cpp
@@ -10,6 +10,8 @@
 
 #include "Dialog.h"
 
+#include "../../../DarkMode/src/DarkModeSubclass.h"
+
 extern HINSTANCE g_hInstance;
 #ifndef _UNICODE
 extern bool g_IsNT;
@@ -34,7 +36,11 @@ DialogProcedure(HWND dialogHWND, UINT message, WPARAM wParam, LPARAM lParam)
   if (dialog == NULL)
     return FALSE;
   if (message == WM_INITDIALOG)
-    dialog->Attach(dialogHWND);
+    {
+      dialog->Attach(dialogHWND);
+      DarkMode::initDarkMode(L"7zDark");
+      DarkMode::setDarkWndNotifySafeEx(*dialog, true, true);
+    }
 
   /* MSDN: The dialog box procedure should return
        TRUE  - if it processed the message
diff --git a/CPP/Windows/Control/PropertyPage.cpp b/CPP/Windows/Control/PropertyPage.cpp
index 9b36cbec8..7321c284d 100644
--- a/CPP/Windows/Control/PropertyPage.cpp
+++ b/CPP/Windows/Control/PropertyPage.cpp
@@ -8,6 +8,8 @@
 
 #include "PropertyPage.h"
 
+#include "../../../DarkMode/src/DarkModeSubclass.h"
+
 extern HINSTANCE g_hInstance;
 #ifndef _UNICODE
 extern bool g_IsNT;
@@ -31,7 +33,13 @@ APIENTRY MyProperyPageProcedure(HWND dialogHWND, UINT message, WPARAM wParam, LP
   if (dialog == NULL)
     return FALSE;
   if (message == WM_INITDIALOG)
-    dialog->Attach(dialogHWND);
+    {
+      dialog->Attach(dialogHWND);
+      DarkMode::setDarkWndNotifySafeEx(::GetParent(*dialog), true, true);
+      DarkMode::setWindowCtlColorSubclass(*dialog);
+      DarkMode::setWindowNotifyCustomDrawSubclass(*dialog);
+      DarkMode::setChildCtrlsSubclassAndTheme(*dialog);
+    }
   try { return BoolToBOOL(dialog->OnMessage(message, wParam, lParam)); }
   catch(...) { return TRUE; }
 }
diff --git a/CPP/Windows/Shell.cpp b/CPP/Windows/Shell.cpp
index 01ceb2288..1caafc2e0 100644
--- a/CPP/Windows/Shell.cpp
+++ b/CPP/Windows/Shell.cpp
@@ -10,6 +10,8 @@
 #include "MemoryGlobal.h"
 #include "Shell.h"
 
+#include "../../DarkMode/src/DarkModeSubclass.h"
+
 #ifndef _UNICODE
 extern bool g_IsNT;
 #endif
@@ -683,6 +685,7 @@ static int CALLBACK BrowseCallbackProc(HWND hwnd, UINT uMsg, LPARAM /* lp */, LP
   {
     case BFFM_INITIALIZED:
     {
+      DarkMode::setDarkWndSafe(hwnd, false);
       SendMessage(hwnd, BFFM_SETSELECTION, TRUE, data);
       break;
     }
diff --git a/DarkMode/7zRes/7zDark.ini b/DarkMode/7zRes/7zDark.ini
new file mode 100644
index 000000000..d9f3b1548
--- /dev/null
+++ b/DarkMode/7zRes/7zDark.ini
@@ -0,0 +1,57 @@
+[main]
+mode = 1
+
+[dark]
+tone = 0
+roundCorner = 0
+borderColor = "FFFFFF"
+mica = 0
+colorizeTitleBar = 0
+
+[dark.colors]
+background =            "202020"
+backgroundCtrl =        "383838"
+backgroundHot =         "454545"
+backgroundDlg =         "202020"
+text =                  "E0E0E0"
+textItem =              "C0C0C0"
+textDisabled =          "808080"
+edge =                  "646464"
+edgeHot =               "9B9B9B"
+edgeDisabled =          "484848"
+
+[dark.colors.view]
+backgroundView =        "3F3F3F"
+textView =              "DCDCDC"
+gridlines =             "646464"
+backgroundHeader =      "202020"
+backgroundHotHeader =   "404040"
+textHeader =            "C0C0C0"
+edgeHeader =            "646464"
+
+[light]
+roundCorner = 0
+borderColor = "FFFFFF"
+mica = 0
+colorizeTitleBar = 0
+
+[light.colors]
+background =            "F0F0F0"
+backgroundCtrl =        "FFFFFF"
+backgroundHot =         "C0DCF3"
+backgroundDlg =         "F0F0F0"
+text =                  "000000"
+textItem =              "000000"
+textDisabled =          "6D6D6D"
+edge =                  "8D8D8D"
+edgeHot =               "0078D4"
+edgeDisabled =          "6D6D6D"
+
+[light.colors.view]
+backgroundView =        "FFFFFF"
+textView =              "000000"
+gridlines =             "F0F0F0"
+backgroundHeader =      "FFFFFF"
+backgroundHotHeader =   "D9EBF9"
+textHeader =            "000000"
+edgeHeader =            "E5E5E5"
diff --git a/DarkMode/7zRes/7zDark.mak b/DarkMode/7zRes/7zDark.mak
new file mode 100644
index 000000000..b7eaa0a7e
--- /dev/null
+++ b/DarkMode/7zRes/7zDark.mak
@@ -0,0 +1,13 @@
+!IFDEF MAK_SINGLE_FILE
+
+!IFDEF DARK_MODE_OBJS
+$(DARK_MODE_OBJS): ../../../../DarkMode/src/$(*B).cpp
+	$(COMPL)
+!ENDIF
+
+!ELSE
+
+{../../../../DarkMode/src}.cpp{$O}.obj::
+	$(COMPLB)
+
+!ENDIF
diff --git a/DarkMode/7zRes/7zDarkObj.mak b/DarkMode/7zRes/7zDarkObj.mak
new file mode 100644
index 000000000..1daae577a
--- /dev/null
+++ b/DarkMode/7zRes/7zDarkObj.mak
@@ -0,0 +1,9 @@
+!IFDEF WIN_CTRL_OBJS
+DARK_MODE_OBJS = \
+  $O\DarkMode.obj \
+  $O\DarkModeSubclass.obj \
+!ENDIF
+
+OBJS = \
+  $(OBJS) \
+  $(DARK_MODE_OBJS) \
diff --git a/DarkMode/LICENSE-MIT.md b/DarkMode/LICENSE-MIT.md
new file mode 100644
index 000000000..82d5e59d7
--- /dev/null
+++ b/DarkMode/LICENSE-MIT.md
@@ -0,0 +1,21 @@
+### MIT License
+
+Copyright (c) 2024-2025 ozone10
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
diff --git a/DarkMode/LICENSE.md b/DarkMode/LICENSE.md
new file mode 100644
index 000000000..ab810efd9
--- /dev/null
+++ b/DarkMode/LICENSE.md
@@ -0,0 +1,357 @@
+Mozilla Public License Version 2.0
+==================================
+
+### 1. Definitions
+
+**1.1. “Contributor”**  
+    means each individual or legal entity that creates, contributes to
+    the creation of, or owns Covered Software.
+
+**1.2. “Contributor Version”**  
+    means the combination of the Contributions of others (if any) used
+    by a Contributor and that particular Contributor's Contribution.
+
+**1.3. “Contribution”**  
+    means Covered Software of a particular Contributor.
+
+**1.4. “Covered Software”**  
+    means Source Code Form to which the initial Contributor has attached
+    the notice in Exhibit A, the Executable Form of such Source Code
+    Form, and Modifications of such Source Code Form, in each case
+    including portions thereof.
+
+**1.5. “Incompatible With Secondary Licenses”**  
+    means
+
+* **(a)** that the initial Contributor has attached the notice described
+    in Exhibit B to the Covered Software; or
+* **(b)** that the Covered Software was made available under the terms of
+    version 1.1 or earlier of the License, but not also under the
+    terms of a Secondary License.
+
+**1.6. “Executable Form”**  
+    means any form of the work other than Source Code Form.
+
+**1.7. “Larger Work”**  
+    means a work that combines Covered Software with other material, in 
+    a separate file or files, that is not Covered Software.
+
+**1.8. “License”**  
+    means this document.
+
+**1.9. “Licensable”**  
+    means having the right to grant, to the maximum extent possible,
+    whether at the time of the initial grant or subsequently, any and
+    all of the rights conveyed by this License.
+
+**1.10. “Modifications”**  
+    means any of the following:
+
+* **(a)** any file in Source Code Form that results from an addition to,
+    deletion from, or modification of the contents of Covered
+    Software; or
+* **(b)** any new file in Source Code Form that contains any Covered
+    Software.
+
+**1.11. “Patent Claims” of a Contributor**  
+    means any patent claim(s), including without limitation, method,
+    process, and apparatus claims, in any patent Licensable by such
+    Contributor that would be infringed, but for the grant of the
+    License, by the making, using, selling, offering for sale, having
+    made, import, or transfer of either its Contributions or its
+    Contributor Version.
+
+**1.12. “Secondary License”**  
+    means either the GNU General Public License, Version 2.0, the GNU
+    Lesser General Public License, Version 2.1, the GNU Affero General
+    Public License, Version 3.0, or any later versions of those
+    licenses.
+
+**1.13. “Source Code Form”**  
+    means the form of the work preferred for making modifications.
+
+**1.14. “You” (or “Your”)**  
+    means an individual or a legal entity exercising rights under this
+    License. For legal entities, “You” includes any entity that
+    controls, is controlled by, or is under common control with You. For
+    purposes of this definition, “control” means **(a)** the power, direct
+    or indirect, to cause the direction or management of such entity,
+    whether by contract or otherwise, or **(b)** ownership of more than
+    fifty percent (50%) of the outstanding shares or beneficial
+    ownership of such entity.
+
+
+### 2. License Grants and Conditions
+
+#### 2.1. Grants
+
+Each Contributor hereby grants You a world-wide, royalty-free,
+non-exclusive license:
+
+* **(a)** under intellectual property rights (other than patent or trademark)
+    Licensable by such Contributor to use, reproduce, make available,
+    modify, display, perform, distribute, and otherwise exploit its
+    Contributions, either on an unmodified basis, with Modifications, or
+    as part of a Larger Work; and
+* **(b)** under Patent Claims of such Contributor to make, use, sell, offer
+    for sale, have made, import, and otherwise transfer either its
+    Contributions or its Contributor Version.
+
+#### 2.2. Effective Date
+
+The licenses granted in Section 2.1 with respect to any Contribution
+become effective for each Contribution on the date the Contributor first
+distributes such Contribution.
+
+#### 2.3. Limitations on Grant Scope
+
+The licenses granted in this Section 2 are the only rights granted under
+this License. No additional rights or licenses will be implied from the
+distribution or licensing of Covered Software under this License.
+Notwithstanding Section 2.1(b) above, no patent license is granted by a
+Contributor:
+
+* **(a)** for any code that a Contributor has removed from Covered Software;
+    or
+* **(b)** for infringements caused by: **(i)** Your and any other third party's
+    modifications of Covered Software, or **(ii)** the combination of its
+    Contributions with other software (except as part of its Contributor
+    Version); or
+* **(c)** under Patent Claims infringed by Covered Software in the absence of
+    its Contributions.
+
+This License does not grant any rights in the trademarks, service marks,
+or logos of any Contributor (except as may be necessary to comply with
+the notice requirements in Section 3.4).
+
+#### 2.4. Subsequent Licenses
+
+No Contributor makes additional grants as a result of Your choice to
+distribute the Covered Software under a subsequent version of this
+License (see Section 10.2) or under the terms of a Secondary License (if
+permitted under the terms of Section 3.3).
+
+#### 2.5. Representation
+
+Each Contributor represents that the Contributor believes its
+Contributions are its original creation(s) or it has sufficient rights
+to grant the rights to its Contributions conveyed by this License.
+
+#### 2.6. Fair Use
+
+This License is not intended to limit any rights You have under
+applicable copyright doctrines of fair use, fair dealing, or other
+equivalents.
+
+#### 2.7. Conditions
+
+Sections 3.1, 3.2, 3.3, and 3.4 are conditions of the licenses granted
+in Section 2.1.
+
+
+### 3. Responsibilities
+
+#### 3.1. Distribution of Source Form
+
+All distribution of Covered Software in Source Code Form, including any
+Modifications that You create or to which You contribute, must be under
+the terms of this License. You must inform recipients that the Source
+Code Form of the Covered Software is governed by the terms of this
+License, and how they can obtain a copy of this License. You may not
+attempt to alter or restrict the recipients' rights in the Source Code
+Form.
+
+#### 3.2. Distribution of Executable Form
+
+If You distribute Covered Software in Executable Form then:
+
+* **(a)** such Covered Software must also be made available in Source Code
+    Form, as described in Section 3.1, and You must inform recipients of
+    the Executable Form how they can obtain a copy of such Source Code
+    Form by reasonable means in a timely manner, at a charge no more
+    than the cost of distribution to the recipient; and
+
+* **(b)** You may distribute such Executable Form under the terms of this
+    License, or sublicense it under different terms, provided that the
+    license for the Executable Form does not attempt to limit or alter
+    the recipients' rights in the Source Code Form under this License.
+
+#### 3.3. Distribution of a Larger Work
+
+You may create and distribute a Larger Work under terms of Your choice,
+provided that You also comply with the requirements of this License for
+the Covered Software. If the Larger Work is a combination of Covered
+Software with a work governed by one or more Secondary Licenses, and the
+Covered Software is not Incompatible With Secondary Licenses, this
+License permits You to additionally distribute such Covered Software
+under the terms of such Secondary License(s), so that the recipient of
+the Larger Work may, at their option, further distribute the Covered
+Software under the terms of either this License or such Secondary
+License(s).
+
+#### 3.4. Notices
+
+You may not remove or alter the substance of any license notices
+(including copyright notices, patent notices, disclaimers of warranty,
+or limitations of liability) contained within the Source Code Form of
+the Covered Software, except that You may alter any license notices to
+the extent required to remedy known factual inaccuracies.
+
+#### 3.5. Application of Additional Terms
+
+You may choose to offer, and to charge a fee for, warranty, support,
+indemnity or liability obligations to one or more recipients of Covered
+Software. However, You may do so only on Your own behalf, and not on
+behalf of any Contributor. You must make it absolutely clear that any
+such warranty, support, indemnity, or liability obligation is offered by
+You alone, and You hereby agree to indemnify every Contributor for any
+liability incurred by such Contributor as a result of warranty, support,
+indemnity or liability terms You offer. You may include additional
+disclaimers of warranty and limitations of liability specific to any
+jurisdiction.
+
+
+### 4. Inability to Comply Due to Statute or Regulation
+
+If it is impossible for You to comply with any of the terms of this
+License with respect to some or all of the Covered Software due to
+statute, judicial order, or regulation then You must: **(a)** comply with
+the terms of this License to the maximum extent possible; and **(b)**
+describe the limitations and the code they affect. Such description must
+be placed in a text file included with all distributions of the Covered
+Software under this License. Except to the extent prohibited by statute
+or regulation, such description must be sufficiently detailed for a
+recipient of ordinary skill to be able to understand it.
+
+
+### 5. Termination
+
+**5.1.** The rights granted under this License will terminate automatically
+if You fail to comply with any of its terms. However, if You become
+compliant, then the rights granted under this License from a particular
+Contributor are reinstated **(a)** provisionally, unless and until such
+Contributor explicitly and finally terminates Your grants, and **(b)** on an
+ongoing basis, if such Contributor fails to notify You of the
+non-compliance by some reasonable means prior to 60 days after You have
+come back into compliance. Moreover, Your grants from a particular
+Contributor are reinstated on an ongoing basis if such Contributor
+notifies You of the non-compliance by some reasonable means, this is the
+first time You have received notice of non-compliance with this License
+from such Contributor, and You become compliant prior to 30 days after
+Your receipt of the notice.
+
+**5.2.** If You initiate litigation against any entity by asserting a patent
+infringement claim (excluding declaratory judgment actions,
+counter-claims, and cross-claims) alleging that a Contributor Version
+directly or indirectly infringes any patent, then the rights granted to
+You by any and all Contributors for the Covered Software under Section
+2.1 of this License shall terminate.
+
+**5.3.** In the event of termination under Sections 5.1 or 5.2 above, all
+end user license agreements (excluding distributors and resellers) which
+have been validly granted by You or Your distributors under this License
+prior to termination shall survive termination.
+
+
+### 6. Disclaimer of Warranty
+
+> Covered Software is provided under this License on an “as is”
+> basis, without warranty of any kind, either expressed, implied, or
+> statutory, including, without limitation, warranties that the
+> Covered Software is free of defects, merchantable, fit for a
+> particular purpose or non-infringing. The entire risk as to the
+> quality and performance of the Covered Software is with You.
+> Should any Covered Software prove defective in any respect, You
+> (not any Contributor) assume the cost of any necessary servicing,
+> repair, or correction. This disclaimer of warranty constitutes an
+> essential part of this License. No use of any Covered Software is
+> authorized under this License except under this disclaimer.
+
+### 7. Limitation of Liability
+
+> Under no circumstances and under no legal theory, whether tort
+> (including negligence), contract, or otherwise, shall any
+> Contributor, or anyone who distributes Covered Software as
+> permitted above, be liable to You for any direct, indirect,
+> special, incidental, or consequential damages of any character
+> including, without limitation, damages for lost profits, loss of
+> goodwill, work stoppage, computer failure or malfunction, or any
+> and all other commercial damages or losses, even if such party
+> shall have been informed of the possibility of such damages. This
+> limitation of liability shall not apply to liability for death or
+> personal injury resulting from such party's negligence to the
+> extent applicable law prohibits such limitation. Some
+> jurisdictions do not allow the exclusion or limitation of
+> incidental or consequential damages, so this exclusion and
+> limitation may not apply to You.
+
+
+### 8. Litigation
+
+Any litigation relating to this License may be brought only in the
+courts of a jurisdiction where the defendant maintains its principal
+place of business and such litigation shall be governed by laws of that
+jurisdiction, without reference to its conflict-of-law provisions.
+Nothing in this Section shall prevent a party's ability to bring
+cross-claims or counter-claims.
+
+
+### 9. Miscellaneous
+
+This License represents the complete agreement concerning the subject
+matter hereof. If any provision of this License is held to be
+unenforceable, such provision shall be reformed only to the extent
+necessary to make it enforceable. Any law or regulation which provides
+that the language of a contract shall be construed against the drafter
+shall not be used to construe this License against a Contributor.
+
+
+### 10. Versions of the License
+
+#### 10.1. New Versions
+
+Mozilla Foundation is the license steward. Except as provided in Section
+10.3, no one other than the license steward has the right to modify or
+publish new versions of this License. Each version will be given a
+distinguishing version number.
+
+#### 10.2. Effect of New Versions
+
+You may distribute the Covered Software under the terms of the version
+of the License under which You originally received the Covered Software,
+or under the terms of any subsequent version published by the license
+steward.
+
+#### 10.3. Modified Versions
+
+If you create software not governed by this License, and you want to
+create a new license for such software, you may create and use a
+modified version of this License if you rename the license and remove
+any references to the name of the license steward (except to note that
+such modified license differs from this License).
+
+#### 10.4. Distributing Source Code Form that is Incompatible With Secondary Licenses
+
+If You choose to distribute Source Code Form that is Incompatible With
+Secondary Licenses under the terms of this version of the License, the
+notice described in Exhibit B of this License must be attached.
+
+## Exhibit A - Source Code Form License Notice
+
+    This Source Code Form is subject to the terms of the Mozilla Public
+    License, v. 2.0. If a copy of the MPL was not distributed with this
+    file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+If it is not possible or desirable to put the notice in a particular
+file, then You may include the notice in a location (such as a LICENSE
+file in a relevant directory) where a recipient would be likely to look
+for such a notice.
+
+You may add additional accurate notices of copyright ownership.
+
+## Exhibit B - “Incompatible With Secondary Licenses” Notice
+
+    This Source Code Form is "Incompatible With Secondary Licenses", as
+    defined by the Mozilla Public License, v. 2.0.
+
+
diff --git a/DarkMode/docs/Dark.ini b/DarkMode/docs/Dark.ini
new file mode 100644
index 000000000..90bc88a8c
--- /dev/null
+++ b/DarkMode/docs/Dark.ini
@@ -0,0 +1,166 @@
+; ===============================================
+; Dark.ini - Custom Color and UI Configuration
+; ===============================================
+
+; This is example file, which allows customization of colors and UI styles.
+; Place this file in the same folder as executable,
+; which use darkmodelib for it to take effect.
+; File should have same name as defined in source code of executable.
+; It is defined when not definig preprocessor macro _DARKMODELIB_NO_INI_CONFIG 
+; and using function static void initOptions(const std::wstring& iniName).
+
+; ===============================================
+; [main] - General configuration settings
+; ===============================================
+
+[main]
+; Determines theme and styling.
+; 0 - Use light mode.
+; 1 - Use dark mode (default when dark mode is enabled).
+; 2 - Follow system settings (light mode in system with light enabled).
+; 3 - Use classic style (default in system with light mode enabled).
+; 4 - Follow system settings (classic style in system with light enabled).
+mode = 1
+
+; *Tips: Renaming section will disable all "key=value" pairs of that section
+;        and default values will be used.
+
+; ===============================================
+; [dark] - Dark mode-specific settings
+; ===============================================
+
+[dark]
+; Defines default colors for dark mode.
+; 0 - Black (default).
+; 1 - Red.
+; 2 - Green.
+; 3 - Blue.
+; 4 - Purple.
+; 5 - Cyan.
+; 6 - Olive.
+tone = 0
+
+; Controls rounded corners on Windows 11.
+; 0 - System decides (default).
+; 1 - Never round window corners.
+; 2 - Round corners if appropriate.
+; 3 - Round corners with a small radius.
+roundCorner = 0
+
+; Sets window border color (RGB hex format: RRGGBB) on Windows 11.
+; FFFFFF - Use default system color (default).
+borderColor = "FFFFFF"
+
+; Applies Mica material (Windows 11 22H2 build 22621 required).
+; 0 - System decides (default).
+; 1 - Do not use Mica.
+; 2 - Apply Mica material.
+; 3 - Apply Acrylic effect.
+; 4 - Apply Mica Alt material.
+; *Note: When using mica=1 with Settings -> Personalization > Colors ->
+;        "Show accent color on title bars and window borders" setting on,
+;        turn this Windows setting off to prevent glitches.
+mica = 0
+
+; Expands Mica material across window/dialog (experimental).
+; 0 - Apply Mica only on title bar (default).
+; 1 - Extend Mica to all window/dialog elements.
+; * Note: Use micaExtend=1 only with HDR and ACM disabled to prevent glitches.
+micaExtend = 0
+
+; Should title bar use same colors as dialog background and static text
+; 0 - Use system colors (default).
+; 1 - Use custom colors (backgroundDlg and text).
+; * Note: with micaExtend=1 this option will be disabled.
+colorizeTitleBar = 0
+
+; ===============================================
+; [dark.colors] - Custom colors for dark mode UI
+; ===============================================
+
+[dark.colors]
+; Background color for "read-only" controls.
+background          = "202020"
+; Background color for controls (buttons, input fields).
+backgroundCtrl      = "383838"
+; Background color for hovered (hot) items.
+backgroundHot       = "454545"
+; Background color for dialogs and popups.
+backgroundDlg       = "202020"
+; Background color for error messages or alerts.
+backgroundError     = "B00000"
+; Primary text color for most UI elements.
+text                = "E0E0E0"
+; Low-light text color used as secondary color for some UI components.
+textItem            = "C0C0C0"
+; Text color used for disabled or inactive controls.
+textDisabled        = "808080"
+; Text color used for hyperlinks.
+textLink            = "FFFF00"
+; Border color used for standard UI elements.
+edge                = "646464"
+; Border color used for hovered elements.
+edgeHot             = "9B9B9B"
+; Border color for disabled or inactive elements.
+edgeDisabled        = "484848"
+
+; ===============================================
+; [dark.colors.view] - Colors for list and tree views
+; ===============================================
+
+[dark.colors.view]
+; Background color for list and tree views.
+backgroundView      = "3F3F3F"
+; Text color in list/tree view items.
+textView            = "DCDCDC"
+; Grid line color in list view (when grid lines are enabled).
+gridlines           = "646464"
+; Background color for headers in list/tree view.
+backgroundHeader    = "202020"
+; Background color for hovered headers.
+backgroundHotHeader = "454545"
+; Text color for headers.
+textHeader          = "C0C0C0"
+; Border color for headers.
+edgeHeader          = "646464"
+
+; ===============================================
+; [light] - Light mode-specific settings
+; ===============================================
+
+[light]
+roundCorner = 0
+borderColor  = "FFFFFF"
+mica = 0
+colorizeTitleBar = 0
+
+; ===============================================
+; [light.colors] - Custom colors for light mode UI
+; ===============================================
+
+[light.colors]
+background          = "F0F0F0"
+backgroundCtrl      = "FFFFFF"
+backgroundHot       = "C0DCF3"
+backgroundDlg       = "F0F0F0"
+backgroundError     = "A01000"
+text                = "000000"
+textItem            = "000000"
+textDisabled        = "6D6D6D"
+textLink            = "0078D4"
+edge                = "8D8D8D"
+edgeHot             = "0078D4"
+edgeDisabled        = "6D6D6D"
+
+; ===============================================
+; [light.colors.view] - Colors for list and tree views (light mode)
+; ===============================================
+
+[light.colors.view]
+backgroundView      = "FFFFFF"
+textView            = "000000"
+gridlines           = "F0F0F0"
+backgroundHeader    = "FFFFFF"
+backgroundHotHeader = "D9EBF9"
+textHeader          = "000000"
+edgeHeader          = "E5E5E5"
diff --git a/DarkMode/docs/LICENSE-PolyHook_2_0.md b/DarkMode/docs/LICENSE-PolyHook_2_0.md
new file mode 100644
index 000000000..f76de84c6
--- /dev/null
+++ b/DarkMode/docs/LICENSE-PolyHook_2_0.md
@@ -0,0 +1,21 @@
+MIT License
+
+Copyright (c) 2018 Stephen Eckels
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
diff --git a/DarkMode/docs/LICENSE-UAHMenuBar.md b/DarkMode/docs/LICENSE-UAHMenuBar.md
new file mode 100644
index 000000000..c1f88996d
--- /dev/null
+++ b/DarkMode/docs/LICENSE-UAHMenuBar.md
@@ -0,0 +1,21 @@
+MIT License
+
+Copyright (c) 2021 adzm
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
diff --git a/DarkMode/docs/LICENSE-win32-darkmode.md b/DarkMode/docs/LICENSE-win32-darkmode.md
new file mode 100644
index 000000000..13bdb5355
--- /dev/null
+++ b/DarkMode/docs/LICENSE-win32-darkmode.md
@@ -0,0 +1,21 @@
+MIT License
+
+Copyright (c) 2019 Richard Yu
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
diff --git a/DarkMode/src/DarkMode.cpp b/DarkMode/src/DarkMode.cpp
new file mode 100644
index 000000000..e0fe1b0c9
--- /dev/null
+++ b/DarkMode/src/DarkMode.cpp
@@ -0,0 +1,640 @@
+// SPDX-License-Identifier: MPL-2.0
+
+/*
+ * Copyright (c) 2025 ozone10
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at https://mozilla.org/MPL/2.0/.
+ *
+ * This file incorporates work from the win32-darkmode project:
+ *  https://github.com/ysc3839/win32-darkmode
+ *  which is covered by the MIT License.
+ *  See LICENSE-win32-darkmode for more information.
+ */
+
+
+#include "StdAfx.h"
+
+#ifndef WIN32_LEAN_AND_MEAN
+#define WIN32_LEAN_AND_MEAN
+#endif
+#ifndef VC_EXTRALEAN
+#define VC_EXTRALEAN
+#endif
+#ifndef NOMINMAX
+#define NOMINMAX
+#endif
+
+#include "DarkMode.h"
+
+#include <uxtheme.h>
+#include <vsstyle.h>
+
+#if defined(_DARKMODELIB_USE_SCROLLBAR_FIX) && (_DARKMODELIB_USE_SCROLLBAR_FIX > 0)
+#include <mutex>
+#include <unordered_set>
+#endif
+
+#if !defined(_DARKMODELIB_EXTERNAL_IATHOOK)
+#include "IatHook.h"
+#else
+extern PIMAGE_THUNK_DATA FindAddressByName(void* moduleBase, PIMAGE_THUNK_DATA impName, PIMAGE_THUNK_DATA impAddr, const char* funcName);
+extern PIMAGE_THUNK_DATA FindAddressByOrdinal(void* moduleBase, PIMAGE_THUNK_DATA impName, PIMAGE_THUNK_DATA impAddr, uint16_t ordinal);
+extern PIMAGE_THUNK_DATA FindIatThunkInModule(void* moduleBase, const char* dllName, const char* funcName);
+extern PIMAGE_THUNK_DATA FindDelayLoadThunkInModule(void* moduleBase, const char* dllName, const char* funcName);
+extern PIMAGE_THUNK_DATA FindDelayLoadThunkInModule(void* moduleBase, const char* dllName, uint16_t ordinal);
+#endif
+
+#if defined(_MSC_VER) && _MSC_VER >= 1800
+#pragma warning(disable : 4191)
+#elif defined(__GNUC__)
+#include <cwchar>
+#endif
+
+template <typename P>
+static auto ReplaceFunction(IMAGE_THUNK_DATA* addr, const P& newFunction) -> P
+{
+	DWORD oldProtect = 0;
+	if (VirtualProtect(addr, sizeof(IMAGE_THUNK_DATA), PAGE_READWRITE, &oldProtect) == FALSE)
+	{
+		return nullptr;
+	}
+
+	const uintptr_t oldFunction = addr->u1.Function;
+	addr->u1.Function = reinterpret_cast<uintptr_t>(newFunction);
+	VirtualProtect(addr, sizeof(IMAGE_THUNK_DATA), oldProtect, &oldProtect);
+	return reinterpret_cast<P>(oldFunction);
+}
+
+template <typename P>
+static auto loadFn(HMODULE handle, P& pointer, const char* name) -> bool
+{
+	if (auto proc = ::GetProcAddress(handle, name); proc != nullptr)
+	{
+		pointer = reinterpret_cast<P>(proc);
+		return true;
+	}
+	return false;
+}
+
+template <typename P>
+static auto loadFn(HMODULE handle, P& pointer, WORD index) -> bool
+{
+	return loadFn(handle, pointer, MAKEINTRESOURCEA(index));
+}
+
+class ModuleHandle
+{
+public:
+	ModuleHandle() = delete;
+
+	explicit ModuleHandle(const wchar_t* moduleName)
+		: hModule(LoadLibraryEx(moduleName, nullptr, LOAD_LIBRARY_SEARCH_SYSTEM32))
+	{}
+
+	ModuleHandle(const ModuleHandle&) = delete;
+	ModuleHandle& operator=(const ModuleHandle&) = delete;
+
+	ModuleHandle(ModuleHandle&&) = delete;
+	ModuleHandle& operator=(ModuleHandle&&) = delete;
+
+	~ModuleHandle()
+	{
+		if (hModule != nullptr)
+		{
+			FreeLibrary(hModule);
+		}
+	}
+
+	[[nodiscard]] HMODULE get() const
+	{
+		return hModule;
+	}
+
+	[[nodiscard]] bool isLoaded() const
+	{
+		return hModule != nullptr;
+	}
+
+private:
+	HMODULE hModule = nullptr;
+};
+
+enum IMMERSIVE_HC_CACHE_MODE
+{
+	IHCM_USE_CACHED_VALUE,
+	IHCM_REFRESH
+};
+
+// 1903 18362
+enum class PreferredAppMode
+{
+	Default,
+	AllowDark,
+	ForceDark,
+	ForceLight,
+	Max
+};
+
+#if defined(_DARKMODELIB_ALLOW_OLD_OS) && (_DARKMODELIB_ALLOW_OLD_OS > 0)
+enum WINDOWCOMPOSITIONATTRIB
+{
+	WCA_UNDEFINED = 0,
+	WCA_NCRENDERING_ENABLED = 1,
+	WCA_NCRENDERING_POLICY = 2,
+	WCA_TRANSITIONS_FORCEDISABLED = 3,
+	WCA_ALLOW_NCPAINT = 4,
+	WCA_CAPTION_BUTTON_BOUNDS = 5,
+	WCA_NONCLIENT_RTL_LAYOUT = 6,
+	WCA_FORCE_ICONIC_REPRESENTATION = 7,
+	WCA_EXTENDED_FRAME_BOUNDS = 8,
+	WCA_HAS_ICONIC_BITMAP = 9,
+	WCA_THEME_ATTRIBUTES = 10,
+	WCA_NCRENDERING_EXILED = 11,
+	WCA_NCADORNMENTINFO = 12,
+	WCA_EXCLUDED_FROM_LIVEPREVIEW = 13,
+	WCA_VIDEO_OVERLAY_ACTIVE = 14,
+	WCA_FORCE_ACTIVEWINDOW_APPEARANCE = 15,
+	WCA_DISALLOW_PEEK = 16,
+	WCA_CLOAK = 17,
+	WCA_CLOAKED = 18,
+	WCA_ACCENT_POLICY = 19,
+	WCA_FREEZE_REPRESENTATION = 20,
+	WCA_EVER_UNCLOAKED = 21,
+	WCA_VISUAL_OWNER = 22,
+	WCA_HOLOGRAPHIC = 23,
+	WCA_EXCLUDED_FROM_DDA = 24,
+	WCA_PASSIVEUPDATEMODE = 25,
+	WCA_USEDARKMODECOLORS = 26,
+	WCA_LAST = 27
+};
+
+struct WINDOWCOMPOSITIONATTRIBDATA
+{
+	WINDOWCOMPOSITIONATTRIB Attrib;
+	PVOID pvData;
+	SIZE_T cbData;
+};
+#endif
+
+using fnRtlGetNtVersionNumbers = void (WINAPI*)(LPDWORD major, LPDWORD minor, LPDWORD build);
+#if defined(_DARKMODELIB_ALLOW_OLD_OS) && (_DARKMODELIB_ALLOW_OLD_OS > 0)
+using fnSetWindowCompositionAttribute = BOOL (WINAPI*)(HWND hWnd, WINDOWCOMPOSITIONATTRIBDATA*);
+#endif
+// 1809 17763
+using fnShouldAppsUseDarkMode = auto (WINAPI*)() -> bool; // ordinal 132
+using fnAllowDarkModeForWindow = auto (WINAPI*)(HWND hWnd, bool allow) -> bool; // ordinal 133
+#if defined(_DARKMODELIB_ALLOW_OLD_OS) && (_DARKMODELIB_ALLOW_OLD_OS > 0)
+using fnAllowDarkModeForApp = auto (WINAPI*)(bool allow) -> bool; // ordinal 135, in 1809
+#endif
+using fnFlushMenuThemes = void (WINAPI*)(); // ordinal 136
+using fnRefreshImmersiveColorPolicyState = void (WINAPI*)(); // ordinal 104
+using fnIsDarkModeAllowedForWindow = auto (WINAPI*)(HWND hWnd) -> bool; // ordinal 137
+using fnGetIsImmersiveColorUsingHighContrast = auto (WINAPI*)(IMMERSIVE_HC_CACHE_MODE mode) -> bool; // ordinal 106
+using fnOpenNcThemeData = auto (WINAPI*)(HWND hWnd, LPCWSTR pszClassList) -> HTHEME; // ordinal 49
+// 1903 18362
+//using fnShouldSystemUseDarkMode = auto (WINAPI*)() -> bool; // ordinal 138
+using fnSetPreferredAppMode = auto (WINAPI*)(PreferredAppMode appMode) -> PreferredAppMode; // ordinal 135, in 1903
+//using fnIsDarkModeAllowedForApp = auto (WINAPI*)() -> bool; // ordinal 139
+
+#if defined(_DARKMODELIB_ALLOW_OLD_OS) && (_DARKMODELIB_ALLOW_OLD_OS > 0)
+static fnSetWindowCompositionAttribute pfSetWindowCompositionAttribute = nullptr;
+#endif
+static fnShouldAppsUseDarkMode pfShouldAppsUseDarkMode = nullptr;
+static fnAllowDarkModeForWindow pfAllowDarkModeForWindow = nullptr;
+#if defined(_DARKMODELIB_ALLOW_OLD_OS) && (_DARKMODELIB_ALLOW_OLD_OS > 0)
+static fnAllowDarkModeForApp _AllowDarkModeForApp = nullptr;
+#endif
+static fnFlushMenuThemes pfFlushMenuThemes = nullptr;
+static fnRefreshImmersiveColorPolicyState pfRefreshImmersiveColorPolicyState = nullptr;
+static fnIsDarkModeAllowedForWindow pfIsDarkModeAllowedForWindow = nullptr;
+static fnGetIsImmersiveColorUsingHighContrast pfGetIsImmersiveColorUsingHighContrast = nullptr;
+static fnOpenNcThemeData pfOpenNcThemeData = nullptr;
+// 1903 18362
+//static fnShouldSystemUseDarkMode _ShouldSystemUseDarkMode = nullptr;
+static fnSetPreferredAppMode pfSetPreferredAppMode = nullptr;
+
+bool g_darkModeSupported = false;
+bool g_darkModeEnabled = false;
+static DWORD g_buildNumber = 0;
+
+bool ShouldAppsUseDarkMode()
+{
+	if (pfShouldAppsUseDarkMode == nullptr)
+	{
+		return false;
+	}
+	return pfShouldAppsUseDarkMode();
+}
+
+bool AllowDarkModeForWindow(HWND hWnd, bool allow)
+{
+	if (g_darkModeSupported && (pfAllowDarkModeForWindow != nullptr))
+	{
+		return pfAllowDarkModeForWindow(hWnd, allow);
+	}
+	return false;
+}
+
+bool IsHighContrast()
+{
+	HIGHCONTRASTW highContrast{};
+	highContrast.cbSize = sizeof(HIGHCONTRASTW);
+	if (SystemParametersInfoW(SPI_GETHIGHCONTRAST, sizeof(HIGHCONTRASTW), &highContrast, FALSE) == TRUE)
+	{
+		return (highContrast.dwFlags & HCF_HIGHCONTRASTON) == HCF_HIGHCONTRASTON;
+	}
+	return false;
+}
+
+#if defined(_DARKMODELIB_ALLOW_OLD_OS) && (_DARKMODELIB_ALLOW_OLD_OS > 0)
+void SetTitleBarThemeColor(HWND hWnd, BOOL dark)
+{
+
+	if (g_buildNumber < 18362)
+		SetPropW(hWnd, L"UseImmersiveDarkModeColors", reinterpret_cast<HANDLE>(static_cast<intptr_t>(dark)));
+	else if (pfSetWindowCompositionAttribute != nullptr)
+	{
+		WINDOWCOMPOSITIONATTRIBDATA data{ WCA_USEDARKMODECOLORS, &dark, sizeof(dark) };
+		pfSetWindowCompositionAttribute(hWnd, &data);
+	}
+}
+
+void RefreshTitleBarThemeColor(HWND hWnd)
+{
+	BOOL dark = FALSE;
+	if (pfIsDarkModeAllowedForWindow != nullptr && pfShouldAppsUseDarkMode != nullptr)
+	{
+		if (pfIsDarkModeAllowedForWindow(hWnd) && pfShouldAppsUseDarkMode() && !IsHighContrast())
+		{
+			dark = TRUE;
+		}
+	}
+
+	SetTitleBarThemeColor(hWnd, dark);
+}
+#endif
+
+bool IsColorSchemeChangeMessage(LPARAM lParam)
+{
+	bool isMsg = false;
+	if ((lParam != 0) // NULL
+		&& (_wcsicmp(reinterpret_cast<LPCWSTR>(lParam), L"ImmersiveColorSet") == 0)
+		&& pfRefreshImmersiveColorPolicyState != nullptr)
+	{
+		pfRefreshImmersiveColorPolicyState();
+		isMsg = true;
+	}
+
+	if (pfGetIsImmersiveColorUsingHighContrast != nullptr)
+	{
+		pfGetIsImmersiveColorUsingHighContrast(IHCM_REFRESH);
+	}
+
+	return isMsg;
+}
+
+bool IsColorSchemeChangeMessage(UINT uMsg, LPARAM lParam)
+{
+	if (uMsg == WM_SETTINGCHANGE)
+	{
+		return IsColorSchemeChangeMessage(lParam);
+	}
+	return false;
+}
+
+void AllowDarkModeForApp(bool allow)
+{
+	if (pfSetPreferredAppMode != nullptr)
+	{
+		pfSetPreferredAppMode(allow ? PreferredAppMode::ForceDark : PreferredAppMode::Default);
+	}
+#if defined(_DARKMODELIB_ALLOW_OLD_OS) && (_DARKMODELIB_ALLOW_OLD_OS > 0)
+	else if (_AllowDarkModeForApp != nullptr)
+	{
+		_AllowDarkModeForApp(allow);
+	}
+#endif
+}
+
+static void FlushMenuThemes()
+{
+	if (pfFlushMenuThemes != nullptr)
+	{
+		pfFlushMenuThemes();
+	}
+}
+
+
+#if defined(_DARKMODELIB_USE_SCROLLBAR_FIX) && (_DARKMODELIB_USE_SCROLLBAR_FIX > 0)
+#if defined(_DARKMODELIB_USE_SCROLLBAR_FIX) && (_DARKMODELIB_USE_SCROLLBAR_FIX > 1)
+// limit dark scroll bar to specific windows and their children
+static std::unordered_set<HWND> g_darkScrollBarWindows;
+static std::mutex g_darkScrollBarMutex;
+
+void EnableDarkScrollBarForWindowAndChildren(HWND hWnd)
+{
+	const std::lock_guard<std::mutex> lock(g_darkScrollBarMutex);
+	g_darkScrollBarWindows.insert(hWnd);
+}
+
+static bool IsWindowOrParentUsingDarkScrollBar(HWND hWnd)
+{
+	HWND hRoot = GetAncestor(hWnd, GA_ROOT);
+
+	const std::lock_guard<std::mutex> lock(g_darkScrollBarMutex);
+	auto hasElement = [](const auto& container, HWND hWndToCheck) -> bool {
+#if (defined(_MSC_VER) && (_MSVC_LANG >= 202002L)) || (__cplusplus >= 202002L)
+		return container.contains(hWndToCheck);
+#else
+		return container.count(hWndToCheck) != 0;
+#endif
+	};
+
+	if (hasElement(g_darkScrollBarWindows, hWnd))
+	{
+		return true;
+	}
+	return (hWnd != hRoot && hasElement(g_darkScrollBarWindows, hRoot));
+}
+#endif // defined(_DARKMODELIB_USE_SCROLLBAR_FIX) && (_DARKMODELIB_USE_SCROLLBAR_FIX > 1)
+
+static HTHEME WINAPI MyOpenNcThemeData(HWND hWnd, LPCWSTR pszClassList)
+{
+	static constexpr std::wstring_view scrollBarClassName = WC_SCROLLBAR;
+	if (scrollBarClassName == pszClassList)
+	{
+#if defined(_DARKMODELIB_USE_SCROLLBAR_FIX) && (_DARKMODELIB_USE_SCROLLBAR_FIX > 1)
+		if (IsWindowOrParentUsingDarkScrollBar(hWnd))
+#endif
+		{
+			hWnd = nullptr;
+			pszClassList = L"Explorer::ScrollBar";
+		}
+	}
+	return pfOpenNcThemeData(hWnd, pszClassList);
+}
+
+static void FixDarkScrollBar()
+{
+	const ModuleHandle moduleComctl(L"comctl32.dll");
+	if (moduleComctl.isLoaded())
+	{
+		auto* addr = FindDelayLoadThunkInModule(moduleComctl.get(), "uxtheme.dll", 49); // OpenNcThemeData
+		if (addr != nullptr) // && pfOpenNcThemeData != nullptr) // checked in InitDarkMode
+		{
+			ReplaceFunction<fnOpenNcThemeData>(addr, MyOpenNcThemeData);
+		}
+	}
+}
+#endif // defined(_DARKMODELIB_USE_SCROLLBAR_FIX) && (_DARKMODELIB_USE_SCROLLBAR_FIX > 0)
+
+#if defined(_DARKMODELIB_ALLOW_OLD_OS) && (_DARKMODELIB_ALLOW_OLD_OS > 0)
+static constexpr DWORD g_win10Build = 17763;
+#else
+static constexpr DWORD g_win10Build = 19044; // 21H2 latest LTSC, 22H2 19045 latest GA
+#endif
+static constexpr DWORD g_win11Build = 22000;
+
+bool IsWindows10() // or later OS version
+{
+	return (g_buildNumber >= g_win10Build);
+}
+
+bool IsWindows11() // or later OS version
+{
+	return (g_buildNumber >= g_win11Build);
+}
+
+static constexpr bool CheckBuildNumber(DWORD buildNumber)
+{
+#if defined(_DARKMODELIB_ALLOW_OLD_OS) && (_DARKMODELIB_ALLOW_OLD_OS > 0) 
+	static constexpr size_t nWin10Builds = 8;
+	// Windows 10 builds { 1809, 1903, 1909, 2004, 20H2, 21H1, 21H2, 22H2 }
+	static constexpr DWORD win10Builds[nWin10Builds] = { 17763, 18362, 18363, 19041, 19042, 19043, 19044, 19045 };
+
+	// Windows 10 any version >= 22H2 and Windows 11
+	if ((buildNumber >= win10Builds[nWin10Builds - 1])) // || buildNumber > g_win11Build
+	{
+		return true;
+	}
+
+	for (size_t i = 0; i < nWin10Builds; ++i)
+	{
+		if (buildNumber == win10Builds[i])
+		{
+			return true;
+		}
+	}
+	return false;
+#else
+	return (buildNumber >= g_win10Build); // || buildNumber > g_win11Build
+#endif
+}
+
+DWORD GetWindowsBuildNumber()
+{
+	return g_buildNumber;
+}
+
+void InitDarkMode()
+{
+	static bool isInit = false;
+	if (isInit)
+	{
+		return;
+	}
+
+	fnRtlGetNtVersionNumbers RtlGetNtVersionNumbers = nullptr;
+	HMODULE hNtdll = GetModuleHandleW(L"ntdll.dll");
+	if (hNtdll != nullptr && loadFn(hNtdll, RtlGetNtVersionNumbers, "RtlGetNtVersionNumbers"))
+	{
+		DWORD major = 0;
+		DWORD minor = 0;
+		RtlGetNtVersionNumbers(&major, &minor, &g_buildNumber);
+		g_buildNumber &= ~0xF0000000;
+		if (major == 10 && minor == 0 && CheckBuildNumber(g_buildNumber))
+		{
+			const ModuleHandle moduleUxtheme(L"uxtheme.dll");
+			if (moduleUxtheme.isLoaded())
+			{
+				const HMODULE& hUxtheme = moduleUxtheme.get();
+
+				bool ptrFnOrd135NotNullptr = false;
+#if defined(_DARKMODELIB_ALLOW_OLD_OS) && (_DARKMODELIB_ALLOW_OLD_OS > 0)
+				if (g_buildNumber < 18362)
+					ptrFnOrd135NotNullptr = loadFn(hUxtheme, _AllowDarkModeForApp, 135);
+				else
+#endif
+					ptrFnOrd135NotNullptr = loadFn(hUxtheme, pfSetPreferredAppMode, 135);
+
+				if (ptrFnOrd135NotNullptr
+					&& loadFn(hUxtheme, pfOpenNcThemeData, 49)
+					&& loadFn(hUxtheme, pfRefreshImmersiveColorPolicyState, 104)
+					&& loadFn(hUxtheme, pfShouldAppsUseDarkMode, 132)
+					&& loadFn(hUxtheme, pfAllowDarkModeForWindow, 133)
+					&& loadFn(hUxtheme, pfFlushMenuThemes, 136)
+					&& loadFn(hUxtheme, pfIsDarkModeAllowedForWindow, 137))
+				{
+					g_darkModeSupported = true;
+				}
+
+				loadFn(hUxtheme, pfGetIsImmersiveColorUsingHighContrast, 106);
+#if defined(_DARKMODELIB_ALLOW_OLD_OS) && (_DARKMODELIB_ALLOW_OLD_OS > 0)
+				if (g_buildNumber < 19041)
+				{
+					HMODULE hUser32 = GetModuleHandleW(L"user32.dll");
+					if (hUser32 != nullptr)
+					{
+						loadFn(hUser32, pfSetWindowCompositionAttribute, "SetWindowCompositionAttribute");
+					}
+				}
+#endif
+				isInit = true;
+			}
+		}
+	}
+}
+
+void SetDarkMode(bool useDark, [[maybe_unused]] bool fixDarkScrollbar)
+{
+	if (g_darkModeSupported)
+	{
+		AllowDarkModeForApp(useDark);
+		FlushMenuThemes();
+#if defined(_DARKMODELIB_USE_SCROLLBAR_FIX) && (_DARKMODELIB_USE_SCROLLBAR_FIX > 0)
+		if (fixDarkScrollbar)
+		{
+			FixDarkScrollBar();
+		}
+#endif
+		g_darkModeEnabled = useDark && ShouldAppsUseDarkMode() && !IsHighContrast();
+	}
+}
+
+// Hooking GetSysColor for comboboxex' list box and list view's gridlines
+
+using fnGetSysColor = auto (WINAPI*)(int nIndex) -> DWORD;
+
+static fnGetSysColor pfGetSysColor = nullptr;
+
+static COLORREF g_clrWindow = RGB(32, 32, 32);
+static COLORREF g_clrText = RGB(224, 224, 224);
+static COLORREF g_clrTGridlines = RGB(100, 100, 100);
+
+static bool g_isGetSysColorHooked = false;
+static int g_hookRef = 0;
+
+void SetMySysColor(int nIndex, COLORREF clr)
+{
+	switch (nIndex)
+	{
+		case COLOR_WINDOW:
+		{
+			g_clrWindow = clr;
+			break;
+		}
+
+		case COLOR_WINDOWTEXT:
+		{
+			g_clrText = clr;
+			break;
+		}
+
+		case COLOR_BTNFACE:
+		{
+			g_clrTGridlines = clr;
+			break;
+		}
+
+		default:
+		{
+			break;
+		}
+	}
+}
+
+static DWORD WINAPI MyGetSysColor(int nIndex)
+{
+	if (!g_darkModeEnabled)
+	{
+		return GetSysColor(nIndex);
+	}
+
+	switch (nIndex)
+	{
+		case COLOR_WINDOW:
+		{
+			return g_clrWindow;
+		}
+
+		case COLOR_WINDOWTEXT:
+		{
+			return g_clrText;
+		}
+
+		case COLOR_BTNFACE:
+		{
+			return g_clrTGridlines;
+		}
+
+		default:
+		{
+			return GetSysColor(nIndex);
+		}
+	}
+}
+
+bool HookSysColor()
+{
+	const ModuleHandle moduleComctl(L"comctl32.dll");
+	if (moduleComctl.isLoaded())
+	{
+		if (pfGetSysColor == nullptr || !g_isGetSysColorHooked)
+		{
+			auto* addr = FindIatThunkInModule(moduleComctl.get(), "user32.dll", "GetSysColor");
+			if (addr != nullptr)
+			{
+				pfGetSysColor = ReplaceFunction<fnGetSysColor>(addr, MyGetSysColor);
+				g_isGetSysColorHooked = true;
+			}
+			else
+			{
+				return false;
+			}
+		}
+
+		if (g_isGetSysColorHooked)
+		{
+			++g_hookRef;
+		}
+
+		return true;
+	}
+	return false;
+}
+
+void UnhookSysColor()
+{
+	const ModuleHandle moduleComctl(L"comctl32.dll");
+	if (moduleComctl.isLoaded())
+	{
+		if (g_isGetSysColorHooked)
+		{
+			if (g_hookRef > 0)
+			{
+				--g_hookRef;
+			}
+
+			if (g_hookRef == 0)
+			{
+				auto* addr = FindIatThunkInModule(moduleComctl.get(), "user32.dll", "GetSysColor");
+				if (addr != nullptr)
+				{
+					ReplaceFunction<fnGetSysColor>(addr, pfGetSysColor);
+					g_isGetSysColorHooked = false;
+				}
+			}
+		}
+	}
+}
diff --git a/DarkMode/src/DarkMode.h b/DarkMode/src/DarkMode.h
new file mode 100644
index 000000000..d28a8cf0f
--- /dev/null
+++ b/DarkMode/src/DarkMode.h
@@ -0,0 +1,45 @@
+// SPDX-License-Identifier: MPL-2.0
+
+/*
+ * Copyright (c) 2025 ozone10
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at https://mozilla.org/MPL/2.0/.
+ *
+ * This file incorporates work from the win32-darkmode project:
+ *  https://github.com/ysc3839/win32-darkmode
+ *  which is covered by the MIT License.
+ *  See LICENSE-win32-darkmode for more information.
+ */
+
+
+#pragma once
+
+#include <windows.h>
+
+extern bool g_darkModeSupported;
+extern bool g_darkModeEnabled;
+
+
+[[nodiscard]] bool ShouldAppsUseDarkMode();
+bool AllowDarkModeForWindow(HWND hWnd, bool allow);
+[[nodiscard]] bool IsHighContrast();
+#if defined(_DARKMODELIB_ALLOW_OLD_OS) && (_DARKMODELIB_ALLOW_OLD_OS > 0)
+void RefreshTitleBarThemeColor(HWND hWnd);
+void SetTitleBarThemeColor(HWND hWnd, BOOL dark);
+#endif
+[[nodiscard]] bool IsColorSchemeChangeMessage(LPARAM lParam);
+[[nodiscard]] bool IsColorSchemeChangeMessage(UINT uMsg, LPARAM lParam);
+void AllowDarkModeForApp(bool allow);
+#if defined(_DARKMODELIB_USE_SCROLLBAR_FIX) && (_DARKMODELIB_USE_SCROLLBAR_FIX > 0)
+void EnableDarkScrollBarForWindowAndChildren(HWND hWnd);
+#endif
+void InitDarkMode();
+void SetDarkMode(bool useDark, bool fixDarkScrollbar);
+[[nodiscard]] bool IsWindows10();
+[[nodiscard]] bool IsWindows11();
+[[nodiscard]] DWORD GetWindowsBuildNumber();
+
+void SetMySysColor(int nIndex, COLORREF clr);
+bool HookSysColor();
+void UnhookSysColor();
diff --git a/DarkMode/src/DarkModeSubclass.cpp b/DarkMode/src/DarkModeSubclass.cpp
new file mode 100644
index 000000000..83dac52b0
--- /dev/null
+++ b/DarkMode/src/DarkModeSubclass.cpp
@@ -0,0 +1,8288 @@
+﻿// SPDX-License-Identifier: MPL-2.0
+
+/*
+ * Copyright (c) 2025 ozone10
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at https://mozilla.org/MPL/2.0/.
+ */
+
+// Based on the Notepad++ dark mode code licensed under GPLv3.
+// Originally by adzm / Adam D. Walling, with modifications by the Notepad++ team.
+// Heavily modified by ozone10 (Notepad++ contributor).
+// Used with permission to relicense under the Mozilla Public License, v. 2.0.
+
+
+#include "StdAfx.h"
+
+#ifndef WIN32_LEAN_AND_MEAN
+#define WIN32_LEAN_AND_MEAN
+#endif
+#ifndef VC_EXTRALEAN
+#define VC_EXTRALEAN
+#endif
+#ifndef NOMINMAX
+#define NOMINMAX
+#endif
+
+#include "DarkModeSubclass.h"
+
+#if !defined(_DARKMODELIB_NOT_USED)
+
+#include <dwmapi.h>
+#include <richedit.h>
+#include <uxtheme.h>
+#include <vssym32.h>
+#include <windowsx.h>
+
+#include <array>
+#include <cmath>
+#include <memory>
+#include <string>
+
+#include "DarkMode.h"
+#include "UAHMenuBar.h"
+
+#include "Version.h"
+
+#if defined(__GNUC__)
+#include <cstdint>
+//static constexpr DWORD DWMWA_USE_IMMERSIVE_DARK_MODE = 20;
+static constexpr int CP_DROPDOWNITEM = 9; // for some reason mingw use only enum up to 8
+#endif
+
+#ifndef WM_DPICHANGED
+#define WM_DPICHANGED 0x02E0
+#endif
+
+//#ifndef WM_DPICHANGED_BEFOREPARENT
+//#define WM_DPICHANGED_BEFOREPARENT 0x02E2
+//#endif
+
+#ifndef WM_DPICHANGED_AFTERPARENT
+#define WM_DPICHANGED_AFTERPARENT 0x02E3
+#endif
+
+//#ifndef WM_GETDPISCALEDSIZE
+//#define WM_GETDPISCALEDSIZE 0x02E4
+//#endif
+
+/// Converts 0xRRGGBB to COLORREF (0xBBGGRR) for GDI usage.
+static constexpr COLORREF HEXRGB(DWORD rrggbb)
+{
+	return
+		((rrggbb & 0xFF0000) >> 16) |
+		((rrggbb & 0x00FF00)) |
+		((rrggbb & 0x0000FF) << 16);
+}
+
+/**
+ * @brief Retrieves the class name of a given window.
+ *
+ * This function wraps the Win32 API `GetClassNameW` to return the class name
+ * of a window as a wide string (`std::wstring`).
+ *
+ * @param hWnd Handle to the target window.
+ * @return The class name of the window as a `std::wstring`.
+ *
+ * @note The maximum length is capped at 32 characters (including the null terminator),
+ *       which suffices for standard Windows window classes.
+ */
+static std::wstring GetWndClassName(HWND hWnd)
+{
+	static constexpr int strLen = 32;
+	std::wstring className(strLen, L'\0');
+	className.resize(static_cast<size_t>(::GetClassNameW(hWnd, className.data(), strLen)));
+	return className;
+}
+
+/**
+ * @brief Compares the class name of a window with a specified string.
+ *
+ * This function retrieves the class name of the given window handle
+ * and compares it to the provided class name.
+ *
+ * @param hWnd Handle to the window whose class name is to be checked.
+ * @param classNameToCmp Pointer to a null-terminated wide string representing the class name to compare against.
+ * @return `true` if the window's class name matches the specified string; otherwise `false`.
+ *
+ * @see GetWndClassName()
+ */
+static bool CmpWndClassName(HWND hWnd, const wchar_t* classNameToCmp)
+{
+	return (GetWndClassName(hWnd) == classNameToCmp);
+}
+
+#if !defined(_DARKMODELIB_NO_INI_CONFIG)
+/**
+ * @brief Constructs a full path to an `.ini` file located next to the executable.
+ *
+ * Retrieves the directory of the current module (executable or DLL) and appends
+ * the specified `.ini` filename to it.
+ *
+ * @param iniFilename The base name of the `.ini` file (without path or extension).
+ * @return Full path to the `.ini` file as a wide string, or an empty string on failure.
+ *
+ * @note Returns a path like: `C:\\Path\\To\\Executable\\YourFile.ini`
+ */
+static std::wstring GetIniPath(const std::wstring& iniFilename)
+{
+	std::array<wchar_t, MAX_PATH> buffer{};
+	const auto strLen = static_cast<size_t>(::GetModuleFileNameW(nullptr, buffer.data(), MAX_PATH));
+	if (strLen == 0)
+	{
+		return L"";
+	}
+
+	wchar_t* lastSlash = std::wcsrchr(buffer.data(), L'\\');
+	if (lastSlash == nullptr)
+	{
+		return L"";
+	}
+
+	*lastSlash = L'\0';
+	std::wstring iniPath(buffer.data());
+	iniPath += L"\\" + iniFilename + L".ini";
+	return iniPath;
+}
+
+/**
+ * @brief Checks whether a file exists at the specified path.
+ *
+ * Determines if the given file path exists and refers to a regular file.
+ *
+ * @param filePath Path to the file to check.
+ * @return `true` if the file exists and is not a directory, otherwise `false`.
+ */
+static bool FileExists(const std::wstring& filePath)
+{
+	const DWORD dwAttrib = ::GetFileAttributesW(filePath.c_str());
+	return (dwAttrib != INVALID_FILE_ATTRIBUTES && ((dwAttrib & FILE_ATTRIBUTE_DIRECTORY) != FILE_ATTRIBUTE_DIRECTORY));
+}
+
+/**
+ * @brief Reads a color value from an `.ini` file and converts it to a `COLORREF`.
+ *
+ * Reads a 6-digit hex color string from the specified section and key, then parses
+ * it as a Windows GDI `COLORREF` value.
+ *
+ * @param sectionName Section within the `.ini` file.
+ * @param keyName Key name containing the hex RGB value (e.g., "E0E2E4").
+ * @param iniFilePath Full path to the `.ini` file.
+ * @param clr Pointer to a `COLORREF` where the parsed color will be stored. **Must not be `nullptr`.**
+ * @return `true` if a valid 6-digit hex color was read and parsed, otherwise `false`.
+ *
+ * @note The value must be exactly 6 hexadecimal digits and represent an RGB color.
+ */
+static bool SetClrFromIni(const std::wstring& sectionName, const std::wstring& keyName, const std::wstring& iniFilePath, COLORREF* clr)
+{
+	static constexpr size_t maxStrLen = 6;
+	std::wstring buffer(maxStrLen + 1, L'\0');
+
+	const auto len = static_cast<size_t>(::GetPrivateProfileStringW(
+		sectionName.c_str()
+		, keyName.c_str()
+		, L""
+		, buffer.data()
+		, static_cast<DWORD>(buffer.size())
+		, iniFilePath.c_str()));
+
+	if (len != maxStrLen)
+	{
+		return false;
+	}
+
+	buffer.resize(len); // remove extra '\0'
+
+	for (const auto& wch : buffer)
+	{
+		if (iswxdigit(wch) == 0)
+		{
+			return false;
+		}
+	}
+
+	try
+	{
+		static constexpr int baseHex = 16;
+		*clr = HEXRGB(std::stoul(buffer, nullptr, baseHex));
+	}
+	catch (const std::exception&)
+	{
+		return false;
+	}
+
+	return true;
+}
+#endif // !defined(_DARKMODELIB_NO_INI_CONFIG)
+
+namespace DarkMode
+{
+	/**
+	 * @brief Returns library version information or compile-time feature flags.
+	 *
+	 * Responds to the specified query by returning either:
+	 * - Version numbers (`verMajor`, `verMinor`, `verRevision`)
+	 * - Build configuration flags (returns `TRUE` or `FALSE`)
+	 * - A constant value (`featureCheck`, `maxValue`) used for validation
+	 *
+	 * @param libInfoType Enum value specifying which piece of information to retrieve.
+	 * @return Integer value:
+	 * - Version: as defined by `DM_VERSION_MAJOR`, etc.
+	 * - Boolean flags: `TRUE` (1) if the feature is enabled, `FALSE` (0) otherwise.
+	 * - `featureCheck`, `maxValue`: returns the numeric max enum value.
+	 * - `-1`: for invalid or unhandled enum cases (should not occur in correct usage).
+	 *
+	 * @see LibInfo
+	 */
+	int getLibInfo(LibInfo libInfoType)
+	{
+		switch (libInfoType)
+		{
+			case LibInfo::maxValue:
+			case LibInfo::featureCheck:
+			{
+				return static_cast<int>(LibInfo::maxValue);
+			}
+
+			case LibInfo::verMajor:
+			{
+				return DM_VERSION_MAJOR;
+			}
+
+			case LibInfo::verMinor:
+			{
+				return DM_VERSION_MINOR;
+			}
+
+			case LibInfo::verRevision:
+			{
+				return DM_VERSION_REVISION;
+			}
+
+			case LibInfo::iathookExternal:
+			{
+#if defined(_DARKMODELIB_EXTERNAL_IATHOOK)
+				return TRUE;
+#else
+				return FALSE;
+#endif
+			}
+
+			case LibInfo::iniConfigUsed:
+			{
+#if !defined(_DARKMODELIB_NO_INI_CONFIG)
+				return TRUE;
+#else
+				return FALSE;
+#endif
+			}
+
+			case LibInfo::allowOldOS:
+			{
+#if defined(_DARKMODELIB_ALLOW_OLD_OS)
+				return _DARKMODELIB_ALLOW_OLD_OS;
+#else
+				return FALSE;
+#endif
+			}
+
+			case LibInfo::useDlgProcCtl:
+			{
+#if defined(_DARKMODELIB_DLG_PROC_CTLCOLOR_RETURNS)
+				return _DARKMODELIB_DLG_PROC_CTLCOLOR_RETURNS;
+#else
+				return FALSE;
+#endif
+			}
+
+			case LibInfo::preferTheme:
+			{
+#if defined(_DARKMODELIB_PREFER_THEME)
+				return _DARKMODELIB_PREFER_THEME;
+#else
+				return FALSE;
+#endif
+			}
+
+			case LibInfo::useSBFix:
+			{
+#if defined(_DARKMODELIB_USE_SCROLLBAR_FIX)
+				return _DARKMODELIB_USE_SCROLLBAR_FIX;
+#else
+				return FALSE;
+#endif
+			}
+		}
+		return -1; // should never happen
+	}
+
+	/**
+	 * @brief Describes how the application responds to the system theme.
+	 *
+	 * Used to determine behavior when following the system's light/dark mode setting.
+	 * - `disabled`: Do not follow system; use manually selected appearance.
+	 * - `light`: Follow system mode; apply light theme when system is in light mode.
+	 * - `classic`: Follow system mode; apply classic style when system is in light mode.
+	 */
+	enum class WinMode : std::uint8_t
+	{
+		disabled,  ///< Manual — system mode is ignored.
+		light,     ///< Use light theme if system is in light mode.
+		classic    ///< Use classic style if system is in light mode.
+	};
+
+	static constexpr UINT_PTR kButtonSubclassID                 = 42;
+	static constexpr UINT_PTR kGroupboxSubclassID               = 1;
+	static constexpr UINT_PTR kUpDownSubclassID                 = 2;
+	static constexpr UINT_PTR kTabPaintSubclassID               = 3;
+	static constexpr UINT_PTR kTabUpDownSubclassID              = 4;
+	static constexpr UINT_PTR kCustomBorderSubclassID           = 5;
+	static constexpr UINT_PTR kComboBoxSubclassID               = 6;
+	static constexpr UINT_PTR kComboBoxExSubclassID             = 7;
+	static constexpr UINT_PTR kListViewSubclassID               = 8;
+	static constexpr UINT_PTR kHeaderSubclassID                 = 9;
+	static constexpr UINT_PTR kStatusBarSubclassID              = 10;
+	static constexpr UINT_PTR kProgressBarSubclassID            = 11;
+	static constexpr UINT_PTR kStaticTextSubclassID             = 12;
+	static constexpr UINT_PTR kWindowEraseBgSubclassID          = 13;
+	static constexpr UINT_PTR kWindowCtlColorSubclassID         = 14;
+	static constexpr UINT_PTR kWindowNotifySubclassID           = 15;
+	static constexpr UINT_PTR kWindowMenuBarSubclassID          = 16;
+	static constexpr UINT_PTR kWindowSettingChangeSubclassID    = 17;
+
+	/**
+	 * @struct DarkModeParams
+	 * @brief Defines theming and subclassing parameters for child controls.
+	 *
+	 * Members:
+	 * - `_themeClassName`: Optional theme class name (e.g. `"DarkMode_Explorer"`), or `nullptr` to skip theming.
+	 * - `_subclass`: Whether to apply custom subclassing for dark-mode painting and behavior.
+	 * - `_theme`: Whether to apply a themed visual style to applicable controls.
+	 *
+	 * Used during enumeration to configure dark mode application on a per-control basis.
+	 */
+	struct DarkModeParams
+	{
+		const wchar_t* _themeClassName = nullptr;
+		bool _subclass = false;
+		bool _theme = false;
+	};
+
+	/// Base roundness value for various controls, such as toolbar iconic buttons and combo boxes
+	static constexpr int kWin11CornerRoundness = 4;
+
+	/// Threshold range around 50.0 where TreeView uses classic style instead of light/dark.
+	static constexpr double kMiddleGrayRange = 2.0;
+
+	namespace // anonymous
+	{
+		/// Global struct
+		struct
+		{
+			DWM_WINDOW_CORNER_PREFERENCE _roundCorner = DWMWCP_DEFAULT;
+			COLORREF _borderColor = DWMWA_COLOR_DEFAULT;
+			DWM_SYSTEMBACKDROP_TYPE _mica = DWMSBT_AUTO;
+			COLORREF _tvBackground = RGB(41, 49, 52);
+			double _lightness = 50.0;
+			TreeViewStyle _tvStylePrev = TreeViewStyle::classic;
+			TreeViewStyle _tvStyle = TreeViewStyle::classic;
+			bool _micaExtend = false;
+			bool _colorizeTitleBar = false;
+			DarkModeType _dmType = DarkModeType::dark;
+			WinMode _windowsMode = WinMode::disabled;
+			bool _isInit = false;
+			bool _isInitExperimental = false;
+
+#if !defined(_DARKMODELIB_NO_INI_CONFIG)
+			std::wstring _iniName;
+			bool _isIniNameSet = false;
+#endif
+		} g_dmCfg;
+	} // anonymous namespace
+
+	struct Brushes
+	{
+		HBRUSH _background = nullptr;
+		HBRUSH _ctrlBackground = nullptr;
+		HBRUSH _hotBackground = nullptr;
+		HBRUSH _dlgBackground = nullptr;
+		HBRUSH _errorBackground = nullptr;
+
+		HBRUSH _edge = nullptr;
+		HBRUSH _hotEdge = nullptr;
+		HBRUSH _disabledEdge = nullptr;
+
+		Brushes() = delete;
+
+		explicit Brushes(const Colors& colors) noexcept
+			: _background(::CreateSolidBrush(colors.background))
+			, _ctrlBackground(::CreateSolidBrush(colors.ctrlBackground))
+			, _hotBackground(::CreateSolidBrush(colors.hotBackground))
+			, _dlgBackground(::CreateSolidBrush(colors.dlgBackground))
+			, _errorBackground(::CreateSolidBrush(colors.errorBackground))
+
+			, _edge(::CreateSolidBrush(colors.edge))
+			, _hotEdge(::CreateSolidBrush(colors.hotEdge))
+			, _disabledEdge(::CreateSolidBrush(colors.disabledEdge))
+		{}
+
+		Brushes(const Brushes&) = delete;
+		Brushes& operator=(const Brushes&) = delete;
+
+		Brushes(Brushes&&) = delete;
+		Brushes& operator=(Brushes&&) = delete;
+
+		~Brushes()
+		{
+			::DeleteObject(_background);         _background = nullptr;
+			::DeleteObject(_ctrlBackground);     _ctrlBackground = nullptr;
+			::DeleteObject(_hotBackground);      _hotBackground = nullptr;
+			::DeleteObject(_dlgBackground);      _dlgBackground = nullptr;
+			::DeleteObject(_errorBackground);    _errorBackground = nullptr;
+
+			::DeleteObject(_edge);               _edge = nullptr;
+			::DeleteObject(_hotEdge);            _hotEdge = nullptr;
+			::DeleteObject(_disabledEdge);       _disabledEdge = nullptr;
+		}
+
+		void updateBrushes(const Colors& colors) noexcept
+		{
+			::DeleteObject(_background);
+			::DeleteObject(_ctrlBackground);
+			::DeleteObject(_hotBackground);
+			::DeleteObject(_dlgBackground);
+			::DeleteObject(_errorBackground);
+
+			::DeleteObject(_edge);
+			::DeleteObject(_hotEdge);
+			::DeleteObject(_disabledEdge);
+
+			_background = ::CreateSolidBrush(colors.background);
+			_ctrlBackground = ::CreateSolidBrush(colors.ctrlBackground);
+			_hotBackground = ::CreateSolidBrush(colors.hotBackground);
+			_dlgBackground = ::CreateSolidBrush(colors.dlgBackground);
+			_errorBackground = ::CreateSolidBrush(colors.errorBackground);
+
+			_edge = ::CreateSolidBrush(colors.edge);
+			_hotEdge = ::CreateSolidBrush(colors.hotEdge);
+			_disabledEdge = ::CreateSolidBrush(colors.disabledEdge);
+		}
+	};
+
+	struct Pens
+	{
+		HPEN _darkerText = nullptr;
+		HPEN _edge = nullptr;
+		HPEN _hotEdge = nullptr;
+		HPEN _disabledEdge = nullptr;
+
+		Pens() = delete;
+
+		explicit Pens(const Colors& colors) noexcept
+			: _darkerText(::CreatePen(PS_SOLID, 1, colors.darkerText))
+			, _edge(::CreatePen(PS_SOLID, 1, colors.edge))
+			, _hotEdge(::CreatePen(PS_SOLID, 1, colors.hotEdge))
+			, _disabledEdge(::CreatePen(PS_SOLID, 1, colors.disabledEdge))
+		{}
+
+		Pens(const Pens&) = delete;
+		Pens& operator=(const Pens&) = delete;
+
+		Pens(Pens&&) = delete;
+		Pens& operator=(Pens&&) = delete;
+
+		~Pens()
+		{
+			::DeleteObject(_darkerText);    _darkerText = nullptr;
+			::DeleteObject(_edge);          _edge = nullptr;
+			::DeleteObject(_hotEdge);       _hotEdge = nullptr;
+			::DeleteObject(_disabledEdge);  _disabledEdge = nullptr;
+		}
+
+		void updatePens(const Colors& colors) noexcept
+		{
+			::DeleteObject(_darkerText);
+			::DeleteObject(_edge);
+			::DeleteObject(_hotEdge);
+			::DeleteObject(_disabledEdge);
+
+			_darkerText = ::CreatePen(PS_SOLID, 1, colors.darkerText);
+			_edge = ::CreatePen(PS_SOLID, 1, colors.edge);
+			_hotEdge = ::CreatePen(PS_SOLID, 1, colors.hotEdge);
+			_disabledEdge = ::CreatePen(PS_SOLID, 1, colors.disabledEdge);
+		}
+	};
+
+	/// Black tone (default)
+	static constexpr Colors darkColors{
+		HEXRGB(0x202020),   // background
+		HEXRGB(0x383838),   // ctrlBackground
+		HEXRGB(0x454545),   // hotBackground
+		HEXRGB(0x202020),   // dlgBackground
+		HEXRGB(0xB00000),   // errorBackground
+		HEXRGB(0xE0E0E0),   // textColor
+		HEXRGB(0xC0C0C0),   // darkerTextColor
+		HEXRGB(0x808080),   // disabledTextColor
+		HEXRGB(0xFFFF00),   // linkTextColor
+		HEXRGB(0x646464),   // edgeColor
+		HEXRGB(0x9B9B9B),   // hotEdgeColor
+		HEXRGB(0x484848)    // disabledEdgeColor
+	};
+
+	static constexpr DWORD offsetEdge = HEXRGB(0x1C1C1C);
+
+	/// Red tone
+	static constexpr DWORD offsetRed = HEXRGB(0x100000);
+	static constexpr Colors darkRedColors{
+		darkColors.background + offsetRed,
+		darkColors.ctrlBackground + offsetRed,
+		darkColors.hotBackground + offsetRed,
+		darkColors.dlgBackground + offsetRed,
+		darkColors.errorBackground,
+		darkColors.text,
+		darkColors.darkerText,
+		darkColors.disabledText,
+		darkColors.linkText,
+		darkColors.edge + offsetEdge + offsetRed,
+		darkColors.hotEdge + offsetRed,
+		darkColors.disabledEdge + offsetRed
+	};
+
+	/// Green tone
+	static constexpr DWORD offsetGreen = HEXRGB(0x001000);
+	static constexpr Colors darkGreenColors{
+		darkColors.background + offsetGreen,
+		darkColors.ctrlBackground + offsetGreen,
+		darkColors.hotBackground + offsetGreen,
+		darkColors.dlgBackground + offsetGreen,
+		darkColors.errorBackground,
+		darkColors.text,
+		darkColors.darkerText,
+		darkColors.disabledText,
+		darkColors.linkText,
+		darkColors.edge + offsetEdge + offsetGreen,
+		darkColors.hotEdge + offsetGreen,
+		darkColors.disabledEdge + offsetGreen
+	};
+
+	/// Blue tone
+	static constexpr DWORD offsetBlue = HEXRGB(0x000020);
+	static constexpr Colors darkBlueColors{
+		darkColors.background + offsetBlue,
+		darkColors.ctrlBackground + offsetBlue,
+		darkColors.hotBackground + offsetBlue,
+		darkColors.dlgBackground + offsetBlue,
+		darkColors.errorBackground,
+		darkColors.text,
+		darkColors.darkerText,
+		darkColors.disabledText,
+		darkColors.linkText,
+		darkColors.edge + offsetEdge + offsetBlue,
+		darkColors.hotEdge + offsetBlue,
+		darkColors.disabledEdge + offsetBlue
+	};
+
+	/// Purple tone
+	static constexpr DWORD offsetPurple = HEXRGB(0x100020);
+	static constexpr Colors darkPurpleColors{
+		darkColors.background + offsetPurple,
+		darkColors.ctrlBackground + offsetPurple,
+		darkColors.hotBackground + offsetPurple,
+		darkColors.dlgBackground + offsetPurple,
+		darkColors.errorBackground,
+		darkColors.text,
+		darkColors.darkerText,
+		darkColors.disabledText,
+		darkColors.linkText,
+		darkColors.edge + offsetEdge + offsetPurple,
+		darkColors.hotEdge + offsetPurple,
+		darkColors.disabledEdge + offsetPurple
+	};
+
+	/// Cyan tone
+	static constexpr DWORD offsetCyan = HEXRGB(0x001020);
+	static constexpr Colors darkCyanColors{
+		darkColors.background + offsetCyan,
+		darkColors.ctrlBackground + offsetCyan,
+		darkColors.hotBackground + offsetCyan,
+		darkColors.dlgBackground + offsetCyan,
+		darkColors.errorBackground,
+		darkColors.text,
+		darkColors.darkerText,
+		darkColors.disabledText,
+		darkColors.linkText,
+		darkColors.edge + offsetEdge + offsetCyan,
+		darkColors.hotEdge + offsetCyan,
+		darkColors.disabledEdge + offsetCyan
+	};
+
+	/// Olive tone
+	static constexpr DWORD offsetOlive = HEXRGB(0x101000);
+	static constexpr Colors darkOliveColors{
+		darkColors.background + offsetOlive,
+		darkColors.ctrlBackground + offsetOlive,
+		darkColors.hotBackground + offsetOlive,
+		darkColors.dlgBackground + offsetOlive,
+		darkColors.errorBackground,
+		darkColors.text,
+		darkColors.darkerText,
+		darkColors.disabledText,
+		darkColors.linkText,
+		darkColors.edge + offsetEdge + offsetOlive,
+		darkColors.hotEdge + offsetOlive,
+		darkColors.disabledEdge + offsetOlive
+	};
+
+	/// Light tone
+	static Colors getLightColors()
+	{
+		const Colors lightColors{
+		::GetSysColor(COLOR_3DFACE),        // background
+		::GetSysColor(COLOR_WINDOW),        // ctrlBackground
+		HEXRGB(0xC0DCF3),                   // hotBackground
+		::GetSysColor(COLOR_3DFACE),        // dlgBackground
+		HEXRGB(0xA01000),                   // errorBackground
+		::GetSysColor(COLOR_WINDOWTEXT),    // textColor
+		::GetSysColor(COLOR_BTNTEXT),       // darkerTextColor
+		::GetSysColor(COLOR_GRAYTEXT),      // disabledTextColor
+		::GetSysColor(COLOR_HOTLIGHT),      // linkTextColor
+		HEXRGB(0x8D8D8D),                   // edgeColor
+		::GetSysColor(COLOR_HIGHLIGHT),     // hotEdgeColor
+		::GetSysColor(COLOR_GRAYTEXT)       // disabledEdgeColor
+		};
+
+		return lightColors;
+	}
+
+	class Theme
+	{
+	public:
+		Theme() noexcept
+			: _colors(darkColors)
+			, _brushes(darkColors)
+			, _pens(darkColors)
+		{}
+
+		explicit Theme(const Colors& colors) noexcept
+			: _colors(colors)
+			, _brushes(colors)
+			, _pens(colors)
+		{}
+
+		void updateTheme()
+		{
+			_brushes.updateBrushes(_colors);
+			_pens.updatePens(_colors);
+		}
+
+		void updateTheme(Colors colors)
+		{
+			_colors = colors;
+			Theme::updateTheme();
+		}
+
+		[[nodiscard]] Colors getToneColors() const
+		{
+			switch (_tone)
+			{
+				case ColorTone::red:
+				{
+					return darkRedColors;
+				}
+
+				case ColorTone::green:
+				{
+					return darkGreenColors;
+				}
+
+				case ColorTone::blue:
+				{
+					return darkBlueColors;
+				}
+
+				case ColorTone::purple:
+				{
+					return darkPurpleColors;
+				}
+
+				case ColorTone::cyan:
+				{
+					return darkCyanColors;
+				}
+
+				case ColorTone::olive:
+				{
+					return darkOliveColors;
+				}
+
+				case ColorTone::black:
+				case ColorTone::max:
+				{
+					break;
+				}
+			}
+			return darkColors;
+		}
+
+		void setToneColors(ColorTone colorTone)
+		{
+			_tone = colorTone;
+
+			switch (_tone)
+			{
+				case ColorTone::red:
+				{
+					_colors = darkRedColors;
+					break;
+				}
+
+				case ColorTone::green:
+				{
+					_colors = darkGreenColors;
+					break;
+				}
+
+				case ColorTone::blue:
+				{
+					_colors = darkBlueColors;
+					break;
+				}
+
+				case ColorTone::purple:
+				{
+					_colors = darkPurpleColors;
+					break;
+				}
+
+				case ColorTone::cyan:
+				{
+					_colors = darkCyanColors;
+					break;
+				}
+
+				case ColorTone::olive:
+				{
+					_colors = darkOliveColors;
+					break;
+				}
+
+				case ColorTone::black:
+				case ColorTone::max:
+				{
+					_colors = darkColors;
+					break;
+				}
+			}
+
+			Theme::updateTheme();
+		}
+
+		void setToneColors()
+		{
+			_colors = Theme::getToneColors();
+			Theme::updateTheme();
+		}
+
+		[[nodiscard]] const Brushes& getBrushes() const
+		{
+			return _brushes;
+		}
+
+		[[nodiscard]] const Pens& getPens() const
+		{
+			return _pens;
+		}
+
+		[[nodiscard]] const ColorTone& getColorTone() const
+		{
+			return _tone;
+		}
+
+		Colors _colors;
+
+	private:
+		Brushes _brushes;
+		Pens _pens;
+		ColorTone _tone = DarkMode::ColorTone::black;
+	};
+
+	static Theme& getTheme()
+	{
+		static Theme tMain{};
+		return tMain;
+	}
+
+	/**
+	 * @brief Sets the color tone and its color set for the active theme.
+	 *
+	 * Applies a color tone (e.g. red, blue, olive) its color set.
+	 *
+	 * @param colorTone The tone to apply (see @ref ColorTone enum).
+	 *
+	 * @see DarkMode::getColorTone()
+	 * @see DarkMode::Theme
+	 */
+	void setColorTone(ColorTone colorTone)
+	{
+		DarkMode::getTheme().setToneColors(colorTone);
+	}
+
+	/**
+	 * @brief Retrieves the currently active color tone for the theme.
+	 *
+	 * @return The currently selected @ref ColorTone value.
+	 *
+	 * @see DarkMode::setColorTone()
+	 */
+	ColorTone getColorTone()
+	{
+		return DarkMode::getTheme().getColorTone();
+	}
+
+	/// Dark views colors
+	static constexpr ColorsView darkColorsView{
+		HEXRGB(0x293134),   // background
+		HEXRGB(0xE0E2E4),   // text
+		HEXRGB(0x646464),   // gridlines
+		HEXRGB(0x202020),   // Header background
+		HEXRGB(0x454545),   // Header hot background
+		HEXRGB(0xC0C0C0),   // header text
+		HEXRGB(0x646464)    // header divider
+	};
+
+	/// Light views colors
+	static constexpr ColorsView lightColorsView{
+		HEXRGB(0xFFFFFF),   // background
+		HEXRGB(0x000000),   // text
+		HEXRGB(0xF0F0F0),   // gridlines
+		HEXRGB(0xFFFFFF),   // header background
+		HEXRGB(0xD9EBF9),   // header hot background
+		HEXRGB(0x000000),   // header text
+		HEXRGB(0xE5E5E5)    // header divider
+	};
+
+	struct BrushesAndPensView
+	{
+		HBRUSH _background = nullptr;
+		HBRUSH _gridlines = nullptr;
+		HBRUSH _headerBackground = nullptr;
+		HBRUSH _headerHotBackground = nullptr;
+
+		HPEN _headerEdge = nullptr;
+
+		BrushesAndPensView() = delete;
+
+		explicit BrushesAndPensView(const ColorsView& colors) noexcept
+			: _background(::CreateSolidBrush(colors.background))
+			, _gridlines(::CreateSolidBrush(colors.gridlines))
+			, _headerBackground(::CreateSolidBrush(colors.headerBackground))
+			, _headerHotBackground(::CreateSolidBrush(colors.headerHotBackground))
+
+			, _headerEdge(::CreatePen(PS_SOLID, 1, colors.headerEdge))
+		{}
+
+		BrushesAndPensView(const BrushesAndPensView&) = delete;
+		BrushesAndPensView& operator=(const BrushesAndPensView&) = delete;
+
+		BrushesAndPensView(BrushesAndPensView&&) = delete;
+		BrushesAndPensView& operator=(BrushesAndPensView&&) = delete;
+
+		~BrushesAndPensView()
+		{
+			::DeleteObject(_background);             _background = nullptr;
+			::DeleteObject(_gridlines);              _gridlines = nullptr;
+			::DeleteObject(_headerBackground);       _headerBackground = nullptr;
+			::DeleteObject(_headerHotBackground);    _headerHotBackground = nullptr;
+
+			::DeleteObject(_headerEdge);             _headerEdge = nullptr;
+		}
+
+		void update(const ColorsView& colors)
+		{
+			::DeleteObject(_background);
+			::DeleteObject(_gridlines);
+			::DeleteObject(_headerBackground);
+			::DeleteObject(_headerHotBackground);
+
+			_background = ::CreateSolidBrush(colors.background);
+			_gridlines = ::CreateSolidBrush(colors.gridlines);
+			_headerBackground = ::CreateSolidBrush(colors.headerBackground);
+			_headerHotBackground = ::CreateSolidBrush(colors.headerHotBackground);
+
+			::DeleteObject(_headerEdge);
+
+			_headerEdge = ::CreatePen(PS_SOLID, 1, colors.headerEdge);
+		}
+	};
+
+	class ThemeView
+	{
+	public:
+		ThemeView() noexcept
+			: _clrView(darkColorsView)
+			, _hbrPnView(darkColorsView)
+		{}
+
+		explicit ThemeView(const ColorsView& colorsView) noexcept
+			: _clrView(colorsView)
+			, _hbrPnView(colorsView)
+		{}
+
+		void updateView()
+		{
+			_hbrPnView.update(_clrView);
+		}
+
+		void updateView(ColorsView colors)
+		{
+			_clrView = colors;
+			ThemeView::updateView();
+		}
+
+		[[nodiscard]] const BrushesAndPensView& getViewBrushesAndPens() const
+		{
+			return _hbrPnView;
+		}
+
+		ColorsView _clrView;
+
+	private:
+		BrushesAndPensView _hbrPnView;
+	};
+
+	static ThemeView& getThemeView()
+	{
+		static ThemeView tView{};
+		return tView;
+	}
+
+	static COLORREF setNewColor(COLORREF* clrOld, COLORREF clrNew)
+	{
+		const auto clrTmp = *clrOld;
+		*clrOld = clrNew;
+		return clrTmp;
+	}
+
+	COLORREF setBackgroundColor(COLORREF clrNew)        { return DarkMode::setNewColor(&DarkMode::getTheme()._colors.background, clrNew); }
+	COLORREF setCtrlBackgroundColor(COLORREF clrNew)    { return DarkMode::setNewColor(&DarkMode::getTheme()._colors.ctrlBackground, clrNew); }
+	COLORREF setHotBackgroundColor(COLORREF clrNew)     { return DarkMode::setNewColor(&DarkMode::getTheme()._colors.hotBackground, clrNew); }
+	COLORREF setDlgBackgroundColor(COLORREF clrNew)     { return DarkMode::setNewColor(&DarkMode::getTheme()._colors.dlgBackground, clrNew); }
+	COLORREF setErrorBackgroundColor(COLORREF clrNew)   { return DarkMode::setNewColor(&DarkMode::getTheme()._colors.errorBackground, clrNew); }
+	COLORREF setTextColor(COLORREF clrNew)              { return DarkMode::setNewColor(&DarkMode::getTheme()._colors.text, clrNew); }
+	COLORREF setDarkerTextColor(COLORREF clrNew)        { return DarkMode::setNewColor(&DarkMode::getTheme()._colors.darkerText, clrNew); }
+	COLORREF setDisabledTextColor(COLORREF clrNew)      { return DarkMode::setNewColor(&DarkMode::getTheme()._colors.disabledText, clrNew); }
+	COLORREF setLinkTextColor(COLORREF clrNew)          { return DarkMode::setNewColor(&DarkMode::getTheme()._colors.linkText, clrNew); }
+	COLORREF setEdgeColor(COLORREF clrNew)              { return DarkMode::setNewColor(&DarkMode::getTheme()._colors.edge, clrNew); }
+	COLORREF setHotEdgeColor(COLORREF clrNew)           { return DarkMode::setNewColor(&DarkMode::getTheme()._colors.hotEdge, clrNew); }
+	COLORREF setDisabledEdgeColor(COLORREF clrNew)      { return DarkMode::setNewColor(&DarkMode::getTheme()._colors.disabledEdge, clrNew); }
+
+	void setThemeColors(Colors colors)
+	{
+		DarkMode::getTheme().updateTheme(colors);
+	}
+
+	void updateThemeBrushesAndPens()
+	{
+		DarkMode::getTheme().updateTheme();
+	}
+
+	COLORREF getBackgroundColor()         { return getTheme()._colors.background; }
+	COLORREF getCtrlBackgroundColor()     { return getTheme()._colors.ctrlBackground; }
+	COLORREF getHotBackgroundColor()      { return getTheme()._colors.hotBackground; }
+	COLORREF getDlgBackgroundColor()      { return getTheme()._colors.dlgBackground; }
+	COLORREF getErrorBackgroundColor()    { return getTheme()._colors.errorBackground; }
+	COLORREF getTextColor()               { return getTheme()._colors.text; }
+	COLORREF getDarkerTextColor()         { return getTheme()._colors.darkerText; }
+	COLORREF getDisabledTextColor()       { return getTheme()._colors.disabledText; }
+	COLORREF getLinkTextColor()           { return getTheme()._colors.linkText; }
+	COLORREF getEdgeColor()               { return getTheme()._colors.edge; }
+	COLORREF getHotEdgeColor()            { return getTheme()._colors.hotEdge; }
+	COLORREF getDisabledEdgeColor()       { return getTheme()._colors.disabledEdge; }
+
+	HBRUSH getBackgroundBrush()           { return getTheme().getBrushes()._background; }
+	HBRUSH getCtrlBackgroundBrush()       { return getTheme().getBrushes()._ctrlBackground; }
+	HBRUSH getHotBackgroundBrush()        { return getTheme().getBrushes()._hotBackground; }
+	HBRUSH getDlgBackgroundBrush()        { return getTheme().getBrushes()._dlgBackground; }
+	HBRUSH getErrorBackgroundBrush()      { return getTheme().getBrushes()._errorBackground; }
+
+	HBRUSH getEdgeBrush()                 { return getTheme().getBrushes()._edge; }
+	HBRUSH getHotEdgeBrush()              { return getTheme().getBrushes()._hotEdge; }
+	HBRUSH getDisabledEdgeBrush()         { return getTheme().getBrushes()._disabledEdge; }
+
+	HPEN getDarkerTextPen()               { return getTheme().getPens()._darkerText; }
+	HPEN getEdgePen()                     { return getTheme().getPens()._edge; }
+	HPEN getHotEdgePen()                  { return getTheme().getPens()._hotEdge; }
+	HPEN getDisabledEdgePen()             { return getTheme().getPens()._disabledEdge; }
+
+	COLORREF setViewBackgroundColor(COLORREF clrNew)        { return DarkMode::setNewColor(&DarkMode::getThemeView()._clrView.background, clrNew); }
+	COLORREF setViewTextColor(COLORREF clrNew)              { return DarkMode::setNewColor(&DarkMode::getThemeView()._clrView.text, clrNew); }
+	COLORREF setViewGridlinesColor(COLORREF clrNew)         { return DarkMode::setNewColor(&DarkMode::getThemeView()._clrView.gridlines, clrNew); }
+
+	COLORREF setHeaderBackgroundColor(COLORREF clrNew)      { return DarkMode::setNewColor(&DarkMode::getThemeView()._clrView.headerBackground, clrNew); }
+	COLORREF setHeaderHotBackgroundColor(COLORREF clrNew)   { return DarkMode::setNewColor(&DarkMode::getThemeView()._clrView.headerHotBackground, clrNew); }
+	COLORREF setHeaderTextColor(COLORREF clrNew)            { return DarkMode::setNewColor(&DarkMode::getThemeView()._clrView.headerText, clrNew); }
+	COLORREF setHeaderEdgeColor(COLORREF clrNew)            { return DarkMode::setNewColor(&DarkMode::getThemeView()._clrView.headerEdge, clrNew); }
+
+	void setViewColors(ColorsView colors)
+	{
+		DarkMode::getThemeView().updateView(colors);
+	}
+
+	void updateViewBrushesAndPens()
+	{
+		DarkMode::getThemeView().updateView();
+	}
+
+	COLORREF getViewBackgroundColor()       { return DarkMode::getThemeView()._clrView.background; }
+	COLORREF getViewTextColor()             { return DarkMode::getThemeView()._clrView.text; }
+	COLORREF getViewGridlinesColor()        { return DarkMode::getThemeView()._clrView.gridlines; }
+
+	COLORREF getHeaderBackgroundColor()     { return DarkMode::getThemeView()._clrView.headerBackground; }
+	COLORREF getHeaderHotBackgroundColor()  { return DarkMode::getThemeView()._clrView.headerHotBackground; }
+	COLORREF getHeaderTextColor()           { return DarkMode::getThemeView()._clrView.headerText; }
+	COLORREF getHeaderEdgeColor()           { return DarkMode::getThemeView()._clrView.headerEdge; }
+
+	HBRUSH getViewBackgroundBrush()         { return DarkMode::getThemeView().getViewBrushesAndPens()._background; }
+	HBRUSH getViewGridlinesBrush()          { return DarkMode::getThemeView().getViewBrushesAndPens()._gridlines; }
+
+	HBRUSH getHeaderBackgroundBrush()       { return DarkMode::getThemeView().getViewBrushesAndPens()._headerBackground; }
+	HBRUSH getHeaderHotBackgroundBrush()    { return DarkMode::getThemeView().getViewBrushesAndPens()._headerHotBackground; }
+
+	HPEN getHeaderEdgePen()                 { return DarkMode::getThemeView().getViewBrushesAndPens()._headerEdge; }
+
+	/**
+	 * @brief Initializes default color set based on the current mode type.
+	 *
+	 * Sets up control and view colors depending on the active theme:
+	 * - `dark`: Applies dark tone color set and view dark color set.
+	 * - `light`: Applies the predefined light color set and view light color set.
+	 * - `classic`: Applies only system color on views, other controls are not affected
+	 *              by theme colors.
+	 *
+	 * If `updateBrushesAndOther` is `true`, also updates
+	 * brushes, pens, and view styles (unless in classic mode).
+	 *
+	 * @param updateBrushesAndOther Whether to refresh GDI brushes and pens, and tree view styling.
+	 *
+	 * @see DarkMode::setToneColors
+	 * @see DarkMode::updateThemeBrushesAndPens
+	 * @see DarkMode::calculateTreeViewStyle
+	 */
+	void setDefaultColors(bool updateBrushesAndOther)
+	{
+		switch (g_dmCfg._dmType)
+		{
+			case DarkModeType::dark:
+			{
+				DarkMode::getTheme().setToneColors();
+				DarkMode::getThemeView()._clrView = DarkMode::darkColorsView;
+				break;
+			}
+
+			case DarkModeType::light:
+			{
+				DarkMode::getTheme()._colors = DarkMode::getLightColors();
+				DarkMode::getThemeView()._clrView = DarkMode::lightColorsView;
+				break;
+			}
+
+			case DarkModeType::classic:
+			{
+				DarkMode::setViewBackgroundColor(::GetSysColor(COLOR_WINDOW));
+				DarkMode::setViewTextColor(::GetSysColor(COLOR_WINDOWTEXT));
+				break;
+			}
+		}
+
+		if (updateBrushesAndOther)
+		{
+			if (g_dmCfg._dmType != DarkModeType::classic)
+			{
+				DarkMode::updateThemeBrushesAndPens();
+				DarkMode::updateViewBrushesAndPens();
+			}
+
+			DarkMode::calculateTreeViewStyle();
+		}
+	}
+
+	/**
+	 * @brief Initializes the dark mode configuration based on the selected mode.
+	 *
+	 * Sets the active dark mode rendering and system-following behavior according to the specified `dmType`:
+	 * - `0`: Light mode, do not follow system.
+	 * - `1` or default: Dark mode, do not follow system.
+	 * - `2`: *[Internal]* Follow system — light or dark depending on registry (see `DarkMode::isDarkModeReg()`).
+	 * - `3`: Classic mode, do not follow system.
+	 * - `4`: *[Internal]* Follow system — classic or dark depending on registry.
+	 *
+	 * @param dmType Integer representing the desired mode.
+	 *
+	 * @see DarkModeType
+	 * @see WinMode
+	 * @see DarkMode::isDarkModeReg()
+	 */
+	void initDarkModeConfig(UINT dmType)
+	{
+		switch (dmType)
+		{
+			case 0:
+			{
+				g_dmCfg._dmType = DarkModeType::light;
+				g_dmCfg._windowsMode = WinMode::disabled;
+				break;
+			}
+
+			case 2:
+			{
+				g_dmCfg._dmType = DarkMode::isDarkModeReg() ? DarkModeType::dark : DarkModeType::light;
+				g_dmCfg._windowsMode = WinMode::light;
+				break;
+			}
+
+			case 3:
+			{
+				g_dmCfg._dmType = DarkModeType::classic;
+				g_dmCfg._windowsMode = WinMode::disabled;
+				break;
+			}
+
+			case 4:
+			{
+				g_dmCfg._dmType = DarkMode::isDarkModeReg() ? DarkModeType::dark : DarkModeType::classic;
+				g_dmCfg._windowsMode = WinMode::classic;
+				break;
+			}
+
+			case 1:
+			default:
+			{
+				g_dmCfg._dmType = DarkModeType::dark;
+				g_dmCfg._windowsMode = WinMode::disabled;
+				break;
+			}
+		}
+	}
+
+	/**
+	 * @brief Sets the preferred window corner style on Windows 11.
+	 *
+	 * Assigns a valid `DWM_WINDOW_CORNER_PREFERENCE` value to the config,
+	 * falling back to `DWMWCP_DEFAULT` if the input is out of range.
+	 *
+	 * @param roundCornerStyle Integer value representing a `DWM_WINDOW_CORNER_PREFERENCE`.
+	 *
+	 * @see https://learn.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwm_window_corner_preference
+	 * @see DarkMode::setDarkTitleBarEx()
+	 */
+	void setRoundCornerConfig(UINT roundCornerStyle)
+	{
+		const auto cornerStyle = static_cast<DWM_WINDOW_CORNER_PREFERENCE>(roundCornerStyle);
+		if (cornerStyle > DWMWCP_ROUNDSMALL) // || cornerStyle < DWMWCP_DEFAULT) // should never be < 0
+		{
+			g_dmCfg._roundCorner = DWMWCP_DEFAULT;
+		}
+		else
+		{
+			g_dmCfg._roundCorner = cornerStyle;
+		}
+	}
+
+	static constexpr DWORD kDwmwaClrDefaultRGBCheck = 0x00FFFFFF;
+
+	/**
+	 * @brief Sets the preferred border color for window edge on Windows 11.
+	 *
+	 * Assigns the given `COLORREF` to the configuration. If the value matches
+	 * `kDwmwaClrDefaultRGBCheck`, the color is reset to `DWMWA_COLOR_DEFAULT`.
+	 *
+	 * @param clr Border color value, or sentinel to reset to system default.
+	 *
+	 * @see DWMWA_BORDER_COLOR
+	 * @see DarkMode::setDarkTitleBarEx()
+	 */
+	void setBorderColorConfig(COLORREF clr)
+	{
+		if (clr == kDwmwaClrDefaultRGBCheck)
+		{
+			g_dmCfg._borderColor = DWMWA_COLOR_DEFAULT;
+		}
+		else
+		{
+			g_dmCfg._borderColor = clr;
+		}
+	}
+
+	/**
+	 * @brief Sets the Mica effects on Windows 11 setting.
+	 *
+	 * Assigns a valid `DWM_SYSTEMBACKDROP_TYPE` to the configuration. If the value exceeds
+	 * `DWMSBT_TABBEDWINDOW`, it falls back to `DWMSBT_AUTO`.
+	 *
+	 * @param mica Integer value representing a `DWM_SYSTEMBACKDROP_TYPE`.
+	 *
+	 * @see DWM_SYSTEMBACKDROP_TYPE
+	 * @see DarkMode::setDarkTitleBarEx()
+	 */
+	void setMicaConfig(UINT mica)
+	{
+		const auto micaType = static_cast<DWM_SYSTEMBACKDROP_TYPE>(mica);
+		if (micaType > DWMSBT_TABBEDWINDOW) // || micaType < DWMSBT_AUTO)  // should never be < 0
+		{
+			g_dmCfg._mica = DWMSBT_AUTO;
+		}
+		else
+		{
+			g_dmCfg._mica = micaType;
+		}
+	}
+
+	/**
+	 * @brief Sets Mica effects on the full window setting.
+	 *
+	 * Controls whether Mica should be applied to the entire window
+	 * or limited to the title bar only.
+	 *
+	 * @param extendMica `true` to apply Mica to the full window, `false` for title bar only.
+	 *
+	 * @see DarkMode::setDarkTitleBarEx()
+	 */
+	void setMicaExtendedConfig(bool extendMica)
+	{
+		g_dmCfg._micaExtend = extendMica;
+	}
+
+	/**
+	 * @brief Sets dialog colors on title bar on Windows 11 setting.
+	 *
+	 * Controls whether title bar should have same colors as dialog window.
+	 *
+	 * @param colorize `true` to have title bar to have same colors as dialog window.
+	 *
+	 * @see DarkMode::setDarkTitleBarEx()
+	 */
+	void setColorizeTitleBarConfig(bool colorize)
+	{
+		g_dmCfg._colorizeTitleBar = colorize;
+	}
+
+	/**
+	 * @brief Initializes undocumented dark mode API.
+	 *
+	 * Wraps `InitDarkMode()` from DarkMode.h.
+	 */
+	static void initExperimentalDarkMode()
+	{
+		::InitDarkMode();
+	}
+
+	/**
+	 * @brief Enables or disables dark mode using undocumented API.
+	 *
+	 * Optionally applies a scrollbar fix for dark mode inconsistencies.
+	 *
+	 * @param useDark Enable dark mode when `true`, disable when `false`.
+	 * @param fixDarkScrollbar Apply scrollbar fix if `true`.
+	 */
+	static void setDarkMode(bool useDark, bool fixDarkScrollbar = true)
+	{
+		::SetDarkMode(useDark, fixDarkScrollbar);
+	}
+
+	/**
+	 * @brief Enables or disables dark mode support for a specific window.
+	 *
+	 * @param hWnd Window handle to apply dark mode.
+	 * @param allow Whether to allow (`true`) or disallow (`false`) dark mode.
+	 * @return `true` if successfully applied.
+	 */
+	static bool allowDarkModeForWindow(HWND hWnd, bool allow)
+	{
+		return ::AllowDarkModeForWindow(hWnd, allow);
+	}
+
+#if defined(_DARKMODELIB_ALLOW_OLD_OS) && (_DARKMODELIB_ALLOW_OLD_OS > 0)
+	/**
+	 * @brief Refreshes the title bar theme color for legacy systems.
+	 *
+	 * Used only on old Windows 10 systems when `_DARKMODELIB_ALLOW_OLD_OS`
+	 * is defined with non-zero unsigned value.
+	 *
+	 * @param hWnd Handle to the window to update.
+	 */
+	static void setTitleBarThemeColor(HWND hWnd)
+	{
+		::RefreshTitleBarThemeColor(hWnd);
+	}
+#endif
+
+	/**
+	 * @brief Checks whether a `WM_SETTINGCHANGE` message indicates a color scheme switch.
+	 *
+	 * @param lParam LPARAM from a system message.
+	 * @return `true` if the message signals a theme mode change.
+	 */
+	[[nodiscard]] static bool isColorSchemeChangeMessage(LPARAM lParam)
+	{
+		return ::IsColorSchemeChangeMessage(lParam);
+	}
+
+	/**
+	 * @brief Determines if high contrast mode is currently active.
+	 *
+	 * @return `true` if high contrast is enabled via system accessibility settings.
+	 */
+	static bool isHighContrast()
+	{
+		return ::IsHighContrast();
+	}
+
+	/**
+	 * @brief Determines if themed styling should be preferred over subclassing.
+	 *
+	 * Requires support for experimental theming and Windows 10 or later.
+	 *
+	 * @return `true` if themed appearance is preferred and supported.
+	 */
+	static bool isThemePrefered()
+	{
+		return (DarkMode::getLibInfo(LibInfo::preferTheme) == TRUE)
+			&& DarkMode::isAtLeastWindows10()
+			&& DarkMode::isExperimentalSupported();
+	}
+
+#if !defined(_DARKMODELIB_NO_INI_CONFIG)
+	 /**
+	  * @brief Initializes dark mode configuration and colors from an INI file.
+	  *
+	  * Loads configuration values from the specified INI file path and applies them to the
+	  * current dark mode settings. This includes:
+	  * - Base appearance (`DarkModeType`) and system-following mode (`WinMode`)
+	  * - Optional Mica and rounded corner styling
+	  * - Custom colors for background, text, borders, and headers (if present)
+	  * - Tone settings for dark theme (`ColorTone`)
+	  *
+	  * If the INI file does not exist, default dark mode behavior is applied via
+	  * @ref DarkMode::setDarkModeConfig.
+	  *
+	  * @param iniName Name of INI file (resolved via @ref GetIniPath).
+	  *
+	  * @note When `DarkModeType::classic` is set, system colors are used instead of themed ones.
+	  */
+	static void initOptions(const std::wstring& iniName)
+	{
+		if (iniName.empty())
+		{
+			return;
+		}
+
+		const std::wstring iniPath = GetIniPath(iniName);
+		if (FileExists(iniPath))
+		{
+			DarkMode::initDarkModeConfig(::GetPrivateProfileIntW(L"main", L"mode", 1, iniPath.c_str()));
+			if (g_dmCfg._dmType == DarkModeType::classic)
+			{
+				DarkMode::setDarkModeConfig(static_cast<UINT>(DarkModeType::classic));
+				DarkMode::setDefaultColors(false);
+				return;
+			}
+
+			const bool useDark = g_dmCfg._dmType == DarkModeType::dark;
+
+			const std::wstring sectionBase = useDark ? L"dark" : L"light";
+			const std::wstring sectionColorsView = sectionBase + L".colors.view";
+			const std::wstring sectionColors = sectionBase + L".colors";
+
+			DarkMode::setMicaConfig(::GetPrivateProfileIntW(sectionBase.c_str(), L"mica", 0, iniPath.c_str()));
+			DarkMode::setRoundCornerConfig(::GetPrivateProfileIntW(sectionBase.c_str(), L"roundCorner", 0, iniPath.c_str()));
+			SetClrFromIni(sectionBase, L"borderColor", iniPath, &g_dmCfg._borderColor);
+			if (g_dmCfg._borderColor == kDwmwaClrDefaultRGBCheck)
+			{
+				g_dmCfg._borderColor = DWMWA_COLOR_DEFAULT;
+			}
+
+			if (useDark)
+			{
+				UINT tone = ::GetPrivateProfileIntW(sectionBase.c_str(), L"tone", 0, iniPath.c_str());
+				if (tone >= static_cast<UINT>(ColorTone::max))
+				{
+					tone = 0;
+				}
+
+				DarkMode::getTheme().setToneColors(static_cast<ColorTone>(tone));
+				DarkMode::getThemeView()._clrView = DarkMode::darkColorsView;
+				DarkMode::getThemeView()._clrView.headerBackground = DarkMode::getTheme()._colors.background;
+				DarkMode::getThemeView()._clrView.headerHotBackground = DarkMode::getTheme()._colors.hotBackground;
+				DarkMode::getThemeView()._clrView.headerText = DarkMode::getTheme()._colors.darkerText;
+
+				if (!DarkMode::isWindowsModeEnabled())
+				{
+					g_dmCfg._micaExtend = (::GetPrivateProfileIntW(sectionBase.c_str(), L"micaExtend", 0, iniPath.c_str()) == 1);
+				}
+			}
+			else
+			{
+				DarkMode::getTheme()._colors = DarkMode::getLightColors();
+				DarkMode::getThemeView()._clrView = DarkMode::lightColorsView;
+			}
+
+			SetClrFromIni(sectionColorsView, L"backgroundView", iniPath, &DarkMode::getThemeView()._clrView.background);
+			SetClrFromIni(sectionColorsView, L"textView", iniPath, &DarkMode::getThemeView()._clrView.text);
+			SetClrFromIni(sectionColorsView, L"gridlines", iniPath, &DarkMode::getThemeView()._clrView.gridlines);
+			SetClrFromIni(sectionColorsView, L"backgroundHeader", iniPath, &DarkMode::getThemeView()._clrView.headerBackground);
+			SetClrFromIni(sectionColorsView, L"backgroundHotHeader", iniPath, &DarkMode::getThemeView()._clrView.headerHotBackground);
+			SetClrFromIni(sectionColorsView, L"textHeader", iniPath, &DarkMode::getThemeView()._clrView.headerText);
+			SetClrFromIni(sectionColorsView, L"edgeHeader", iniPath, &DarkMode::getThemeView()._clrView.headerEdge);
+
+			SetClrFromIni(sectionColors, L"background", iniPath, &DarkMode::getTheme()._colors.background);
+			SetClrFromIni(sectionColors, L"backgroundCtrl", iniPath, &DarkMode::getTheme()._colors.ctrlBackground);
+			SetClrFromIni(sectionColors, L"backgroundHot", iniPath, &DarkMode::getTheme()._colors.hotBackground);
+			SetClrFromIni(sectionColors, L"backgroundDlg", iniPath, &DarkMode::getTheme()._colors.dlgBackground);
+			SetClrFromIni(sectionColors, L"backgroundError", iniPath, &DarkMode::getTheme()._colors.errorBackground);
+
+			SetClrFromIni(sectionColors, L"text", iniPath, &DarkMode::getTheme()._colors.text);
+			SetClrFromIni(sectionColors, L"textItem", iniPath, &DarkMode::getTheme()._colors.darkerText);
+			SetClrFromIni(sectionColors, L"textDisabled", iniPath, &DarkMode::getTheme()._colors.disabledText);
+			SetClrFromIni(sectionColors, L"textLink", iniPath, &DarkMode::getTheme()._colors.linkText);
+
+			SetClrFromIni(sectionColors, L"edge", iniPath, &DarkMode::getTheme()._colors.edge);
+			SetClrFromIni(sectionColors, L"edgeHot", iniPath, &DarkMode::getTheme()._colors.hotEdge);
+			SetClrFromIni(sectionColors, L"edgeDisabled", iniPath, &DarkMode::getTheme()._colors.disabledEdge);
+
+			DarkMode::updateThemeBrushesAndPens();
+			DarkMode::updateViewBrushesAndPens();
+			DarkMode::calculateTreeViewStyle();
+
+			if (!g_dmCfg._micaExtend)
+			{
+				g_dmCfg._colorizeTitleBar = (::GetPrivateProfileIntW(sectionBase.c_str(), L"colorizeTitleBar", 0, iniPath.c_str()) == 1);
+			}
+
+			DarkMode::setDarkMode(g_dmCfg._dmType == DarkModeType::dark, true);
+		}
+		else
+		{
+			DarkMode::setDarkModeConfig(static_cast<UINT>(DarkModeType::dark));
+			DarkMode::setDefaultColors(true);
+		}
+	}
+#endif // !defined(_DARKMODELIB_NO_INI_CONFIG)
+
+	/**
+	 * @brief Applies dark mode settings based on the given configuration type.
+	 *
+	 * Initializes the dark mode type settings and system-following behavior.
+	 * Enables or disables dark mode depending on whether `DarkModeType::dark` is selected.
+	 * It is recommended to use together with @ref DarkMode::setDefaultColors to also set colors.
+	 *
+	 * @param dmType Dark mode configuration type; see @ref DarkMode::initDarkModeConfig for values.
+	 *
+	 * @see DarkMode::initDarkModeConfig()
+	 * @see DarkMode::setDefaultColors()
+	 */
+	void setDarkModeConfig(UINT dmType)
+	{
+		DarkMode::initDarkModeConfig(dmType);
+
+		const bool useDark = g_dmCfg._dmType == DarkModeType::dark;
+		DarkMode::setDarkMode(useDark, true);
+	}
+
+	/**
+	 * @brief Applies dark mode settings based on system mode preference.
+	 *
+	 * Determines the appropriate mode using @ref DarkMode::isDarkModeReg and forwards
+	 * the result to @ref DarkMode::setDarkModeConfig.
+	 * It is recommended to use together with @ref DarkMode::setDefaultColors to also set colors.
+	 *
+	 * Uses:
+	 * - `DarkModeType::dark` if registry prefers dark mode.
+	 * - `DarkModeType::classic` otherwise.
+	 *
+	 * @see DarkMode::setDefaultColors()
+	 */
+	void setDarkModeConfig()
+	{
+		const auto dmType = static_cast<UINT>(DarkMode::isDarkModeReg() ? DarkModeType::dark : DarkModeType::classic);
+		DarkMode::setDarkModeConfig(dmType);
+	}
+
+	/**
+	 * @brief Initializes dark mode experimental features, colors, and other settings.
+	 *
+	 * Performs one-time setup for dark mode, including:
+	 * - Initializing experimental features if not yet done.
+	 * - Optionally loading settings from an INI file (if INI config is enabled).
+	 * - Initializing TreeView style and applying dark mode settings.
+	 * - Preparing system colors (e.g. `COLOR_WINDOW`, `COLOR_WINDOWTEXT`, `COLOR_BTNFACE`)
+	 *   for hooking.
+	 *
+	 * @param iniName Optional path to an INI file for dark mode settings (ignored if already set).
+	 *
+	 * @note This function is only run once per session;
+	 *       subsequent calls have no effect, unless follow system mode is used,
+	 *       then only colors are updated each time system changes mode.
+	 *
+	 * @see DarkMode::calculateTreeViewStyle()
+	 */
+	void initDarkMode([[maybe_unused]] const wchar_t* iniName)
+	{
+		if (!g_dmCfg._isInit)
+		{
+			if (!g_dmCfg._isInitExperimental)
+			{
+				DarkMode::initExperimentalDarkMode();
+				g_dmCfg._isInitExperimental = true;
+			}
+
+#if !defined(_DARKMODELIB_NO_INI_CONFIG)
+			if (!g_dmCfg._isIniNameSet)
+			{
+				g_dmCfg._iniName = iniName;
+				g_dmCfg._isIniNameSet = true;
+
+				if (g_dmCfg._iniName.empty())
+				{
+					DarkMode::setDarkModeConfig(static_cast<UINT>(DarkModeType::dark));
+					DarkMode::setDefaultColors(true);
+				}
+			}
+			DarkMode::initOptions(g_dmCfg._iniName);
+#else
+			DarkMode::setDarkModeConfig();
+			DarkMode::setDefaultColors(true);
+#endif
+
+			DarkMode::setSysColor(COLOR_WINDOW, DarkMode::getBackgroundColor());
+			DarkMode::setSysColor(COLOR_WINDOWTEXT, DarkMode::getTextColor());
+			DarkMode::setSysColor(COLOR_BTNFACE, DarkMode::getViewGridlinesColor());
+
+			g_dmCfg._isInit = true;
+		}
+	}
+
+	/**
+	 * @brief Initializes dark mode without INI settings.
+	 *
+	 * Forwards to @ref DarkMode::initDarkMode with an empty INI path, effectively disabling INI settings.
+	 */
+	void initDarkMode()
+	{
+		DarkMode::initDarkMode(L"");
+	}
+
+	/**
+	 * @brief Checks if non-classic mode is enabled.
+	 *
+	 * If `_DARKMODELIB_ALLOW_OLD_OS` is defined with value larger than '1',
+	 * this skips Windows version checks. Otherwise, dark mode is only enabled
+	 * on Windows 10 or newer.
+	 *
+	 * @return `true` if a supported dark mode type is active, otherwise `false`.
+	 */
+	bool isEnabled()
+	{
+#if defined(_DARKMODELIB_ALLOW_OLD_OS) && (_DARKMODELIB_ALLOW_OLD_OS > 1)
+		return g_dmCfg._dmType != DarkModeType::classic;
+#else
+		return DarkMode::isAtLeastWindows10() && g_dmCfg._dmType != DarkModeType::classic;
+#endif
+	}
+
+	/**
+	 * @brief Checks if experimental dark mode features are currently active.
+	 *
+	 * @return `true` if experimental dark mode is enabled.
+	 */
+	bool isExperimentalActive()
+	{
+		return g_darkModeEnabled;
+	}
+
+	/**
+	 * @brief Checks if experimental dark mode features are supported by the system.
+	 *
+	 * @return `true` if dark mode experimental APIs are available.
+	 */
+	bool isExperimentalSupported()
+	{
+		return g_darkModeSupported;
+	}
+
+	/**
+	 * @brief Checks if follow the system mode behavior is enabled.
+	 *
+	 * @return `true` if "mode" is not `WinMode::disabled`, i.e. system mode is followed.
+	 */
+	bool isWindowsModeEnabled()
+	{
+		return g_dmCfg._windowsMode != WinMode::disabled;
+	}
+
+	/**
+	 * @brief Checks if the host OS is at least Windows 10.
+	 *
+	 * @return `true` if running on Windows 10 or newer.
+	 */
+	bool isAtLeastWindows10()
+	{
+		return ::IsWindows10();
+	}
+	/**
+	 * @brief Checks if the host OS is at least Windows 11.
+	 *
+	 * @return `true` if running on Windows 11 or newer.
+	 */
+	bool isAtLeastWindows11()
+	{
+		return ::IsWindows11();
+	}
+
+	/**
+	 * @brief Retrieves the current Windows build number.
+	 *
+	 * @return Windows build number reported by the system.
+	 */
+	DWORD getWindowsBuildNumber()
+	{
+		return GetWindowsBuildNumber();
+	}
+
+	/**
+	 * @brief Handles system setting changes related to dark mode.
+	 *
+	 * Responds to system messages indicating a color scheme change. If the current
+	 * dark mode state no longer matches the system registry preference, dark mode is
+	 * re-initialized.
+	 *
+	 * - Skips processing if experimental dark mode is unsupported.
+	 * - Relies on @ref DarkMode::isDarkModeReg for theme preference and skips during high contrast.
+	 *
+	 * @param lParam Message parameter (typically from `WM_SETTINGCHANGE`).
+	 * @return `true` if a dark mode change was handled; otherwise `false`.
+	 *
+	 * @see DarkMode::isDarkModeReg()
+	 * @see DarkMode::initDarkMode()
+	 */
+	bool handleSettingChange(LPARAM lParam)
+	{
+		if (DarkMode::isExperimentalSupported() && DarkMode::isColorSchemeChangeMessage(lParam))
+		{
+			// ShouldAppsUseDarkMode() is not reliable from 1903+, use DarkMode::isDarkModeReg() instead
+			const bool isDarkModeUsed = DarkMode::isDarkModeReg() && !DarkMode::isHighContrast();
+			if (DarkMode::isExperimentalActive() != isDarkModeUsed)
+			{
+				if (g_dmCfg._isInit)
+				{
+					g_dmCfg._isInit = false;
+					DarkMode::initDarkMode();
+				}
+			}
+			return true;
+		}
+		return false;
+	}
+
+	/**
+	 * @brief Checks if dark mode is enabled in the Windows registry.
+	 *
+	 * Queries `HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize\\AppsUseLightTheme`.
+	 *
+	 * @return `true` if dark mode is preferred (value is `0`); otherwise `false`.
+	 */
+	bool isDarkModeReg()
+	{
+		DWORD data{};
+		DWORD dwBufSize = sizeof(data);
+		LPCWSTR lpSubKey = L"Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize";
+		LPCWSTR lpValue = L"AppsUseLightTheme";
+
+		const auto result = ::RegGetValueW(HKEY_CURRENT_USER, lpSubKey, lpValue, RRF_RT_REG_DWORD, nullptr, &data, &dwBufSize);
+		if (result != ERROR_SUCCESS)
+		{
+			return false;
+		}
+
+		// dark mode is 0, light mode is 1
+		return data == 0UL;
+	}
+
+	// from DarkMode.h
+
+	/**
+	 * @brief Overrides a specific system color with a custom color.
+	 *
+	 * Currently supports:
+	 * - `COLOR_WINDOW`: Background of ComboBoxEx list.
+	 * - `COLOR_WINDOWTEXT`: Text color of ComboBoxEx list.
+	 * - `COLOR_BTNFACE`: Gridline color in ListView (when applicable).
+	 *
+	 * @param nIndex One of the supported system color indices.
+	 * @param color Custom `COLORREF` value to apply.
+	 */
+	void setSysColor(int nIndex, COLORREF color)
+	{
+		::SetMySysColor(nIndex, color);
+	}
+
+	/**
+	 * @brief Hooks system color to support runtime customization.
+	 *
+	 * @return `true` if the hook was installed successfully.
+	 */
+	static bool hookSysColor()
+	{
+		return ::HookSysColor();
+	}
+
+	/**
+	 * @brief Unhooks system color overrides and restores default color behavior.
+	 *
+	 * This function is safe to call even if no color hook is currently installed.
+	 * It ensures that system colors return to normal without requiring
+	 * prior state checks.
+	 */
+	static void unhookSysColor()
+	{
+		::UnhookSysColor();
+	}
+
+	/**
+	 * @brief Makes scroll bars on the specified window and all its children consistent.
+	 *
+	 * Currently not widely used by default.
+	 *
+	 * @param hWnd Handle to the parent window.
+	 */
+	void enableDarkScrollBarForWindowAndChildren([[maybe_unused]] HWND hWnd)
+	{
+#if defined(_DARKMODELIB_USE_SCROLLBAR_FIX) && (_DARKMODELIB_USE_SCROLLBAR_FIX > 0)
+		::EnableDarkScrollBarForWindowAndChildren(hWnd);
+#endif
+	}
+
+	/**
+	 * @brief Paints a rounded rectangle using the specified pen and brush.
+	 *
+	 * Draws a rounded rectangle defined by `rect`, using the provided pen (`hpen`) and brush (`hBrush`)
+	 * for the edge and fill, respectively. Preserves previous GDI object selections.
+	 *
+	 * @param hdc Handle to the device context.
+	 * @param rect Rectangle bounds for the shape.
+	 * @param hpen Pen used to draw the edge.
+	 * @param hBrush Brush used to inner fill.
+	 * @param width Horizontal corner radius.
+	 * @param height Vertical corner radius.
+	 */
+	void paintRoundRect(HDC hdc, const RECT& rect, HPEN hpen, HBRUSH hBrush, int width, int height)
+	{
+		auto holdBrush = ::SelectObject(hdc, hBrush);
+		auto holdPen = ::SelectObject(hdc, hpen);
+		::RoundRect(hdc, rect.left, rect.top, rect.right, rect.bottom, width, height);
+		::SelectObject(hdc, holdBrush);
+		::SelectObject(hdc, holdPen);
+	}
+
+	/**
+	 * @brief Paints an unfilled rounded rectangle (frame only).
+	 *
+	 * Uses a `NULL_BRUSH` to omit the inner fill, drawing only the rounded frame.
+	 *
+	 * @param hdc Handle to the device context.
+	 * @param rect Rectangle bounds for the frame.
+	 * @param hpen Pen used to draw the edge.
+	 * @param width Horizontal corner radius.
+	 * @param height Vertical corner radius.
+	 */
+	void paintRoundFrameRect(HDC hdc, const RECT& rect, HPEN hpen, int width, int height)
+	{
+		DarkMode::paintRoundRect(hdc, rect, hpen, static_cast<HBRUSH>(::GetStockObject(NULL_BRUSH)), width, height);
+	}
+
+	/**
+	 * @class ThemeData
+	 * @brief RAII-style wrapper for `HTHEME` handle tied to a specific theme class.
+	 *
+	 * Prevents leaks by managing the lifecycle of a theme handle opened via `OpenThemeData()`.
+	 * Ensures handles are released properly in the destructor via `CloseThemeData()`.
+	 *
+	 * Usage:
+	 * - Construct with a valid theme class name (e.g. `L"Button"`).
+	 * - Call `ensureTheme(HWND)` before drawing to open the theme handle.
+	 * - Access the active handle via `getHTheme()`.
+	 *
+	 * Copying and moving are explicitly disabled to preserve exclusive ownership.
+	 */
+	class ThemeData
+	{
+	public:
+		ThemeData() = delete;
+
+		explicit ThemeData(const wchar_t* themeClass)
+			: _themeClass(themeClass)
+		{}
+
+		ThemeData(const ThemeData&) = delete;
+		ThemeData& operator=(const ThemeData&) = delete;
+
+		ThemeData(ThemeData&&) = delete;
+		ThemeData& operator=(ThemeData&&) = delete;
+
+		~ThemeData()
+		{
+			closeTheme();
+		}
+
+		bool ensureTheme(HWND hWnd)
+		{
+			if (_hTheme == nullptr && _themeClass != nullptr)
+			{
+				_hTheme = ::OpenThemeData(hWnd, _themeClass);
+			}
+			return _hTheme != nullptr;
+		}
+
+		void closeTheme() noexcept
+		{
+			if (_hTheme != nullptr)
+			{
+				::CloseThemeData(_hTheme);
+				_hTheme = nullptr;
+			}
+		}
+
+		[[nodiscard]] const HTHEME& getHTheme() const
+		{
+			return _hTheme;
+		}
+
+	private:
+		const wchar_t* _themeClass = nullptr;
+		HTHEME _hTheme = nullptr;
+	};
+
+	/**
+	 * @class BufferData
+	 * @brief RAII-style utility for double buffer technique.
+	 *
+	 * Allocates and resizes an offscreen buffer for flicker-free GDI drawing. When
+	 * `ensureBuffer()` is called with a target HDC and client rect, it creates or resizes
+	 * a memory device context and bitmap accordingly. Automatically releases resources
+	 * via `releaseBuffer()` and destructor.
+	 *
+	 * Usage:
+	 * - Call `ensureBuffer()` before painting.
+	 * - Draw to `getHMemDC()`.
+	 * - BitBlt back to screen in WM_PAINT.
+	 *
+	 * Copying and moving are explicitly disabled to preserve exclusive ownership.
+	 */
+	class BufferData
+	{
+	public:
+		BufferData() = default;
+
+		BufferData(const BufferData&) = delete;
+		BufferData& operator=(const BufferData&) = delete;
+
+		BufferData(BufferData&&) = delete;
+		BufferData& operator=(BufferData&&) = delete;
+
+		~BufferData()
+		{
+			releaseBuffer();
+		}
+
+		bool ensureBuffer(HDC hdc, const RECT& rcClient)
+		{
+			const int width = rcClient.right - rcClient.left;
+			const int height = rcClient.bottom - rcClient.top;
+
+			if (_szBuffer.cx != width || _szBuffer.cy != height)
+			{
+				releaseBuffer();
+				_hMemDC = ::CreateCompatibleDC(hdc);
+				_hMemBmp = ::CreateCompatibleBitmap(hdc, width, height);
+				_holdBmp = static_cast<HBITMAP>(::SelectObject(_hMemDC, _hMemBmp));
+				_szBuffer = { width, height };
+			}
+
+			return _hMemDC != nullptr && _hMemBmp != nullptr;
+		}
+
+		void releaseBuffer() noexcept
+		{
+			if (_hMemDC != nullptr)
+			{
+				::SelectObject(_hMemDC, _holdBmp);
+				::DeleteObject(_hMemBmp);
+				::DeleteDC(_hMemDC);
+
+				_hMemDC = nullptr;
+				_hMemBmp = nullptr;
+				_holdBmp = nullptr;
+				_szBuffer = { 0, 0 };
+			}
+		}
+
+		[[nodiscard]] const HDC& getHMemDC() const
+		{
+			return _hMemDC;
+		}
+
+	private:
+		HDC _hMemDC = nullptr;
+		HBITMAP _hMemBmp = nullptr;
+		HBITMAP _holdBmp = nullptr;
+		SIZE _szBuffer{};
+	};
+
+	/**
+	 * @class FontData
+	 * @brief RAII-style wrapper for managing a GDI font (`HFONT`) resource.
+	 *
+	 * Ensures safe creation, assignment, and destruction of fonts in GDI-based UI code.
+	 * Automatically deletes the font in the destructor or when replaced via `setFont()`.
+	 *
+	 * Usage:
+	 * - Use `setFont()` to assign a new font, deleting any previous one.
+	 * - `getFont()` provides access to the current `HFONT`.
+	 * - `hasFont()` checks if a valid font is currently held.
+	 *
+	 * Copying and moving are explicitly disabled to preserve exclusive ownership.
+	 */
+	class FontData
+	{
+	public:
+		FontData() = default;
+
+		explicit FontData(HFONT hFont) noexcept
+			: _hFont(hFont)
+		{}
+
+		FontData(const FontData&) = delete;
+		FontData& operator=(const FontData&) = delete;
+
+		FontData(FontData&&) = delete;
+		FontData& operator=(FontData&&) = delete;
+
+		~FontData()
+		{
+			FontData::destroyFont();
+		}
+
+		void setFont(HFONT newFont) noexcept
+		{
+			FontData::destroyFont();
+			_hFont = newFont;
+		}
+
+		[[nodiscard]] const HFONT& getFont() const noexcept
+		{
+			return _hFont;
+		}
+
+		[[nodiscard]] bool hasFont() const noexcept
+		{
+			return _hFont != nullptr;
+		}
+
+		void destroyFont() noexcept
+		{
+			if (FontData::hasFont())
+			{
+				::DeleteObject(_hFont);
+				_hFont = nullptr;
+			}
+		}
+
+	private:
+		HFONT _hFont = nullptr;
+	};
+
+	/**
+	 * @brief Attaches a typed subclass procedure with custom data to a window.
+	 *
+	 * If the subclass ID is not already attached, allocates a `T` instance using the given
+	 * `param` and stores it as subclass reference data. Ownership is transferred to the system.
+	 *
+	 * @tparam T The user-defined data type associated with the subclass.
+	 * @tparam Param Type used to initialize `T`.
+	 * @param hWnd Target window.
+	 * @param subclassProc Subclass procedure.
+	 * @param subclassID Identifier for the subclass instance.
+	 * @param param Constructor argument forwarded to `T`.
+	 * @return TRUE on success, FALSE on failure, -1 if subclass already set.
+	 */
+	template <typename T, typename Param>
+	static auto setSubclass(HWND hWnd, SUBCLASSPROC subclassProc, UINT_PTR subclassID, const Param& param) -> int
+	{
+		if (::GetWindowSubclass(hWnd, subclassProc, subclassID, nullptr) == FALSE)
+		{
+			auto pData = std::make_unique<T>(param);
+			if (::SetWindowSubclass(hWnd, subclassProc, subclassID, reinterpret_cast<DWORD_PTR>(pData.get())) == TRUE)
+			{
+				pData.release();
+				return TRUE;
+			}
+			return FALSE;
+		}
+		return -1;
+	}
+
+	/**
+	 * @brief Attaches a typed subclass procedure with default-constructed data.
+	 *
+	 * Same logic as the other overload, but constructs `T` using its default constructor.
+	 *
+	 * @tparam T The user-defined data type associated with the subclass.
+	 * @param hWnd Target window.
+	 * @param subclassProc Subclass procedure.
+	 * @param subclassID Identifier for the subclass instance.
+	 * @return TRUE on success, FALSE on failure, -1 if already subclassed.
+	 */
+	template <typename T>
+	static auto setSubclass(HWND hWnd, SUBCLASSPROC subclassProc, UINT_PTR subclassID) -> int
+	{
+		if (::GetWindowSubclass(hWnd, subclassProc, subclassID, nullptr) == FALSE)
+		{
+			auto pData = std::make_unique<T>();
+			if (::SetWindowSubclass(hWnd, subclassProc, subclassID, reinterpret_cast<DWORD_PTR>(pData.get())) == TRUE)
+			{
+				pData.release();
+				return TRUE;
+			}
+			return FALSE;
+		}
+		return -1;
+	}
+
+	/**
+	 * @brief Attaches an untyped subclass (no reference data).
+	 *
+	 * Sets a subclass with no associated custom data.
+	 *
+	 * @param hWnd Target window.
+	 * @param subclassProc Subclass procedure.
+	 * @param subclassID Identifier for the subclass instance.
+	 * @return TRUE on success, FALSE on failure, -1 if already subclassed.
+	 */
+	static int setSubclass(HWND hWnd, SUBCLASSPROC subclassProc, UINT_PTR subclassID)
+	{
+		if (::GetWindowSubclass(hWnd, subclassProc, subclassID, nullptr) == FALSE)
+		{
+			return ::SetWindowSubclass(hWnd, subclassProc, subclassID, 0);
+		}
+		return -1;
+	}
+
+	/**
+	 * @brief Removes a subclass and deletes associated user data (if provided).
+	 *
+	 * Retrieves and deletes user-defined `T` data stored in subclass reference
+	 * (unless `T = void`, in which case no delete is performed). Then removes the subclass.
+	 *
+	 * @tparam T Optional type of reference data to delete.
+	 * @param hWnd Window handle.
+	 * @param subclassProc Subclass procedure.
+	 * @param subclassID Identifier for the subclass instance.
+	 * @return TRUE on success, FALSE on failure, -1 if not present.
+	 */
+	template <typename T = void>
+	static auto removeSubclass(HWND hWnd, SUBCLASSPROC subclassProc, UINT_PTR subclassID) -> int
+	{
+		T* pData = nullptr;
+
+		if (::GetWindowSubclass(hWnd, subclassProc, subclassID, reinterpret_cast<DWORD_PTR*>(&pData)) == TRUE)
+		{
+			if constexpr (!std::is_void_v<T>)
+			{
+				if (pData != nullptr)
+				{
+					delete pData;
+					pData = nullptr;
+				}
+			}
+			return ::RemoveWindowSubclass(hWnd, subclassProc, subclassID);
+		}
+		return -1;
+	}
+
+	/**
+	 * @struct ButtonData
+	 * @brief Stores button theming state and original size metadata.
+	 *
+	 * Used for checkbox, radio, tri-state, or group box buttons. Used in conjunction
+	 * with subclassing of button controls to preserve original layout dimensions
+	 * and apply consistent visual styling. Captures the control's client size
+	 * for checkbox, radio, or tri-state buttons.
+	 *
+	 * Members:
+	 * - `_themeData` : RAII-managed theme handle for `VSCLASS_BUTTON`.
+	 * - `_szBtn` : Original size extracted from the button rectangle.
+	 * - `_iStateID` : Current visual state ID (e.g. pressed, disabled, ...).
+	 * - `_isSizeSet` : Indicates whether `_szBtn` holds a valid measurement.
+	 *
+	 * Constructor behavior:
+	 * - When constructed with an `HWND`, attempts to extract the initial size if the button
+	 *   is a checkbox/radio/tri-state type without `BS_MULTILINE`.
+	 */
+	struct ButtonData
+	{
+		ThemeData _themeData{ VSCLASS_BUTTON };
+		SIZE _szBtn{};
+
+		int _iStateID = 0;
+		bool _isSizeSet = false;
+
+		ButtonData() = default;
+
+		// Saves width and height from the resource file for use as restrictions.
+		// Currently unused / have no effect.
+		explicit ButtonData(HWND hWnd)
+		{
+			const auto nBtnStyle = ::GetWindowLongPtr(hWnd, GWL_STYLE);
+			switch (nBtnStyle & BS_TYPEMASK)
+			{
+				case BS_CHECKBOX:
+				case BS_AUTOCHECKBOX:
+				case BS_3STATE:
+				case BS_AUTO3STATE:
+				case BS_RADIOBUTTON:
+				case BS_AUTORADIOBUTTON:
+				{
+					if ((nBtnStyle & BS_MULTILINE) != BS_MULTILINE)
+					{
+						RECT rcBtn{};
+						::GetClientRect(hWnd, &rcBtn);
+						_szBtn.cx = rcBtn.right - rcBtn.left;
+						_szBtn.cy = rcBtn.bottom - rcBtn.top;
+						_isSizeSet = (_szBtn.cx != 0 && _szBtn.cy != 0);
+					}
+					break;
+				}
+
+				default:
+				{
+					break;
+				}
+			}
+		}
+	};
+
+	/**
+	 * @brief Draws a themed owner drawn checkbox, radio, or tri-state button (excluding push-like buttons).
+	 *
+	 * Internally used by @ref DarkMode::paintButton to draw visual elements such as checkbox glyphs
+	 * or radio indicators alongside styled text. Not used for buttons with `BS_PUSHLIKE`,
+	 * which require different handling and theming logic.
+	 *
+	 * - Retrieves themed or fallback font for consistent appearance.
+	 * - Handles alignment, word wrapping, and prefix visibility per style flags.
+	 * - Draws themed background and glyph using `DrawThemeBackground`.
+	 * - Uses dark mode-aware text rendering and applies focus cue when needed.
+	 *
+	 * @param hWnd Handle to the button control.
+	 * @param hdc Device context for drawing.
+	 * @param hTheme Active visual style theme handle.
+	 * @param iPartID Part ID (`BP_CHECKBOX`, `BP_RADIOBUTTON`, etc.).
+	 * @param iStateID State ID (`CBS_CHECKEDHOT`, `RBS_UNCHECKEDNORMAL`, etc.).
+	 *
+	 * @see DarkMode::paintButton()
+	 */
+	static void renderButton(HWND hWnd, HDC hdc, HTHEME hTheme, int iPartID, int iStateID)
+	{
+		// Font part
+
+		HFONT hFont = nullptr;
+		bool isFontCreated = false;
+		LOGFONT lf{};
+		if (SUCCEEDED(::GetThemeFont(hTheme, hdc, iPartID, iStateID, TMT_FONT, &lf)))
+		{
+			hFont = ::CreateFontIndirect(&lf);
+			isFontCreated = true;
+		}
+
+		if (hFont == nullptr)
+		{
+			hFont = reinterpret_cast<HFONT>(::SendMessage(hWnd, WM_GETFONT, 0, 0));
+		}
+
+		auto holdFont = static_cast<HFONT>(::SelectObject(hdc, hFont));
+
+		// Style part
+
+		const auto nStyle = ::GetWindowLongPtr(hWnd, GWL_STYLE);
+		const bool isMultiline = (nStyle & BS_MULTILINE) == BS_MULTILINE;
+		const bool isTop = (nStyle & BS_TOP) == BS_TOP;
+		const bool isBottom = (nStyle & BS_BOTTOM) == BS_BOTTOM;
+		const bool isCenter = (nStyle & BS_CENTER) == BS_CENTER;
+		const bool isRight = (nStyle & BS_RIGHT) == BS_RIGHT;
+		const bool isVCenter = (nStyle & BS_VCENTER) == BS_VCENTER;
+
+		DWORD dtFlags = DT_LEFT;
+		if (isMultiline)
+		{
+			dtFlags |= DT_WORDBREAK;
+		}
+		else
+		{
+			dtFlags |= DT_SINGLELINE;
+		}
+
+		if (isCenter)
+		{
+			dtFlags |= DT_CENTER;
+		}
+		else if (isRight)
+		{
+			dtFlags |= DT_RIGHT;
+		}
+
+		if (isVCenter || (!isMultiline && !isBottom && !isTop))
+		{
+			dtFlags |= DT_VCENTER;
+		}
+		else if (isBottom)
+		{
+			dtFlags |= DT_BOTTOM;
+		}
+
+		const auto uiState = static_cast<DWORD>(::SendMessage(hWnd, WM_QUERYUISTATE, 0, 0));
+		const bool hidePrefix = (uiState & UISF_HIDEACCEL) == UISF_HIDEACCEL;
+		if (hidePrefix)
+		{
+			dtFlags |= DT_HIDEPREFIX;
+		}
+
+		// Text and box part
+
+		RECT rcClient{};
+		::GetClientRect(hWnd, &rcClient);
+
+		std::wstring buffer;
+		const auto bufferLen = static_cast<size_t>(::GetWindowTextLength(hWnd));
+		buffer.resize(bufferLen + 1, L'\0');
+		::GetWindowText(hWnd, buffer.data(), static_cast<int>(buffer.length()));
+
+		SIZE szBox{};
+		::GetThemePartSize(hTheme, hdc, iPartID, iStateID, nullptr, TS_DRAW, &szBox);
+
+		RECT rcText{};
+		::GetThemeBackgroundContentRect(hTheme, hdc, iPartID, iStateID, &rcClient, &rcText);
+
+		RECT rcBackground{ rcClient };
+		if (!isMultiline)
+		{
+			rcBackground.top += (rcText.bottom - rcText.top - szBox.cy) / 2;
+		}
+		rcBackground.bottom = rcBackground.top + szBox.cy;
+		rcBackground.right = rcBackground.left + szBox.cx;
+		rcText.left = rcBackground.right + 3;
+
+		::DrawThemeParentBackground(hWnd, hdc, &rcClient);
+		::DrawThemeBackground(hTheme, hdc, iPartID, iStateID, &rcBackground, nullptr); // draw box
+
+		DTTOPTS dtto{};
+		dtto.dwSize = sizeof(DTTOPTS);
+		dtto.dwFlags = DTT_TEXTCOLOR;
+		dtto.crText = (::IsWindowEnabled(hWnd) == FALSE) ? DarkMode::getDisabledTextColor() : DarkMode::getTextColor();
+
+		::DrawThemeTextEx(hTheme, hdc, iPartID, iStateID, buffer.c_str(), -1, dtFlags, &rcText, &dtto);
+
+		// Focus rect
+
+		const auto nState = static_cast<DWORD>(::SendMessage(hWnd, BM_GETSTATE, 0, 0));
+		if (((nState & BST_FOCUS) == BST_FOCUS) && ((uiState & UISF_HIDEFOCUS) != UISF_HIDEFOCUS))
+		{
+			dtto.dwFlags |= DTT_CALCRECT;
+			::DrawThemeTextEx(hTheme, hdc, iPartID, iStateID, buffer.c_str(), -1, dtFlags | DT_CALCRECT, &rcText, &dtto);
+			const RECT rcFocus{ rcText.left - 1, rcText.top, rcText.right + 1, rcText.bottom + 1 };
+			::DrawFocusRect(hdc, &rcFocus);
+		}
+
+		// Cleanup
+
+		::SelectObject(hdc, holdFont);
+		if (isFontCreated)
+		{
+			::DeleteObject(hFont);
+		}
+	}
+
+	/**
+	 * @brief Paints a checkbox, radio, or tri-state button with state-based visuals.
+	 *
+	 * Determines the appropriate themed part and state ID based on the control’s
+	 * style (e.g. `BS_CHECKBOX`, `BS_RADIOBUTTON`) and current button state flags
+	 * such as `BST_CHECKED`, `BST_PUSHED`, or `BST_HOT`.
+	 *
+	 * - Uses buffered animation (if available) to smoothly transition between states.
+	 * - Falls back to direct drawing via @ref DarkMode::renderButton if animation is not used.
+	 * - Internally updates the `buttonData._iStateID` to preserve the last rendered state.
+	 * - Not used for `BS_PUSHLIKE` buttons.
+	 *
+	 * @param hWnd Handle to the checkbox or radio button control.
+	 * @param hdc Device context used for rendering.
+	 * @param buttonData Theming and state info, including current theme and last state.
+	 *
+	 * @see DarkMode::renderButton()
+	 */
+	static void paintButton(HWND hWnd, HDC hdc, ButtonData& buttonData)
+	{
+		const auto& hTheme = buttonData._themeData.getHTheme();
+
+		const auto nState = static_cast<DWORD>(::SendMessage(hWnd, BM_GETSTATE, 0, 0));
+		const auto nStyle = ::GetWindowLongPtr(hWnd, GWL_STYLE);
+		const auto nBtnStyle = nStyle & BS_TYPEMASK;
+
+		int iPartID = 0;
+		int iStateID = 0;
+
+		// Get style
+		switch (nBtnStyle)
+		{
+			case BS_CHECKBOX:
+			case BS_AUTOCHECKBOX:
+			case BS_3STATE:
+			case BS_AUTO3STATE:
+			{
+				iPartID = BP_CHECKBOX;
+
+				if (::IsWindowEnabled(hWnd) == FALSE)           { iStateID = CBS_UNCHECKEDDISABLED; }
+				else if ((nState & BST_PUSHED) == BST_PUSHED)   { iStateID = CBS_UNCHECKEDPRESSED; }
+				else if ((nState & BST_HOT) == BST_HOT)         { iStateID = CBS_UNCHECKEDHOT; }
+				else                                            { iStateID = CBS_UNCHECKEDNORMAL; }
+
+				static constexpr int checkedOffset = 4;
+				static constexpr int mixedOffset = 8;
+				if ((nState & BST_CHECKED) == BST_CHECKED)      { iStateID += checkedOffset; }
+				else if ((nState & BST_INDETERMINATE) == BST_INDETERMINATE) { iStateID += mixedOffset; }
+
+				break;
+			}
+
+			case BS_RADIOBUTTON:
+			case BS_AUTORADIOBUTTON:
+			{
+				iPartID = BP_RADIOBUTTON;
+
+				if (::IsWindowEnabled(hWnd) == FALSE)           { iStateID = RBS_UNCHECKEDDISABLED; }
+				else if ((nState & BST_PUSHED) == BST_PUSHED)   { iStateID = RBS_UNCHECKEDPRESSED; }
+				else if ((nState & BST_HOT) == BST_HOT)         { iStateID = RBS_UNCHECKEDHOT; }
+				else                                            { iStateID = RBS_UNCHECKEDNORMAL; }
+
+				if ((nState & BST_CHECKED) == BST_CHECKED)      { iStateID += 4; }
+
+				break;
+			}
+
+			default: // should never happen
+			{
+				iPartID = BP_CHECKBOX;
+				iStateID = CBS_UNCHECKEDDISABLED;
+				break;
+			}
+		}
+
+		if (::BufferedPaintRenderAnimation(hWnd, hdc) == TRUE)
+		{
+			return;
+		}
+
+		// Animation part - hover transition
+
+		BP_ANIMATIONPARAMS animParams{};
+		animParams.cbSize = sizeof(BP_ANIMATIONPARAMS);
+		animParams.style = BPAS_LINEAR;
+		if (iStateID != buttonData._iStateID)
+		{
+			::GetThemeTransitionDuration(hTheme, iPartID, buttonData._iStateID, iStateID, TMT_TRANSITIONDURATIONS, &animParams.dwDuration);
+		}
+
+		RECT rcClient{};
+		::GetClientRect(hWnd, &rcClient);
+
+		HDC hdcFrom = nullptr;
+		HDC hdcTo = nullptr;
+		HANIMATIONBUFFER hbpAnimation = ::BeginBufferedAnimation(hWnd, hdc, &rcClient, BPBF_COMPATIBLEBITMAP, nullptr, &animParams, &hdcFrom, &hdcTo);
+		if (hbpAnimation != nullptr)
+		{
+			if (hdcFrom != nullptr)
+			{
+				DarkMode::renderButton(hWnd, hdcFrom, hTheme, iPartID, buttonData._iStateID);
+			}
+			if (hdcTo != nullptr)
+			{
+				DarkMode::renderButton(hWnd, hdcTo, hTheme, iPartID, iStateID);
+			}
+
+			buttonData._iStateID = iStateID;
+
+			::EndBufferedAnimation(hbpAnimation, TRUE);
+		}
+		else
+		{
+			DarkMode::renderButton(hWnd, hdc, hTheme, iPartID, iStateID);
+
+			buttonData._iStateID = iStateID;
+		}
+	}
+
+	/**
+	 * @brief Window subclass procedure for themed owner drawn checkbox, radio, and tri-state buttons.
+	 *
+	 * @param hWnd Window handle being subclassed.
+	 * @param uMsg Message identifier.
+	 * @param wParam Message-specific data.
+	 * @param lParam Message-specific data.
+	 * @param uIdSubclass Subclass identifier.
+	 * @param dwRefData ButtonData instance.
+	 * @return LRESULT Result of message processing.
+	 *
+	 * @see DarkMode::setCheckboxOrRadioBtnCtrlSubclass()
+	 * @see DarkMode::removeCheckboxOrRadioBtnCtrlSubclass()
+	 */
+	static LRESULT CALLBACK ButtonSubclass(
+		HWND hWnd,
+		UINT uMsg,
+		WPARAM wParam,
+		LPARAM lParam,
+		UINT_PTR uIdSubclass,
+		DWORD_PTR dwRefData
+	)
+	{
+		auto* pButtonData = reinterpret_cast<ButtonData*>(dwRefData);
+		auto& themeData = pButtonData->_themeData;
+
+		switch (uMsg)
+		{
+			case WM_NCDESTROY:
+			{
+				::RemoveWindowSubclass(hWnd, ButtonSubclass, uIdSubclass);
+				delete pButtonData;
+				break;
+			}
+
+			case WM_ERASEBKGND:
+			{
+				if (!DarkMode::isEnabled() || !themeData.ensureTheme(hWnd))
+				{
+					break;
+				}
+				return TRUE;
+			}
+
+			case WM_PRINTCLIENT:
+			case WM_PAINT:
+			{
+				if (!DarkMode::isEnabled() || !themeData.ensureTheme(hWnd))
+				{
+					break;
+				}
+
+				PAINTSTRUCT ps{};
+				auto hdc = reinterpret_cast<HDC>(wParam);
+				if (hdc == nullptr)
+				{
+					hdc = ::BeginPaint(hWnd, &ps);
+				}
+
+				DarkMode::paintButton(hWnd, hdc, *pButtonData);
+
+				if (ps.hdc != nullptr)
+				{
+					::EndPaint(hWnd, &ps);
+				}
+
+				return 0;
+			}
+
+			case WM_DPICHANGED:
+			case WM_DPICHANGED_AFTERPARENT:
+			{
+				themeData.closeTheme();
+				return 0;
+			}
+
+			case WM_THEMECHANGED:
+			{
+				themeData.closeTheme();
+				break;
+			}
+
+			case WM_SIZE:
+			case WM_DESTROY:
+			{
+				::BufferedPaintStopAllAnimations(hWnd);
+				break;
+			}
+
+			case WM_ENABLE:
+			{
+				if (!DarkMode::isEnabled())
+				{
+					break;
+				}
+
+				// Skip the button's normal wndproc so it won't redraw out of wm_paint
+				const LRESULT retVal = ::DefWindowProc(hWnd, uMsg, wParam, lParam);
+				::InvalidateRect(hWnd, nullptr, FALSE);
+				return retVal;
+			}
+
+			case WM_UPDATEUISTATE:
+			{
+				if ((HIWORD(wParam) & (UISF_HIDEACCEL | UISF_HIDEFOCUS)) != 0)
+				{
+					::InvalidateRect(hWnd, nullptr, FALSE);
+				}
+				break;
+			}
+
+			default:
+			{
+				break;
+			}
+		}
+		return ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
+	}
+
+	/**
+	 * @brief Applies themed owner drawn subclassing to a checkbox, radio, or tri-state button control.
+	 *
+	 * Associates a `ButtonData` instance with the control.
+	 *
+	 * @param hWnd Handle to the checkbox, radio, or tri-state button control.
+	 *
+	 * @see DarkMode::ButtonSubclass()
+	 * @see DarkMode::removeCheckboxOrRadioBtnCtrlSubclass()
+	 */
+	void setCheckboxOrRadioBtnCtrlSubclass(HWND hWnd)
+	{
+		DarkMode::setSubclass<ButtonData>(hWnd, ButtonSubclass, kButtonSubclassID, hWnd);
+	}
+
+	/**
+	 * @brief Removes the owner drawn subclass from a checkbox, radio, or tri-state button control.
+	 *
+	 * Cleans up the `ButtonData` instance and detaches the control's subclass proc.
+	 *
+	 * @param hWnd Handle to the control previously subclassed.
+	 *
+	 * @see DarkMode::ButtonSubclass()
+	 * @see DarkMode::setCheckboxOrRadioBtnCtrlSubclass()
+	 */
+	void removeCheckboxOrRadioBtnCtrlSubclass(HWND hWnd)
+	{
+		DarkMode::removeSubclass<ButtonData>(hWnd, ButtonSubclass, kButtonSubclassID);
+	}
+
+	/**
+	 * @brief Paints a group box frame and text with custom colors.
+	 *
+	 * Handles drawing a themed group box with optional centered text, styled borders,
+	 * and font fallback. If a caption text is present, the frame is clipped to avoid overdrawing
+	 * behind the text. The function adapts layout for both centered and left-aligned titles.
+	 *
+	 * Rendering steps:
+	 * - Determines current visual state (`GBS_DISABLED`, `GBS_NORMAL`).
+	 * - Retrieves themed font via `GetThemeFont` or falls back to dialog font.
+	 * - Measures caption text, computes layout and exclusion for frame clipping.
+	 * - Paints the outer rounded frame via @ref DarkMode::paintRoundFrameRect
+	 *   using `DarkMode::getEdgePen()`.
+	 * - Restores clip region and renders text using `DrawThemeTextEx` with custom colors.
+	 *
+	 * @param hWnd Handle to the group box control.
+	 * @param hdc Device context used for painting.
+	 * @param buttonData Reference to the theming and state info (theme handle).
+	 *
+	 * @note Ensures proper cleanup of temporary GDI objects (font, clip region).
+	 *
+	 * @see DarkMode::paintRoundFrameRect()
+	 */
+	static void paintGroupbox(HWND hWnd, HDC hdc, const ButtonData& buttonData)
+	{
+		const auto& hTheme = buttonData._themeData.getHTheme();
+
+		// Style part
+
+		const bool isDisabled = ::IsWindowEnabled(hWnd) == FALSE;
+		static constexpr int iPartID = BP_GROUPBOX;
+		const int iStateID = isDisabled ? GBS_DISABLED : GBS_NORMAL;
+
+		// Font part
+
+		bool isFontCreated = false;
+		HFONT hFont = nullptr;
+		LOGFONT lf{};
+		if (SUCCEEDED(::GetThemeFont(hTheme, hdc, iPartID, iStateID, TMT_FONT, &lf)))
+		{
+			hFont = ::CreateFontIndirect(&lf);
+			isFontCreated = true;
+		}
+
+		if (hFont == nullptr)
+		{
+			hFont = reinterpret_cast<HFONT>(::SendMessage(hWnd, WM_GETFONT, 0, 0));
+			isFontCreated = false;
+		}
+
+		auto holdFont = static_cast<HFONT>(::SelectObject(hdc, hFont));
+
+		// Text rectangle part
+
+		std::wstring buffer;
+		const auto bufferLen = static_cast<size_t>(::GetWindowTextLength(hWnd));
+		if (bufferLen > 0)
+		{
+			buffer.resize(bufferLen + 1, L'\0');
+			::GetWindowText(hWnd, buffer.data(), static_cast<int>(buffer.length()));
+		}
+
+		const auto nStyle = ::GetWindowLongPtr(hWnd, GWL_STYLE);
+		const bool isCenter = (nStyle & BS_CENTER) == BS_CENTER;
+
+		RECT rcClient{};
+		::GetClientRect(hWnd, &rcClient);
+
+		rcClient.bottom -= 1;
+
+		RECT rcText{ rcClient };
+		RECT rcBackground{ rcClient };
+		if (!buffer.empty())
+		{
+			SIZE szText{};
+			::GetTextExtentPoint32(hdc, buffer.c_str(), static_cast<int>(bufferLen), &szText);
+
+			const int centerPosX = isCenter ? ((rcClient.right - rcClient.left - szText.cx) / 2) : 7;
+
+			rcBackground.top += szText.cy / 2;
+			rcText.left += centerPosX;
+			rcText.bottom = rcText.top + szText.cy;
+			rcText.right = rcText.left + szText.cx + 4;
+
+			::ExcludeClipRect(hdc, rcText.left, rcText.top, rcText.right, rcText.bottom);
+		}
+		else // There is no text, use "M" to get metrics to move top edge down
+		{
+			SIZE szText{};
+			::GetTextExtentPoint32(hdc, L"M", 1, &szText);
+			rcBackground.top += szText.cy / 2;
+		}
+
+		RECT rcContent = rcBackground;
+		::GetThemeBackgroundContentRect(hTheme, hdc, BP_GROUPBOX, iStateID, &rcBackground, &rcContent);
+		::ExcludeClipRect(hdc, rcContent.left, rcContent.top, rcContent.right, rcContent.bottom);
+
+		DarkMode::paintRoundFrameRect(hdc, rcBackground, DarkMode::getEdgePen()); // main frame
+
+		::SelectClipRgn(hdc, nullptr);
+
+		// Text part
+
+		if (!buffer.empty())
+		{
+			::InflateRect(&rcText, -2, 0);
+
+			DTTOPTS dtto{};
+			dtto.dwSize = sizeof(DTTOPTS);
+			dtto.dwFlags = DTT_TEXTCOLOR;
+			dtto.crText = isDisabled ? DarkMode::getDisabledTextColor() : DarkMode::getTextColor();
+
+			DWORD dtFlags = isCenter ? DT_CENTER : DT_LEFT;
+
+			if (::SendMessage(hWnd, WM_QUERYUISTATE, 0, 0) != 0) // NULL
+			{
+				dtFlags |= DT_HIDEPREFIX;
+			}
+
+			::DrawThemeTextEx(hTheme, hdc, BP_GROUPBOX, iStateID, buffer.c_str(), -1, dtFlags | DT_SINGLELINE, &rcText, &dtto);
+		}
+
+		::SelectObject(hdc, holdFont);
+		if (isFontCreated)
+		{
+			::DeleteObject(hFont);
+		}
+	}
+
+	/**
+	 * @brief Window subclass procedure for owner drawn groupbox button control.
+	 *
+	 * @param hWnd Window handle being subclassed.
+	 * @param uMsg Message identifier.
+	 * @param wParam Message-specific data.
+	 * @param lParam Message-specific data.
+	 * @param uIdSubclass Subclass identifier.
+	 * @param dwRefData ButtonData instance.
+	 * @return LRESULT Result of message processing.
+	 *
+	 * @see DarkMode::setGroupboxCtrlSubclass()
+	 * @see DarkMode::removeGroupboxCtrlSubclass()
+	 */
+	static LRESULT CALLBACK GroupboxSubclass(
+		HWND hWnd,
+		UINT uMsg,
+		WPARAM wParam,
+		LPARAM lParam,
+		UINT_PTR uIdSubclass,
+		DWORD_PTR dwRefData
+	)
+	{
+		auto* pButtonData = reinterpret_cast<ButtonData*>(dwRefData);
+		auto& themeData = pButtonData->_themeData;
+
+		switch (uMsg)
+		{
+			case WM_NCDESTROY:
+			{
+				::RemoveWindowSubclass(hWnd, GroupboxSubclass, uIdSubclass);
+				delete pButtonData;
+				break;
+			}
+
+			case WM_ERASEBKGND:
+			{
+				if (!DarkMode::isEnabled() || !themeData.ensureTheme(hWnd))
+				{
+					break;
+				}
+				return TRUE;
+			}
+
+			case WM_PRINTCLIENT:
+			case WM_PAINT:
+			{
+				if (!DarkMode::isEnabled() || !themeData.ensureTheme(hWnd))
+				{
+					break;
+				}
+
+				PAINTSTRUCT ps{};
+				auto hdc = reinterpret_cast<HDC>(wParam);
+				if (hdc == nullptr)
+				{
+					hdc = ::BeginPaint(hWnd, &ps);
+				}
+
+				DarkMode::paintGroupbox(hWnd, hdc, *pButtonData);
+
+				if (ps.hdc != nullptr)
+				{
+					::EndPaint(hWnd, &ps);
+				}
+
+				return 0;
+			}
+
+			case WM_DPICHANGED:
+			case WM_DPICHANGED_AFTERPARENT:
+			{
+				themeData.closeTheme();
+				return 0;
+			}
+
+			case WM_THEMECHANGED:
+			{
+				themeData.closeTheme();
+				break;
+			}
+
+			case WM_ENABLE:
+			{
+				::RedrawWindow(hWnd, nullptr, nullptr, RDW_INVALIDATE);
+				break;
+			}
+
+			default:
+			{
+				break;
+			}
+		}
+		return ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
+	}
+
+	/**
+	 * @brief Applies owner drawn subclassing to a groupbox button control.
+	 *
+	 * Associates a `ButtonData` instance with the control.
+	 *
+	 * @param hWnd Handle to the groupbox button control.
+	 *
+	 * @see DarkMode::GroupboxSubclass()
+	 * @see DarkMode::removeGroupboxCtrlSubclass()
+	 */
+	void setGroupboxCtrlSubclass(HWND hWnd)
+	{
+		DarkMode::setSubclass<ButtonData>(hWnd, GroupboxSubclass, kGroupboxSubclassID);
+	}
+
+	/**
+	 * @brief Removes the owner drawn subclass from a groupbox button control.
+	 *
+	 * Cleans up the `ButtonData` instance and detaches the control's subclass proc.
+	 *
+	 * @param hWnd Handle to the control previously subclassed.
+	 *
+	 * @see DarkMode::GroupboxSubclass()
+	 * @see DarkMode::setGroupboxCtrlSubclass()
+	 */
+	void removeGroupboxCtrlSubclass(HWND hWnd)
+	{
+		DarkMode::removeSubclass<ButtonData>(hWnd, GroupboxSubclass, kGroupboxSubclassID);
+	}
+
+	/**
+	 * @brief Applies theming and/or subclassing to a button control based on its style.
+	 *
+	 * Inspects the control's style (`BS_*`) to determine its visual category and applies
+	 * apropriate theming and/or subclassing accordingly. Handles:
+	 * - Checkbox/radio/tri-state buttons: Applies theme (optional) and optional subclassing
+	 * - Group boxes: Applies subclassing for dark mode drawing
+	 * - Push buttons: Applies visual theming if requested
+	 *
+	 * The behavior varies depending on dark mode support, Windows version, and the flags
+	 * provided in @ref DarkModeParams.
+	 *
+	 * @param hWnd Handle to the target button control.
+	 * @param p Parameters defining theming and subclassing behavior.
+	 *
+	 * @see DarkModeParams
+	 * @see DarkMode::setCheckboxOrRadioBtnCtrlSubclass()
+	 * @see DarkMode::setGroupboxCtrlSubclass()
+	 */
+	static void setBtnCtrlSubclassAndTheme(HWND hWnd, DarkModeParams p)
+	{
+		const auto nBtnStyle = ::GetWindowLongPtr(hWnd, GWL_STYLE);
+		switch (nBtnStyle & BS_TYPEMASK)
+		{
+			case BS_CHECKBOX:
+			case BS_AUTOCHECKBOX:
+			case BS_3STATE:
+			case BS_AUTO3STATE:
+			case BS_RADIOBUTTON:
+			case BS_AUTORADIOBUTTON:
+			{
+				if ((nBtnStyle & BS_PUSHLIKE) == BS_PUSHLIKE)
+				{
+					if (p._theme)
+					{
+						::SetWindowTheme(hWnd, p._themeClassName, nullptr);
+					}
+					break;
+				}
+
+				if (DarkMode::isAtLeastWindows11() && p._theme)
+				{
+					::SetWindowTheme(hWnd, p._themeClassName, nullptr);
+				}
+
+				if (p._subclass)
+				{
+					DarkMode::setCheckboxOrRadioBtnCtrlSubclass(hWnd);
+				}
+				break;
+			}
+
+			case BS_GROUPBOX:
+			{
+				if (p._subclass)
+				{
+					DarkMode::setGroupboxCtrlSubclass(hWnd);
+				}
+				break;
+			}
+
+			case BS_PUSHBUTTON:
+			case BS_DEFPUSHBUTTON:
+			case BS_SPLITBUTTON:
+			case BS_DEFSPLITBUTTON:
+			{
+				if (p._theme)
+				{
+					::SetWindowTheme(hWnd, p._themeClassName, nullptr);
+				}
+				break;
+			}
+
+			default:
+			{
+				break;
+			}
+		}
+	}
+
+	/**
+	 * @struct UpDownData
+	 * @brief Stores layout and rendering state for a owner drawn updown (spinner) control.
+	 *
+	 * Used to manage rectangle, buffer, and hit-test regions for owner-drawn subclassed
+	 * up-down controls, supporting both vertical and horizontal layouts.
+	 *
+	 * Key members:
+	 * - `_bufferData`: Offscreen back buffer for flicker-free rendering.
+	 * - `_rcClient`: Current client rectangle of the control.
+	 * - `_rcPrev`, `_rcNext`: Rectangles for the up/down or left/right arrow buttons.
+	 * - `_cornerRoundness`: Optional roundness for corners (used in Windows 11+ with tabs).
+	 * - `_isHorizontal`: `true` if the control is horizontal (`UDS_HORZ` style).
+	 * - `_wasHotNext`: Last hover state (used for hover feedback/rendering).
+	 *
+	 * Construction:
+	 * - Detects orientation from `GWL_STYLE`.
+	 * - Initializes corner styling based on OS and parent class.
+	 * - Extracts rectangles for arrow segments immediately.
+	 *
+	 * Usage:
+	 * - `updateRect(HWND)`: Refreshes rectangle from control handle.
+	 * - `updateRect(RECT)`: Checks for rectangle change and updates it.
+	 */
+	struct UpDownData
+	{
+		BufferData _bufferData;
+
+		RECT _rcClient{};
+		RECT _rcPrev{};
+		RECT _rcNext{};
+		int _cornerRoundness = 0;
+		bool _isHorizontal = false;
+		bool _wasHotNext = false;
+
+		UpDownData() = delete;
+
+		explicit UpDownData(HWND hWnd)
+			: _cornerRoundness((DarkMode::isAtLeastWindows11() && CmpWndClassName(::GetParent(hWnd), WC_TABCONTROL)) ? (kWin11CornerRoundness + 1) : 0)
+			, _isHorizontal((::GetWindowLongPtr(hWnd, GWL_STYLE) & UDS_HORZ) == UDS_HORZ)
+		{
+			updateRect(hWnd);
+		}
+
+		void updateRectUpDown()
+		{
+			if (_isHorizontal)
+			{
+				const RECT rcArrowLeft{
+					_rcClient.left, _rcClient.top,
+					_rcClient.right - ((_rcClient.right - _rcClient.left) / 2) - 1, _rcClient.bottom
+				};
+
+				const RECT rcArrowRight{
+					rcArrowLeft.right + 1, _rcClient.top,
+					_rcClient.right, _rcClient.bottom
+				};
+
+				_rcPrev = rcArrowLeft;
+				_rcNext = rcArrowRight;
+			}
+			else
+			{
+				static constexpr LONG offset = 2;
+
+				const RECT rcArrowTop{
+					_rcClient.left + offset, _rcClient.top,
+					_rcClient.right, _rcClient.bottom - ((_rcClient.bottom - _rcClient.top) / 2)
+				};
+
+				const RECT rcArrowBottom{
+					_rcClient.left + offset, rcArrowTop.bottom,
+					_rcClient.right, _rcClient.bottom
+				};
+
+				_rcPrev = rcArrowTop;
+				_rcNext = rcArrowBottom;
+			}
+		}
+
+		void updateRect(HWND hWnd)
+		{
+			::GetClientRect(hWnd, &_rcClient);
+			updateRectUpDown();
+		}
+
+		bool updateRect(RECT rcClientNew)
+		{
+			if (::EqualRect(&_rcClient, &rcClientNew) == FALSE)
+			{
+				_rcClient = rcClientNew;
+				updateRectUpDown();
+				return true;
+			}
+			return false;
+		}
+	};
+
+	/**
+	 * @brief Custom paints a updown (spinner) control.
+	 *
+	 * Renders the two-button control using custom color brushes, pen styles, and directional
+	 * arrows. Adapts to both vertical and horizontal orientation based on @ref UpDownData.
+	 * Applies hover highlighting and draws appropriate glyphs (`<`/`>` or `˄`/`˅`) using
+	 * the control's font.
+	 *
+	 * Paint logic includes:
+	 * - Background fill with dialog background brush
+	 * - Rounded corners (optional, based on Windows 11 and parent class)
+	 * - Direction-aware layout and glyph placement
+	 *
+	 * @param hWnd Handle to the updown control being painted.
+	 * @param hdc Target device context.
+	 * @param upDownData Reference to layout and state information (segments, orientation, corner radius).
+	 *
+	 * @note Assumes the DC has already been prepared for painting. Uses `WM_GETFONT` to
+	 *       match the host UI font.
+	 *
+	 * @see UpDownData
+	 */
+	static void paintUpDown(HWND hWnd, HDC hdc, UpDownData& upDownData)
+	{
+		const bool isDisabled = ::IsWindowEnabled(hWnd) == FALSE;
+		const int roundness = upDownData._cornerRoundness;
+
+		::FillRect(hdc, &upDownData._rcClient, DarkMode::getDlgBackgroundBrush());
+		::SetBkMode(hdc, TRANSPARENT);
+
+		// Button part
+
+		POINT ptCursor{};
+		::GetCursorPos(&ptCursor);
+		::ScreenToClient(hWnd, &ptCursor);
+
+		const bool isHotPrev = ::PtInRect(&upDownData._rcPrev, ptCursor) == TRUE;
+		const bool isHotNext = ::PtInRect(&upDownData._rcNext, ptCursor) == TRUE;
+
+		upDownData._wasHotNext = !isHotPrev && (::PtInRect(&upDownData._rcClient, ptCursor) == TRUE);
+
+		auto paintUpDownBtn = [&](const RECT& rect, bool isHot) -> void {
+			HBRUSH hBrush = nullptr;
+			HPEN hPen = nullptr;
+			if (isDisabled)
+			{
+				hBrush = DarkMode::getDlgBackgroundBrush();
+				hPen = DarkMode::getDisabledEdgePen();
+			}
+			else if (isHot)
+			{
+				hBrush = DarkMode::getHotBackgroundBrush();
+				hPen = DarkMode::getHotEdgePen();
+			}
+			else
+			{
+				hBrush = DarkMode::getCtrlBackgroundBrush();
+				hPen = DarkMode::getEdgePen();
+			}
+
+			DarkMode::paintRoundRect(hdc, rect, hPen, hBrush, roundness, roundness);
+		};
+
+		paintUpDownBtn(upDownData._rcPrev, isHotPrev);
+		paintUpDownBtn(upDownData._rcNext, isHotNext);
+
+		// Glyph part
+
+		auto hFont = reinterpret_cast<HFONT>(::SendMessage(hWnd, WM_GETFONT, 0, 0));
+		auto holdFont = static_cast<HFONT>(::SelectObject(hdc, hFont));
+
+		static constexpr UINT dtFlags = DT_NOPREFIX | DT_CENTER | DT_VCENTER | DT_SINGLELINE | DT_NOCLIP;
+		const COLORREF clrText = isDisabled ? DarkMode::getDisabledTextColor() : DarkMode::getDarkerTextColor();
+
+		const LONG offset = upDownData._isHorizontal ? 1 : 0;
+		RECT rcTectPrev{ upDownData._rcPrev.left, upDownData._rcPrev.top, upDownData._rcPrev.right, upDownData._rcPrev.bottom - offset };
+		::SetTextColor(hdc, isHotPrev ? DarkMode::getTextColor() : clrText);
+		::DrawText(hdc, upDownData._isHorizontal ? L"<" : L"˄", -1, &rcTectPrev, dtFlags);
+
+		RECT rcTectNext{ upDownData._rcNext.left + offset, upDownData._rcNext.top, upDownData._rcNext.right, upDownData._rcNext.bottom - offset };
+		::SetTextColor(hdc, isHotNext ? DarkMode::getTextColor() : clrText);
+		::DrawText(hdc, upDownData._isHorizontal ? L">" : L"˅", -1, &rcTectNext, dtFlags);
+
+		::SelectObject(hdc, holdFont);
+	}
+
+	/**
+	 * @brief Window subclass procedure for owner drawn updown (spinner) control.
+	 *
+	 * @param hWnd Window handle being subclassed.
+	 * @param uMsg Message identifier.
+	 * @param wParam Message-specific data.
+	 * @param lParam Message-specific data.
+	 * @param uIdSubclass Subclass identifier.
+	 * @param dwRefData UpDownData instance .
+	 * @return LRESULT Result of message processing.
+	 *
+	 * @see DarkMode::setUpDownCtrlSubclass()
+	 * @see DarkMode::removeUpDownCtrlSubclass()
+	 */
+	static LRESULT CALLBACK UpDownSubclass(
+		HWND hWnd,
+		UINT uMsg,
+		WPARAM wParam,
+		LPARAM lParam,
+		UINT_PTR uIdSubclass,
+		DWORD_PTR dwRefData
+	)
+	{
+		auto* pUpDownData = reinterpret_cast<UpDownData*>(dwRefData);
+		auto& bufferData = pUpDownData->_bufferData;
+		const auto& hMemDC = bufferData.getHMemDC();
+
+		switch (uMsg)
+		{
+			case WM_NCDESTROY:
+			{
+				::RemoveWindowSubclass(hWnd, UpDownSubclass, uIdSubclass);
+				delete pUpDownData;
+				break;
+			}
+
+			case WM_ERASEBKGND:
+			{
+				if (!DarkMode::isEnabled())
+				{
+					break;
+				}
+
+				const auto* hdc = reinterpret_cast<HDC>(wParam);
+				if (hdc != hMemDC)
+				{
+					return FALSE;
+				}
+				return TRUE;
+			}
+
+			case WM_PAINT:
+			{
+				if (!DarkMode::isEnabled())
+				{
+					break;
+				}
+
+				PAINTSTRUCT ps{};
+				HDC hdc = ::BeginPaint(hWnd, &ps);
+
+				if (ps.rcPaint.right <= ps.rcPaint.left || ps.rcPaint.bottom <= ps.rcPaint.top)
+				{
+					::EndPaint(hWnd, &ps);
+					return 0;
+				}
+
+				if (!pUpDownData->_isHorizontal)
+				{
+					::OffsetRect(&ps.rcPaint, 2, 0);
+				}
+
+				RECT rcClient{};
+				::GetClientRect(hWnd, &rcClient);
+				pUpDownData->updateRect(rcClient);
+				if (!pUpDownData->_isHorizontal)
+				{
+					::OffsetRect(&rcClient, 2, 0);
+				}
+
+				if (bufferData.ensureBuffer(hdc, rcClient))
+				{
+					const int savedState = ::SaveDC(hMemDC);
+					::IntersectClipRect(
+						hMemDC,
+						ps.rcPaint.left, ps.rcPaint.top, ps.rcPaint.right, ps.rcPaint.bottom
+					);
+
+					DarkMode::paintUpDown(hWnd, hMemDC, *pUpDownData);
+
+					::RestoreDC(hMemDC, savedState);
+
+					::BitBlt(
+						hdc,
+						ps.rcPaint.left, ps.rcPaint.top,
+						ps.rcPaint.right - ps.rcPaint.left,
+						ps.rcPaint.bottom - ps.rcPaint.top,
+						hMemDC,
+						ps.rcPaint.left, ps.rcPaint.top,
+						SRCCOPY
+					);
+				}
+
+				::EndPaint(hWnd, &ps);
+				return 0;
+			}
+
+			case WM_DPICHANGED:
+			case WM_DPICHANGED_AFTERPARENT:
+			{
+				pUpDownData->updateRect(hWnd);
+				return 0;
+			}
+
+			case WM_MOUSEMOVE:
+			{
+				if (!DarkMode::isEnabled())
+				{
+					break;
+				}
+
+				if (pUpDownData->_wasHotNext)
+				{
+					pUpDownData->_wasHotNext = false;
+					::RedrawWindow(hWnd, nullptr, nullptr, RDW_INVALIDATE);
+				}
+
+				break;
+			}
+
+			case WM_MOUSELEAVE:
+			{
+				if (!DarkMode::isEnabled())
+				{
+					break;
+				}
+
+				pUpDownData->_wasHotNext = false;
+				::RedrawWindow(hWnd, nullptr, nullptr, RDW_INVALIDATE);
+
+				break;
+			}
+
+			default:
+			{
+				break;
+			}
+		}
+		return ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
+	}
+
+	/**
+	 * @brief Applies owner drawn subclassing and theming to an updown (spinner) control.
+	 *
+	 * Associates a `UpDownData` instance with the control.
+	 *
+	 * @param hWnd Handle to the updown (spinner) control.
+	 *
+	 * @see DarkMode::UpDownSubclass()
+	 * @see DarkMode::removeUpDownCtrlSubclass()
+	 */
+	void setUpDownCtrlSubclass(HWND hWnd)
+	{
+		DarkMode::setSubclass<UpDownData>(hWnd, UpDownSubclass, kUpDownSubclassID, hWnd);
+		DarkMode::setDarkExplorerTheme(hWnd);
+	}
+
+	/**
+	 * @brief Removes the owner drawn subclass from a updown (spinner) control.
+	 *
+	 * Cleans up the `UpDownData` instance and detaches the control's subclass proc.
+	 *
+	 * @param hWnd Handle to the control previously subclassed.
+	 *
+	 * @see DarkMode::UpDownSubclass()
+	 * @see DarkMode::setUpDownCtrlSubclass()
+	 */
+	void removeUpDownCtrlSubclass(HWND hWnd)
+	{
+		DarkMode::removeSubclass<UpDownData>(hWnd, UpDownSubclass, kUpDownSubclassID);
+	}
+
+	/**
+	 * @brief Applies updown (spinner) control theming and/or subclassing based on specified parameters.
+	 *
+	 * Conditionally applies custom subclassing and/or themed appearance depending on
+	 * `DarkModeParams`. Subclassing takes priority if both are requested.
+	 *
+	 * @param hWnd Handle to the up-down control.
+	 * @param p Parameters controlling whether to apply theming and/or subclassing.
+	 *
+	 * @see DarkModeParams
+	 * @see DarkMode::setUpDownCtrlSubclass()
+	 */
+	static void setUpDownCtrlSubclassAndTheme(HWND hWnd, DarkModeParams p)
+	{
+		if (p._subclass)
+		{
+			DarkMode::setUpDownCtrlSubclass(hWnd);
+		}
+		else if (p._theme)
+		{
+			::SetWindowTheme(hWnd, p._themeClassName, nullptr);
+		}
+	}
+
+	static void paintTab(HWND hWnd, HDC hdc, const RECT& rect)
+	{
+		::FillRect(hdc, &rect, DarkMode::getDlgBackgroundBrush());
+
+		auto holdPen = static_cast<HPEN>(::SelectObject(hdc, DarkMode::getEdgePen()));
+
+		auto holdClip = ::CreateRectRgn(0, 0, 0, 0);
+		if (::GetClipRgn(hdc, holdClip) != 1)
+		{
+			::DeleteObject(holdClip);
+			holdClip = nullptr;
+		}
+
+		auto hFont = reinterpret_cast<HFONT>(::SendMessage(hWnd, WM_GETFONT, 0, 0));
+		auto holdFont = ::SelectObject(hdc, hFont);
+
+		POINT ptCursor{};
+		::GetCursorPos(&ptCursor);
+		::ScreenToClient(hWnd, &ptCursor);
+
+		bool hasFocusRect = false;
+		if (::GetFocus() == hWnd)
+		{
+			const auto uiState = static_cast<DWORD>(::SendMessage(hWnd, WM_QUERYUISTATE, 0, 0));
+			hasFocusRect = ((uiState & UISF_HIDEFOCUS) != UISF_HIDEFOCUS);
+		}
+
+		const int iSelTab = TabCtrl_GetCurSel(hWnd);
+		const int nTabs = TabCtrl_GetItemCount(hWnd);
+		for (int i = 0; i < nTabs; ++i)
+		{
+			RECT rcItem{};
+			TabCtrl_GetItemRect(hWnd, i, &rcItem);
+			RECT rcFrame{ rcItem };
+
+			RECT rcIntersect{};
+			if (::IntersectRect(&rcIntersect, &rect, &rcItem) == TRUE)
+			{
+				const bool isHot = ::PtInRect(&rcItem, ptCursor) == TRUE;
+				const bool isSelectedTab = (i == iSelTab);
+
+				::SetBkMode(hdc, TRANSPARENT);
+
+				HRGN hClip = ::CreateRectRgnIndirect(&rcItem);
+				::SelectClipRgn(hdc, hClip);
+
+				::InflateRect(&rcItem, -1, -1);
+				rcItem.right += 1;
+
+				std::wstring label(MAX_PATH, L'\0');
+				TCITEM tci{};
+				tci.mask = TCIF_TEXT | TCIF_IMAGE | TCIF_STATE;
+				tci.dwStateMask = TCIS_HIGHLIGHTED;
+				tci.pszText = label.data();
+				tci.cchTextMax = MAX_PATH - 1;
+
+				TabCtrl_GetItem(hWnd, i, &tci);
+
+				const auto nStyle = ::GetWindowLongPtr(hWnd, GWL_STYLE);
+				const bool isBtn = (nStyle & TCS_BUTTONS) == TCS_BUTTONS;
+				if (isBtn)
+				{
+					const bool isHighlighted = (tci.dwState & TCIS_HIGHLIGHTED) == TCIS_HIGHLIGHTED;
+					::FillRect(hdc, &rcItem, isHighlighted ? DarkMode::getHotBackgroundBrush() : DarkMode::getDlgBackgroundBrush());
+					::SetTextColor(hdc, isHighlighted ? DarkMode::getLinkTextColor() : DarkMode::getDarkerTextColor());
+				}
+				else
+				{
+					// for consistency getBackgroundBrush()
+					// would be better, than getCtrlBackgroundBrush(),
+					// however default getBackgroundBrush() has same color
+					// as getDlgBackgroundBrush()
+					auto getBrush = [&]() -> HBRUSH {
+						if (isSelectedTab)
+						{
+							return DarkMode::getDlgBackgroundBrush();
+						}
+
+						if (isHot)
+						{
+							return DarkMode::getHotBackgroundBrush();
+						}
+						return DarkMode::getCtrlBackgroundBrush();
+					};
+
+					::FillRect(hdc, &rcItem, getBrush());
+					::SetTextColor(hdc, (isHot || isSelectedTab) ? DarkMode::getTextColor() : DarkMode::getDarkerTextColor());
+				}
+
+				RECT rcText{ rcItem };
+				if (!isBtn)
+				{
+					if (isSelectedTab)
+					{
+						::OffsetRect(&rcText, 0, -1);
+						::InflateRect(&rcFrame, 0, 1);
+					}
+
+					if (i != nTabs - 1)
+					{
+						rcFrame.right += 1;
+					}
+				}
+
+				if (tci.iImage != -1)
+				{
+					int cx = 0;
+					int cy = 0;
+					auto hImagelist = TabCtrl_GetImageList(hWnd);
+					static constexpr int offset = 2;
+					::ImageList_GetIconSize(hImagelist, &cx, &cy);
+					::ImageList_Draw(hImagelist, tci.iImage, hdc, rcText.left + offset, rcText.top + (((rcText.bottom - rcText.top) - cy) / 2), ILD_NORMAL);
+					rcText.left += cx;
+				}
+
+				::DrawText(hdc, label.c_str(), -1, &rcText, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
+
+				::FrameRect(hdc, &rcFrame, DarkMode::getEdgeBrush());
+
+				if (isSelectedTab && hasFocusRect)
+				{
+					::InflateRect(&rcFrame, -2, -1);
+					::DrawFocusRect(hdc, &rcFrame);
+				}
+
+				::SelectClipRgn(hdc, holdClip);
+				::DeleteObject(hClip);
+			}
+		}
+
+		::SelectObject(hdc, holdFont);
+		::SelectClipRgn(hdc, holdClip);
+		if (holdClip != nullptr)
+		{
+			::DeleteObject(holdClip);
+			holdClip = nullptr;
+		}
+		::SelectObject(hdc, holdPen);
+	}
+
+	/**
+	 * @brief Window subclass procedure for owner drawn tab control.
+	 *
+	 * @param hWnd Window handle being subclassed.
+	 * @param uMsg Message identifier.
+	 * @param wParam Message-specific data.
+	 * @param lParam Message-specific data.
+	 * @param uIdSubclass Subclass identifier.
+	 * @param dwRefData BufferData instance.
+	 * @return LRESULT Result of message processing.
+	 *
+	 * @see DarkMode::setTabCtrlPaintSubclass()
+	 * @see DarkMode::removeTabCtrlPaintSubclass()
+	 */
+	static LRESULT CALLBACK TabPaintSubclass(
+		HWND hWnd,
+		UINT uMsg,
+		WPARAM wParam,
+		LPARAM lParam,
+		UINT_PTR uIdSubclass,
+		DWORD_PTR dwRefData
+	)
+	{
+		auto* pTabBufferData = reinterpret_cast<BufferData*>(dwRefData);
+		const auto& hMemDC = pTabBufferData->getHMemDC();
+
+		switch (uMsg)
+		{
+			case WM_NCDESTROY:
+			{
+				::RemoveWindowSubclass(hWnd, TabPaintSubclass, uIdSubclass);
+				delete pTabBufferData;
+				break;
+			}
+
+			case WM_ERASEBKGND:
+			{
+				if (!DarkMode::isEnabled())
+				{
+					break;
+				}
+
+				const auto* hdc = reinterpret_cast<HDC>(wParam);
+				if (hdc != hMemDC)
+				{
+					return FALSE;
+				}
+				return TRUE;
+			}
+
+			case WM_PAINT:
+			{
+				if (!DarkMode::isEnabled())
+				{
+					break;
+				}
+
+				const auto nStyle = ::GetWindowLongPtr(hWnd, GWL_STYLE);
+				if ((nStyle & TCS_VERTICAL) == TCS_VERTICAL)
+				{
+					break;
+				}
+
+				PAINTSTRUCT ps{};
+				HDC hdc = ::BeginPaint(hWnd, &ps);
+
+				if (ps.rcPaint.right <= ps.rcPaint.left || ps.rcPaint.bottom <= ps.rcPaint.top)
+				{
+					::EndPaint(hWnd, &ps);
+					return 0;
+				}
+
+				RECT rcClient{};
+				::GetClientRect(hWnd, &rcClient);
+
+				if (pTabBufferData->ensureBuffer(hdc, rcClient))
+				{
+					const int savedState = ::SaveDC(hMemDC);
+					::IntersectClipRect(
+						hMemDC,
+						ps.rcPaint.left, ps.rcPaint.top, ps.rcPaint.right, ps.rcPaint.bottom
+					);
+
+					DarkMode::paintTab(hWnd, hMemDC, rcClient);
+
+					::RestoreDC(hMemDC, savedState);
+
+					::BitBlt(
+						hdc,
+						ps.rcPaint.left, ps.rcPaint.top,
+						ps.rcPaint.right - ps.rcPaint.left,
+						ps.rcPaint.bottom - ps.rcPaint.top,
+						hMemDC,
+						ps.rcPaint.left, ps.rcPaint.top,
+						SRCCOPY
+					);
+				}
+
+				::EndPaint(hWnd, &ps);
+				return 0;
+			}
+
+			case WM_UPDATEUISTATE:
+			{
+				if ((HIWORD(wParam) & (UISF_HIDEACCEL | UISF_HIDEFOCUS)) != 0)
+				{
+					::InvalidateRect(hWnd, nullptr, FALSE);
+				}
+				break;
+			}
+
+			default:
+			{
+				break;
+			}
+		}
+		return ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
+	}
+
+	static void setTabCtrlPaintSubclass(HWND hWnd)
+	{
+		DarkMode::setSubclass<BufferData>(hWnd, TabPaintSubclass, kTabPaintSubclassID);
+	}
+
+	static void removeTabCtrlPaintSubclass(HWND hWnd)
+	{
+		DarkMode::removeSubclass<BufferData>(hWnd, TabPaintSubclass, kTabPaintSubclassID);
+	}
+
+	/**
+	 * @brief Window subclass procedure for tab control's updown control subclassing.
+	 *
+	 * @param hWnd Window handle being subclassed.
+	 * @param uMsg Message identifier.
+	 * @param wParam Message-specific data.
+	 * @param lParam Message-specific data.
+	 * @param uIdSubclass Subclass identifier.
+	 * @param dwRefData Reserved data (unused).
+	 * @return LRESULT Result of message processing.
+	 *
+	 * @see DarkMode::setTabCtrlUpDownSubclass()
+	 * @see DarkMode::removeTabCtrlUpDownSubclass()
+	 */
+	static LRESULT CALLBACK TabUpDownSubclass(
+		HWND hWnd,
+		UINT uMsg,
+		WPARAM wParam,
+		LPARAM lParam,
+		UINT_PTR uIdSubclass,
+		[[maybe_unused]] DWORD_PTR dwRefData
+	)
+	{
+		switch (uMsg)
+		{
+			case WM_NCDESTROY:
+			{
+				::RemoveWindowSubclass(hWnd, TabUpDownSubclass, uIdSubclass);
+				break;
+			}
+
+			case WM_PARENTNOTIFY:
+			{
+				if (LOWORD(wParam) == WM_CREATE)
+				{
+					auto hUpDown = reinterpret_cast<HWND>(lParam);
+					if (CmpWndClassName(hUpDown, UPDOWN_CLASS))
+					{
+						DarkMode::setUpDownCtrlSubclass(hUpDown);
+						return 0;
+					}
+				}
+				break;
+			}
+
+			default:
+			{
+				break;
+			}
+		}
+		return ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
+	}
+
+	void setTabCtrlUpDownSubclass(HWND hWnd)
+	{
+		DarkMode::setSubclass(hWnd, TabUpDownSubclass, kTabUpDownSubclassID);
+	}
+
+	void removeTabCtrlUpDownSubclass(HWND hWnd)
+	{
+		DarkMode::removeSubclass(hWnd, TabUpDownSubclass, kTabUpDownSubclassID);
+	}
+
+	void setTabCtrlSubclass(HWND hWnd)
+	{
+		DarkMode::setTabCtrlPaintSubclass(hWnd);
+		DarkMode::setTabCtrlUpDownSubclass(hWnd);
+	}
+
+	void removeTabCtrlSubclass(HWND hWnd)
+	{
+		DarkMode::removeTabCtrlPaintSubclass(hWnd);
+		DarkMode::removeTabCtrlUpDownSubclass(hWnd);
+	}
+
+	static void setTabCtrlSubclassAndTheme(HWND hWnd, DarkModeParams p)
+	{
+		if (p._theme)
+		{
+			DarkMode::setDarkTooltips(hWnd, ToolTipsType::tabbar);
+		}
+
+		if (p._subclass)
+		{
+			DarkMode::setTabCtrlSubclass(hWnd);
+		}
+	}
+
+	struct BorderMetricsData
+	{
+		UINT _dpi = USER_DEFAULT_SCREEN_DPI;
+		LONG _xEdge = ::GetSystemMetrics(SM_CXEDGE);
+		LONG _yEdge = ::GetSystemMetrics(SM_CYEDGE);
+		LONG _xScroll = ::GetSystemMetrics(SM_CXVSCROLL);
+		LONG _yScroll = ::GetSystemMetrics(SM_CYVSCROLL);
+		bool _isHot = false;
+	};
+
+	static void ncPaintCustomBorder(HWND hWnd, const BorderMetricsData& borderMetricsData)
+	{
+		HDC hdc = ::GetWindowDC(hWnd);
+		RECT rcClient{};
+		::GetClientRect(hWnd, &rcClient);
+		rcClient.right += (2 * borderMetricsData._xEdge);
+
+		const auto nStyle = ::GetWindowLongPtr(hWnd, GWL_STYLE);
+		const bool hasVerScrollbar = (nStyle & WS_VSCROLL) == WS_VSCROLL;
+		if (hasVerScrollbar)
+		{
+			rcClient.right += borderMetricsData._xScroll;
+		}
+
+		rcClient.bottom += (2 * borderMetricsData._yEdge);
+
+		const bool hasHorScrollbar = (nStyle & WS_HSCROLL) == WS_HSCROLL;
+		if (hasHorScrollbar)
+		{
+			rcClient.bottom += borderMetricsData._yScroll;
+		}
+
+		HPEN hPen = ::CreatePen(PS_SOLID, 1, (::IsWindowEnabled(hWnd) == TRUE) ? DarkMode::getBackgroundColor() : DarkMode::getDlgBackgroundColor());
+		RECT rcInner{ rcClient };
+		::InflateRect(&rcInner, -1, -1);
+		DarkMode::paintRoundFrameRect(hdc, rcInner, hPen);
+		::DeleteObject(hPen);
+
+		POINT ptCursor{};
+		::GetCursorPos(&ptCursor);
+		::ScreenToClient(hWnd, &ptCursor);
+
+		const bool isHot = ::PtInRect(&rcClient, ptCursor) == TRUE;
+		const bool hasFocus = ::GetFocus() == hWnd;
+
+		HPEN hEnabledPen = ((borderMetricsData._isHot && isHot) || hasFocus ? DarkMode::getHotEdgePen() : DarkMode::getEdgePen());
+
+		DarkMode::paintRoundFrameRect(hdc, rcClient, (::IsWindowEnabled(hWnd) == TRUE) ? hEnabledPen : DarkMode::getDisabledEdgePen());
+
+		::ReleaseDC(hWnd, hdc);
+	}
+
+	/**
+	 * @brief Window subclass procedure for owner drawn border for list box and edit control.
+	 *
+	 * @param hWnd Window handle being subclassed.
+	 * @param uMsg Message identifier.
+	 * @param wParam Message-specific data.
+	 * @param lParam Message-specific data.
+	 * @param uIdSubclass Subclass identifier.
+	 * @param dwRefData BorderMetricsData instance.
+	 * @return LRESULT Result of message processing.
+	 *
+	 * @see DarkMode::setCustomBorderForListBoxOrEditCtrlSubclass()
+	 * @see DarkMode::removeCustomBorderForListBoxOrEditCtrlSubclass()
+	 */
+	static LRESULT CALLBACK CustomBorderSubclass(
+		HWND hWnd,
+		UINT uMsg,
+		WPARAM wParam,
+		LPARAM lParam,
+		UINT_PTR uIdSubclass,
+		DWORD_PTR dwRefData
+	)
+	{
+		auto* pBorderMetricsData = reinterpret_cast<BorderMetricsData*>(dwRefData);
+
+		switch (uMsg)
+		{
+			case WM_NCDESTROY:
+			{
+				::RemoveWindowSubclass(hWnd, CustomBorderSubclass, uIdSubclass);
+				delete pBorderMetricsData;
+				break;
+			}
+
+			case WM_NCPAINT:
+			{
+				if (!DarkMode::isEnabled())
+				{
+					break;
+				}
+
+				::DefSubclassProc(hWnd, uMsg, wParam, lParam);
+
+				DarkMode::ncPaintCustomBorder(hWnd, *pBorderMetricsData);
+
+				return 0;
+			}
+
+			case WM_NCCALCSIZE:
+			{
+				if (!DarkMode::isEnabled())
+				{
+					break;
+				}
+
+				auto* lpRect = reinterpret_cast<LPRECT>(lParam);
+				::InflateRect(lpRect, -(pBorderMetricsData->_xEdge), -(pBorderMetricsData->_yEdge));
+
+				break;
+			}
+
+			case WM_DPICHANGED:
+			case WM_DPICHANGED_AFTERPARENT:
+			{
+				DarkMode::redrawWindowFrame(hWnd);
+				return 0;
+			}
+
+			case WM_MOUSEMOVE:
+			{
+				if (!DarkMode::isEnabled())
+				{
+					break;
+				}
+
+				if (::GetFocus() == hWnd)
+				{
+					break;
+				}
+
+				TRACKMOUSEEVENT tme{};
+				tme.cbSize = sizeof(TRACKMOUSEEVENT);
+				tme.dwFlags = TME_LEAVE;
+				tme.hwndTrack = hWnd;
+				tme.dwHoverTime = HOVER_DEFAULT;
+				::TrackMouseEvent(&tme);
+
+				if (!pBorderMetricsData->_isHot)
+				{
+					pBorderMetricsData->_isHot = true;
+					DarkMode::redrawWindowFrame(hWnd);
+				}
+				break;
+			}
+
+			case WM_MOUSELEAVE:
+			{
+				if (!DarkMode::isEnabled())
+				{
+					break;
+				}
+
+				if (pBorderMetricsData->_isHot)
+				{
+					pBorderMetricsData->_isHot = false;
+					DarkMode::redrawWindowFrame(hWnd);
+				}
+
+				TRACKMOUSEEVENT tme{};
+				tme.cbSize = sizeof(TRACKMOUSEEVENT);
+				tme.dwFlags = TME_LEAVE | TME_CANCEL;
+				tme.hwndTrack = hWnd;
+				tme.dwHoverTime = HOVER_DEFAULT;
+				::TrackMouseEvent(&tme);
+				break;
+			}
+
+			default:
+			{
+				break;
+			}
+		}
+		return ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
+	}
+
+	void setCustomBorderForListBoxOrEditCtrlSubclass(HWND hWnd)
+	{
+		DarkMode::setSubclass<BorderMetricsData>(hWnd, CustomBorderSubclass, kCustomBorderSubclassID);
+	}
+
+	void removeCustomBorderForListBoxOrEditCtrlSubclass(HWND hWnd)
+	{
+		DarkMode::removeSubclass<BorderMetricsData>(hWnd, CustomBorderSubclass, kCustomBorderSubclassID);
+	}
+
+	static void setCustomBorderForListBoxOrEditCtrlSubclassAndTheme(HWND hWnd, DarkModeParams p, bool isListBox)
+	{
+		const auto nStyle = ::GetWindowLongPtr(hWnd, GWL_STYLE);
+		const bool hasScrollBar = ((nStyle & WS_HSCROLL) == WS_HSCROLL) || ((nStyle & WS_VSCROLL) == WS_VSCROLL);
+
+		// edit control without scroll bars
+		if (DarkMode::isThemePrefered()
+			&& p._theme
+			&& !isListBox
+			&& !hasScrollBar)
+		{
+			DarkMode::setDarkThemeExperimental(hWnd, L"CFD");
+		}
+		else
+		{
+			if (p._theme && (isListBox || hasScrollBar))
+			{
+				// dark scroll bars for list box or edit control
+				::SetWindowTheme(hWnd, p._themeClassName, nullptr);
+			}
+
+			const auto nExStyle = ::GetWindowLongPtr(hWnd, GWL_EXSTYLE);
+			const bool hasClientEdge = (nExStyle & WS_EX_CLIENTEDGE) == WS_EX_CLIENTEDGE;
+			const bool isCBoxListBox = isListBox && (nStyle & LBS_COMBOBOX) == LBS_COMBOBOX;
+
+			if (p._subclass && hasClientEdge && !isCBoxListBox)
+			{
+				DarkMode::setCustomBorderForListBoxOrEditCtrlSubclass(hWnd);
+			}
+
+			if (::GetWindowSubclass(hWnd, CustomBorderSubclass, kCustomBorderSubclassID, nullptr) == TRUE)
+			{
+				const bool enableClientEdge = !DarkMode::isEnabled();
+				DarkMode::setWindowExStyle(hWnd, enableClientEdge, WS_EX_CLIENTEDGE);
+			}
+		}
+	}
+
+	struct ComboBoxData
+	{
+		ThemeData _themeData{ VSCLASS_COMBOBOX };
+		BufferData _bufferData;
+
+		LONG_PTR _cbStyle = CBS_SIMPLE;
+
+		ComboBoxData() = delete;
+
+		explicit ComboBoxData(LONG_PTR cbStyle)
+			: _cbStyle(cbStyle)
+		{}
+	};
+
+	static void paintCombobox(HWND hWnd, HDC hdc, ComboBoxData& comboBoxData)
+	{
+		auto& themeData = comboBoxData._themeData;
+		const auto& hTheme = themeData.getHTheme();
+
+		const bool hasTheme = themeData.ensureTheme(hWnd);
+
+		COMBOBOXINFO cbi{};
+		cbi.cbSize = sizeof(COMBOBOXINFO);
+		::GetComboBoxInfo(hWnd, &cbi);
+
+		RECT rcClient{};
+		::GetClientRect(hWnd, &rcClient);
+
+		POINT ptCursor{};
+		::GetCursorPos(&ptCursor);
+		::ScreenToClient(hWnd, &ptCursor);
+
+		const bool isDisabled = ::IsWindowEnabled(hWnd) == FALSE;
+		const bool isHot = ::PtInRect(&rcClient, ptCursor) == TRUE && !isDisabled;
+
+		bool hasFocus = false;
+
+		::SelectObject(hdc, reinterpret_cast<HFONT>(::SendMessage(hWnd, WM_GETFONT, 0, 0)));
+		::SetBkMode(hdc, TRANSPARENT); // for non-theme DrawText
+
+		RECT rcArrow{ cbi.rcButton };
+		rcArrow.left -= 1;
+
+		auto getBrush = [&]() -> HBRUSH {
+			if (isDisabled)
+			{
+				return DarkMode::getDlgBackgroundBrush();
+			}
+
+			if (isHot)
+			{
+				return DarkMode::getHotBackgroundBrush();
+			}
+			return DarkMode::getCtrlBackgroundBrush();
+		};
+
+		HBRUSH hBrush = getBrush();
+
+		// Text part
+
+		// CBS_DROPDOWN and CBS_SIMPLE text is handled by parent by WM_CTLCOLOREDIT
+		if (comboBoxData._cbStyle == CBS_DROPDOWNLIST)
+		{
+			// erase background on item change
+			::FillRect(hdc, &rcClient, hBrush);
+
+			const auto index = static_cast<int>(::SendMessage(hWnd, CB_GETCURSEL, 0, 0));
+			if (index != CB_ERR)
+			{
+				const auto bufferLen = static_cast<size_t>(::SendMessage(hWnd, CB_GETLBTEXTLEN, static_cast<WPARAM>(index), 0));
+				std::wstring buffer(bufferLen + 1, L'\0');
+				::SendMessage(hWnd, CB_GETLBTEXT, static_cast<WPARAM>(index), reinterpret_cast<LPARAM>(buffer.data()));
+
+				RECT rcText{ cbi.rcItem };
+				::InflateRect(&rcText, -2, 0);
+
+				static constexpr DWORD dtFlags = DT_NOPREFIX | DT_LEFT | DT_VCENTER | DT_SINGLELINE;
+				if (hasTheme)
+				{
+					DTTOPTS dtto{};
+					dtto.dwSize = sizeof(DTTOPTS);
+					dtto.dwFlags = DTT_TEXTCOLOR;
+					dtto.crText = isDisabled ? DarkMode::getDisabledTextColor() : DarkMode::getTextColor();
+
+					::DrawThemeTextEx(hTheme, hdc, CP_DROPDOWNITEM, isDisabled ? CBXSR_DISABLED : CBXSR_NORMAL, buffer.c_str(), -1, dtFlags, &rcText, &dtto);
+				}
+				else
+				{
+					::SetTextColor(hdc, isDisabled ? DarkMode::getDisabledTextColor() : DarkMode::getTextColor());
+					::DrawText(hdc, buffer.c_str(), -1, &rcText, dtFlags);
+				}
+			}
+
+			hasFocus = ::GetFocus() == hWnd;
+			if (!isDisabled && hasFocus && ::SendMessage(hWnd, CB_GETDROPPEDSTATE, 0, 0) == FALSE)
+			{
+				::DrawFocusRect(hdc, &cbi.rcItem);
+			}
+		}
+		else if (cbi.hwndItem != nullptr)
+		{
+			hasFocus = ::GetFocus() == cbi.hwndItem;
+
+			::FillRect(hdc, &rcArrow, hBrush);
+		}
+
+		HPEN hPen = nullptr;
+		if (isDisabled)
+		{
+			hPen = DarkMode::getDisabledEdgePen();
+		}
+		else if ((isHot || hasFocus || comboBoxData._cbStyle == CBS_SIMPLE))
+		{
+			hPen = DarkMode::getHotEdgePen();
+		}
+		else
+		{
+			hPen = DarkMode::getEdgePen();
+		}
+		auto holdPen = static_cast<HPEN>(::SelectObject(hdc, hPen));
+
+		// Drop down arrow part
+		if (comboBoxData._cbStyle != CBS_SIMPLE)
+		{
+			if (hasTheme
+				&& (DarkMode::isExperimentalSupported()
+					|| g_dmCfg._dmType != DarkMode::DarkModeType::dark))
+			{
+				const RECT rcThemedArrow{ rcArrow.left, rcArrow.top - 1, rcArrow.right, rcArrow.bottom - 1 };
+				::DrawThemeBackground(hTheme, hdc, CP_DROPDOWNBUTTONRIGHT, isDisabled ? CBXSR_DISABLED : CBXSR_NORMAL, &rcThemedArrow, nullptr);
+			}
+			else
+			{
+				auto getTextClr = [&]() -> COLORREF {
+					if (isDisabled)
+					{
+						return DarkMode::getDisabledTextColor();
+					}
+
+					if (isHot)
+					{
+						return DarkMode::getTextColor();
+					}
+					return DarkMode::getDarkerTextColor();
+				};
+
+				::SetTextColor(hdc, getTextClr());
+				::DrawText(hdc, L"˅", -1, &rcArrow, DT_NOPREFIX | DT_CENTER | DT_VCENTER | DT_SINGLELINE | DT_NOCLIP);
+			}
+		}
+
+		// Frame part
+		if (comboBoxData._cbStyle == CBS_DROPDOWNLIST)
+		{
+			::ExcludeClipRect(hdc, rcClient.left + 1, rcClient.top + 1, rcClient.right - 1, rcClient.bottom - 1);
+		}
+		else
+		{
+			::ExcludeClipRect(hdc, cbi.rcItem.left, cbi.rcItem.top, cbi.rcItem.right, cbi.rcItem.bottom);
+
+			if (comboBoxData._cbStyle == CBS_SIMPLE && cbi.hwndList != nullptr)
+			{
+				RECT rcItem{ cbi.rcItem };
+				::MapWindowPoints(cbi.hwndItem, hWnd, reinterpret_cast<LPPOINT>(&rcItem), 2);
+				rcClient.bottom = rcItem.bottom;
+			}
+
+			RECT rcInner{ rcClient };
+			::InflateRect(&rcInner, -1, -1);
+
+			if (comboBoxData._cbStyle == CBS_DROPDOWN)
+			{
+				const std::array<POINT, 2> edge{ {
+					{ rcArrow.left - 1, rcArrow.top },
+					{ rcArrow.left - 1, rcArrow.bottom }
+				} };
+				::Polyline(hdc, edge.data(), static_cast<int>(edge.size()));
+
+				::ExcludeClipRect(hdc, rcArrow.left - 1, rcArrow.top, rcArrow.right, rcArrow.bottom);
+
+				rcInner.right = rcArrow.left - 1;
+			}
+
+			HPEN hInnerPen = ::CreatePen(PS_SOLID, 1, isDisabled ? DarkMode::getDlgBackgroundColor() : DarkMode::getBackgroundColor());
+			DarkMode::paintRoundFrameRect(hdc, rcInner, hInnerPen);
+			::DeleteObject(hInnerPen);
+			::InflateRect(&rcInner, -1, -1);
+			::FillRect(hdc, &rcInner, isDisabled ? DarkMode::getDlgBackgroundBrush() : DarkMode::getCtrlBackgroundBrush());
+		}
+
+		static const int roundness = DarkMode::isAtLeastWindows11() ? kWin11CornerRoundness : 0;
+		DarkMode::paintRoundFrameRect(hdc, rcClient, hPen, roundness, roundness);
+
+		::SelectObject(hdc, holdPen);
+	}
+
+	/**
+	 * @brief Window subclass procedure for owner drawn combo box control.
+	 *
+	 * @param hWnd Window handle being subclassed.
+	 * @param uMsg Message identifier.
+	 * @param wParam Message-specific data.
+	 * @param lParam Message-specific data.
+	 * @param uIdSubclass Subclass identifier.
+	 * @param dwRefData ComboBoxData instance.
+	 * @return LRESULT Result of message processing.
+	 *
+	 * @see DarkMode::setComboBoxCtrlSubclass()
+	 * @see DarkMode::removeComboBoxCtrlSubclass()
+	 */
+	static LRESULT CALLBACK ComboBoxSubclass(
+		HWND hWnd,
+		UINT uMsg,
+		WPARAM wParam,
+		LPARAM lParam,
+		UINT_PTR uIdSubclass,
+		DWORD_PTR dwRefData
+	)
+	{
+		auto* pComboboxData = reinterpret_cast<ComboBoxData*>(dwRefData);
+		auto& themeData = pComboboxData->_themeData;
+		auto& bufferData = pComboboxData->_bufferData;
+		const auto& hMemDC = bufferData.getHMemDC();
+
+		switch (uMsg)
+		{
+			case WM_NCDESTROY:
+			{
+				::RemoveWindowSubclass(hWnd, ComboBoxSubclass, uIdSubclass);
+				delete pComboboxData;
+				break;
+			}
+
+			case WM_ERASEBKGND:
+			{
+				if (!DarkMode::isEnabled() || !themeData.ensureTheme(hWnd))
+				{
+					break;
+				}
+
+				const auto* hdc = reinterpret_cast<HDC>(wParam);
+				if (pComboboxData->_cbStyle != CBS_DROPDOWN && hdc != hMemDC)
+				{
+					return FALSE;
+				}
+				return TRUE;
+			}
+
+			case WM_PAINT:
+			{
+				if (!DarkMode::isEnabled())
+				{
+					break;
+				}
+
+				PAINTSTRUCT ps{};
+				HDC hdc = ::BeginPaint(hWnd, &ps);
+
+				if (pComboboxData->_cbStyle != CBS_DROPDOWN)
+				{
+					if (ps.rcPaint.right <= ps.rcPaint.left || ps.rcPaint.bottom <= ps.rcPaint.top)
+					{
+						::EndPaint(hWnd, &ps);
+						return 0;
+					}
+
+					RECT rcClient{};
+					::GetClientRect(hWnd, &rcClient);
+
+					if (bufferData.ensureBuffer(hdc, rcClient))
+					{
+						const int savedState = ::SaveDC(hMemDC);
+						::IntersectClipRect(
+							hMemDC,
+							ps.rcPaint.left, ps.rcPaint.top, ps.rcPaint.right, ps.rcPaint.bottom
+						);
+
+						DarkMode::paintCombobox(hWnd, hMemDC, *pComboboxData);
+
+						::RestoreDC(hMemDC, savedState);
+
+						::BitBlt(
+							hdc,
+							ps.rcPaint.left, ps.rcPaint.top,
+							ps.rcPaint.right - ps.rcPaint.left,
+							ps.rcPaint.bottom - ps.rcPaint.top,
+							hMemDC,
+							ps.rcPaint.left, ps.rcPaint.top,
+							SRCCOPY
+						);
+					}
+				}
+				else
+				{
+					DarkMode::paintCombobox(hWnd, hdc, *pComboboxData);
+				}
+
+				::EndPaint(hWnd, &ps);
+				return 0;
+			}
+
+			case WM_ENABLE:
+			{
+				if (!DarkMode::isEnabled())
+				{
+					break;
+				}
+
+				const LRESULT retVal = ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
+				::RedrawWindow(hWnd, nullptr, nullptr, RDW_INVALIDATE);
+				return retVal;
+			}
+
+			case WM_DPICHANGED:
+			case WM_DPICHANGED_AFTERPARENT:
+			{
+				themeData.closeTheme();
+				return 0;
+			}
+
+			case WM_THEMECHANGED:
+			{
+				themeData.closeTheme();
+				break;
+			}
+
+			default:
+			{
+				break;
+			}
+		}
+		return ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
+	}
+
+	void setComboBoxCtrlSubclass(HWND hWnd)
+	{
+		const auto cbStyle = ::GetWindowLongPtr(hWnd, GWL_STYLE) & CBS_DROPDOWNLIST;
+		DarkMode::setSubclass<ComboBoxData>(hWnd, ComboBoxSubclass, kComboBoxSubclassID, cbStyle);
+	}
+
+	void removeComboBoxCtrlSubclass(HWND hWnd)
+	{
+		DarkMode::removeSubclass<ComboBoxData>(hWnd, ComboBoxSubclass, kComboBoxSubclassID);
+	}
+
+	static void setComboBoxCtrlSubclassAndTheme(HWND hWnd, DarkModeParams p)
+	{
+		const auto cbStyle = ::GetWindowLongPtr(hWnd, GWL_STYLE) & CBS_DROPDOWNLIST;
+		const bool isCbList = cbStyle == CBS_DROPDOWNLIST;
+		const bool isCbSimple = cbStyle == CBS_SIMPLE;
+
+		if (isCbList
+			|| cbStyle == CBS_DROPDOWN
+			|| isCbSimple)
+		{
+			COMBOBOXINFO cbi{};
+			cbi.cbSize = sizeof(COMBOBOXINFO);
+			if (::GetComboBoxInfo(hWnd, &cbi) == TRUE)
+			{
+				if (p._theme && cbi.hwndList != nullptr)
+				{
+					if (isCbSimple)
+					{
+						DarkMode::replaceClientEdgeWithBorderSafe(cbi.hwndList);
+					}
+
+					// dark scroll bar for list box of combo box
+					::SetWindowTheme(cbi.hwndList, p._themeClassName, nullptr);
+				}
+			}
+
+			if (!DarkMode::isThemePrefered() && p._subclass)
+			{
+				HWND hParent = ::GetParent(hWnd);
+				if ((hParent == nullptr || GetWndClassName(hParent) != WC_COMBOBOXEX))
+				{
+					DarkMode::setComboBoxCtrlSubclass(hWnd);
+				}
+			}
+
+			if (p._theme) // for light dropdown arrow in dark mode
+			{
+				DarkMode::setDarkThemeExperimental(hWnd, L"CFD");
+
+				if (!isCbList)
+				{
+					::SendMessage(hWnd, CB_SETEDITSEL, 0, 0); // clear selection
+				}
+			}
+		}
+	}
+
+	/**
+	 * @brief Window subclass procedure for custom color for combo box ex' list box and edit control.
+	 *
+	 * @param hWnd Window handle being subclassed.
+	 * @param uMsg Message identifier.
+	 * @param wParam Message-specific data.
+	 * @param lParam Message-specific data.
+	 * @param uIdSubclass Subclass identifier.
+	 * @param dwRefData Reserved data (unused).
+	 * @return LRESULT Result of message processing.
+	 *
+	 * @see DarkMode::setComboBoxExCtrlSubclass()
+	 * @see DarkMode::removeComboBoxExCtrlSubclass()
+	 */
+	static LRESULT CALLBACK ComboboxExSubclass(
+		HWND hWnd,
+		UINT uMsg,
+		WPARAM wParam,
+		LPARAM lParam,
+		UINT_PTR uIdSubclass,
+		[[maybe_unused]] DWORD_PTR dwRefData
+	)
+	{
+		switch (uMsg)
+		{
+			case WM_NCDESTROY:
+			{
+				::RemoveWindowSubclass(hWnd, ComboboxExSubclass, uIdSubclass);
+				DarkMode::unhookSysColor();
+				break;
+			}
+
+			case WM_ERASEBKGND:
+			{
+				if (!DarkMode::isEnabled())
+				{
+					break;
+				}
+
+				RECT rcClient{};
+				::GetClientRect(hWnd, &rcClient);
+				::FillRect(reinterpret_cast<HDC>(wParam), &rcClient, DarkMode::getDlgBackgroundBrush());
+				return TRUE;
+			}
+
+			case WM_CTLCOLOREDIT:
+			{
+				if (!DarkMode::isEnabled())
+				{
+					break;
+				}
+				return DarkMode::onCtlColorCtrl(reinterpret_cast<HDC>(wParam));
+			}
+
+			case WM_CTLCOLORLISTBOX:
+			{
+				if (!DarkMode::isEnabled())
+				{
+					break;
+				}
+				return DarkMode::onCtlColorListbox(wParam, lParam);
+			}
+
+			case WM_COMMAND:
+			{
+				if (!DarkMode::isEnabled())
+				{
+					break;
+				}
+
+				// ComboboxEx has only one child combo box, so only control-defined notification code is checked.
+				// Hooking is done only when list box is about to show. And unhook when list box is closed.
+				// This process is used to avoid visual glitches in other GUI.
+				switch (HIWORD(wParam))
+				{
+					case CBN_DROPDOWN:
+					{
+						DarkMode::hookSysColor();
+						break;
+					}
+
+					case CBN_CLOSEUP:
+					{
+						DarkMode::unhookSysColor();
+						break;
+					}
+
+					default:
+					{
+						break;
+					}
+				}
+				break;
+			}
+
+			default:
+			{
+				break;
+			}
+		}
+		return ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
+	}
+
+	void setComboBoxExCtrlSubclass(HWND hWnd)
+	{
+		DarkMode::setSubclass(hWnd, ComboboxExSubclass, kComboBoxExSubclassID);
+	}
+
+	void removeComboBoxExCtrlSubclass(HWND hWnd)
+	{
+		DarkMode::removeSubclass(hWnd, ComboboxExSubclass, kComboBoxExSubclassID);
+		DarkMode::unhookSysColor();
+	}
+
+	static void setComboBoxExCtrlSubclass(HWND hWnd, DarkModeParams p)
+	{
+		if (p._subclass)
+		{
+			DarkMode::setComboBoxExCtrlSubclass(hWnd);
+		}
+	}
+
+	/**
+	 * @brief Window subclass procedure for custom color for list view's gridlines and edit control.
+	 *
+	 * @param hWnd Window handle being subclassed.
+	 * @param uMsg Message identifier.
+	 * @param wParam Message-specific data.
+	 * @param lParam Message-specific data.
+	 * @param uIdSubclass Subclass identifier.
+	 * @param dwRefData Reserved data (unused).
+	 * @return LRESULT Result of message processing.
+	 *
+	 * @see DarkMode::setListViewCtrlSubclass()
+	 * @see DarkMode::removeListViewCtrlSubclass()
+	 */
+	static LRESULT CALLBACK ListViewSubclass(
+		HWND hWnd,
+		UINT uMsg,
+		WPARAM wParam,
+		LPARAM lParam,
+		UINT_PTR uIdSubclass,
+		[[maybe_unused]] DWORD_PTR dwRefData
+	)
+	{
+		switch (uMsg)
+		{
+			case WM_NCDESTROY:
+			{
+				::RemoveWindowSubclass(hWnd, ListViewSubclass, uIdSubclass);
+				DarkMode::unhookSysColor();
+				break;
+			}
+
+			case WM_PAINT:
+			{
+				if (!DarkMode::isEnabled())
+				{
+					break;
+				}
+
+				const auto lvStyle = ::GetWindowLongPtr(hWnd, GWL_STYLE) & LVS_TYPEMASK;
+				const bool isReport = (lvStyle == LVS_REPORT);
+				bool hasGridlines = false;
+				if (isReport)
+				{
+					const auto lvExStyle = ListView_GetExtendedListViewStyle(hWnd);
+					hasGridlines = (lvExStyle & LVS_EX_GRIDLINES) == LVS_EX_GRIDLINES;
+				}
+
+				if (hasGridlines)
+				{
+					DarkMode::hookSysColor();
+					const LRESULT retVal = ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
+					DarkMode::unhookSysColor();
+					return retVal;
+				}
+				break;
+			}
+
+			// For edit control, which is created when renaming/editing items
+			case WM_CTLCOLOREDIT:
+			{
+				if (!DarkMode::isEnabled())
+				{
+					break;
+				}
+				return DarkMode::onCtlColorCtrl(reinterpret_cast<HDC>(wParam));
+			}
+
+			case WM_NOTIFY:
+			{
+				if (!DarkMode::isEnabled())
+				{
+					break;
+				}
+
+				if (reinterpret_cast<LPNMHDR>(lParam)->code == NM_CUSTOMDRAW)
+				{
+					auto* lpnmcd = reinterpret_cast<LPNMCUSTOMDRAW>(lParam);
+					switch (lpnmcd->dwDrawStage)
+					{
+						case CDDS_PREPAINT:
+						{
+							if (DarkMode::isExperimentalActive())
+							{
+								return CDRF_NOTIFYITEMDRAW;
+							}
+							return CDRF_DODEFAULT;
+						}
+
+						case CDDS_ITEMPREPAINT:
+						{
+							::SetTextColor(lpnmcd->hdc, DarkMode::getDarkerTextColor());
+
+							return CDRF_NEWFONT;
+						}
+
+						default:
+						{
+							return CDRF_DODEFAULT;
+						}
+					}
+				}
+				break;
+			}
+
+			default:
+			{
+				break;
+			}
+		}
+		return ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
+	}
+
+	void setListViewCtrlSubclass(HWND hWnd)
+	{
+		DarkMode::setSubclass(hWnd, ListViewSubclass, kListViewSubclassID);
+	}
+
+	void removeListViewCtrlSubclass(HWND hWnd)
+	{
+		DarkMode::removeSubclass(hWnd, ListViewSubclass, kListViewSubclassID);
+	}
+
+	static void setListViewCtrlSubclassAndTheme(HWND hWnd, DarkModeParams p)
+	{
+		HWND hHeader = ListView_GetHeader(hWnd);
+
+		if (p._theme)
+		{
+			ListView_SetTextColor(hWnd, DarkMode::getViewTextColor());
+			ListView_SetTextBkColor(hWnd, DarkMode::getViewBackgroundColor());
+			ListView_SetBkColor(hWnd, DarkMode::getViewBackgroundColor());
+
+			DarkMode::setDarkListView(hWnd);
+			DarkMode::setDarkListViewCheckboxes(hWnd);
+			DarkMode::setDarkTooltips(hWnd, DarkMode::ToolTipsType::listview);
+
+			if (DarkMode::isThemePrefered())
+			{
+				DarkMode::setDarkThemeExperimental(hHeader, L"ItemsView");
+			}
+		}
+
+		if (p._subclass)
+		{
+			if (!DarkMode::isThemePrefered())
+			{
+				DarkMode::setHeaderCtrlSubclass(hHeader);
+			}
+
+			const auto lvExStyle = ListView_GetExtendedListViewStyle(hWnd);
+			ListView_SetExtendedListViewStyle(hWnd, lvExStyle | LVS_EX_DOUBLEBUFFER);
+			DarkMode::setListViewCtrlSubclass(hWnd);
+		}
+	}
+
+	struct HeaderData
+	{
+		ThemeData _themeData{ VSCLASS_HEADER };
+		BufferData _bufferData;
+		FontData _fontData{ nullptr };
+
+		POINT _pt{ LONG_MIN, LONG_MIN };
+		bool _isHot = false;
+		bool _hasBtnStyle = true;
+		bool _isPressed = false;
+
+		HeaderData() = delete;
+
+		explicit HeaderData(bool hasBtnStyle)
+			: _hasBtnStyle(hasBtnStyle)
+		{}
+	};
+
+	static void paintHeader(HWND hWnd, HDC hdc, HeaderData& headerData)
+	{
+		auto& themeData = headerData._themeData;
+		const auto& hTheme = themeData.getHTheme();
+		const bool hasTheme = themeData.ensureTheme(hWnd);
+		auto& fontData = headerData._fontData;
+
+		::SetBkMode(hdc, TRANSPARENT);
+		auto holdPen = static_cast<HPEN>(::SelectObject(hdc, DarkMode::getHeaderEdgePen()));
+
+		RECT rcHeader{};
+		::GetClientRect(hWnd, &rcHeader);
+		::FillRect(hdc, &rcHeader, DarkMode::getHeaderBackgroundBrush());
+
+		LOGFONT lf{};
+		if (!fontData.hasFont()
+			&& hasTheme
+			&& SUCCEEDED(::GetThemeFont(hTheme, hdc, HP_HEADERITEM, HIS_NORMAL, TMT_FONT, &lf)))
+		{
+			fontData.setFont(::CreateFontIndirect(&lf));
+		}
+
+		HFONT hFont = (fontData.hasFont()) ? fontData.getFont() : reinterpret_cast<HFONT>(::SendMessage(hWnd, WM_GETFONT, 0, 0));
+		auto holdFont = static_cast<HFONT>(::SelectObject(hdc, hFont));
+
+		DTTOPTS dtto{};
+		if (hasTheme)
+		{
+			dtto.dwSize = sizeof(DTTOPTS);
+			dtto.dwFlags = DTT_TEXTCOLOR;
+			dtto.crText = DarkMode::getHeaderTextColor();
+		}
+		else
+		{
+			::SetTextColor(hdc, DarkMode::getHeaderTextColor());
+		}
+
+		HWND hList = ::GetParent(hWnd);
+		const auto lvStyle = ::GetWindowLongPtr(hList, GWL_STYLE) & LVS_TYPEMASK;
+		bool hasGridlines = false;
+		if (lvStyle == LVS_REPORT)
+		{
+			const auto lvExStyle = ListView_GetExtendedListViewStyle(hList);
+			hasGridlines = (lvExStyle & LVS_EX_GRIDLINES) == LVS_EX_GRIDLINES;
+		}
+
+		const int count = Header_GetItemCount(hWnd);
+		RECT rcItem{};
+		for (int i = 0; i < count; i++)
+		{
+			Header_GetItemRect(hWnd, i, &rcItem);
+			const bool isOnItem = ::PtInRect(&rcItem, headerData._pt) == TRUE;
+
+			if (headerData._hasBtnStyle && isOnItem)
+			{
+				RECT rcTmp{ rcItem };
+				if (hasGridlines)
+				{
+					::OffsetRect(&rcTmp, 1, 0);
+				}
+				else if (DarkMode::isExperimentalActive())
+				{
+					::OffsetRect(&rcTmp, -1, 0);
+				}
+				::FillRect(hdc, &rcTmp, DarkMode::getHeaderHotBackgroundBrush());
+			}
+
+			std::wstring buffer(MAX_PATH, L'\0');
+			HDITEM hdi{};
+			hdi.mask = HDI_TEXT | HDI_FORMAT;
+			hdi.pszText = buffer.data();
+			hdi.cchTextMax = MAX_PATH - 1;
+
+			Header_GetItem(hWnd, i, &hdi);
+
+			if (hasTheme
+				&& ((hdi.fmt & HDF_SORTUP) == HDF_SORTUP
+					|| (hdi.fmt & HDF_SORTDOWN) == HDF_SORTDOWN))
+			{
+				const int iStateID = ((hdi.fmt & HDF_SORTUP) == HDF_SORTUP) ? HSAS_SORTEDUP : HSAS_SORTEDDOWN;
+				RECT rcArrow{ rcItem };
+				SIZE szArrow{};
+				if (SUCCEEDED(::GetThemePartSize(hTheme, hdc, HP_HEADERSORTARROW, iStateID, nullptr, TS_DRAW, &szArrow)))
+				{
+					rcArrow.bottom = szArrow.cy;
+				}
+
+				::DrawThemeBackground(hTheme, hdc, HP_HEADERSORTARROW, iStateID, &rcArrow, nullptr);
+			}
+
+			LONG edgeX = rcItem.right;
+			if (!hasGridlines)
+			{
+				--edgeX;
+				if (DarkMode::isExperimentalActive())
+				{
+					--edgeX;
+				}
+			}
+
+			const std::array<POINT, 2> edge{ {
+				{ edgeX, rcItem.top },
+				{ edgeX, rcItem.bottom }
+			} };
+			::Polyline(hdc, edge.data(), static_cast<int>(edge.size()));
+
+			DWORD dtFlags = DT_VCENTER | DT_SINGLELINE | DT_WORD_ELLIPSIS | DT_HIDEPREFIX;
+			if ((hdi.fmt & HDF_RIGHT) == HDF_RIGHT)
+			{
+				dtFlags |= DT_RIGHT;
+			}
+			else if ((hdi.fmt & HDF_CENTER) == HDF_CENTER)
+			{
+				dtFlags |= DT_CENTER;
+			}
+
+			static constexpr LONG lOffset = 6;
+			static constexpr LONG rOffset = 8;
+
+			rcItem.left += lOffset;
+			rcItem.right -= rOffset;
+
+			if (headerData._isPressed && isOnItem)
+			{
+				::OffsetRect(&rcItem, 1, 1);
+			}
+
+			if (hasTheme)
+			{
+				::DrawThemeTextEx(hTheme, hdc, HP_HEADERITEM, HIS_NORMAL, hdi.pszText, -1, dtFlags, &rcItem, &dtto);
+			}
+			else
+			{
+				::DrawText(hdc, hdi.pszText, -1, &rcItem, dtFlags);
+			}
+		}
+
+		::SelectObject(hdc, holdFont);
+		::SelectObject(hdc, holdPen);
+	}
+
+	/**
+	 * @brief Window subclass procedure for owner drawn header control.
+	 *
+	 * @param hWnd Window handle being subclassed.
+	 * @param uMsg Message identifier.
+	 * @param wParam Message-specific data.
+	 * @param lParam Message-specific data.
+	 * @param uIdSubclass Subclass identifier.
+	 * @param dwRefData HeaderData instance.
+	 * @return LRESULT Result of message processing.
+	 *
+	 * @see DarkMode::setHeaderCtrlSubclass()
+	 * @see DarkMode::removeHeaderCtrlSubclass()
+	 */
+	static LRESULT CALLBACK HeaderSubclass(
+		HWND hWnd,
+		UINT uMsg,
+		WPARAM wParam,
+		LPARAM lParam,
+		UINT_PTR uIdSubclass,
+		DWORD_PTR dwRefData
+	)
+	{
+		auto* pHeaderData = reinterpret_cast<HeaderData*>(dwRefData);
+		auto& themeData = pHeaderData->_themeData;
+		auto& bufferData = pHeaderData->_bufferData;
+		const auto& hMemDC = bufferData.getHMemDC();
+
+		switch (uMsg)
+		{
+			case WM_NCDESTROY:
+			{
+				::RemoveWindowSubclass(hWnd, HeaderSubclass, uIdSubclass);
+				delete pHeaderData;
+				break;
+			}
+
+			case WM_ERASEBKGND:
+			{
+				if (!DarkMode::isEnabled() || !themeData.ensureTheme(hWnd))
+				{
+					break;
+				}
+
+				const auto* hdc = reinterpret_cast<HDC>(wParam);
+				if (hdc != hMemDC)
+				{
+					return FALSE;
+				}
+				return TRUE;
+			}
+
+			case WM_PAINT:
+			{
+				if (!DarkMode::isEnabled())
+				{
+					break;
+				}
+
+				PAINTSTRUCT ps{};
+				HDC hdc = ::BeginPaint(hWnd, &ps);
+
+				if (ps.rcPaint.right <= ps.rcPaint.left || ps.rcPaint.bottom <= ps.rcPaint.top)
+				{
+					::EndPaint(hWnd, &ps);
+					return 0;
+				}
+
+				RECT rcClient{};
+				::GetClientRect(hWnd, &rcClient);
+
+				if (bufferData.ensureBuffer(hdc, rcClient))
+				{
+					const int savedState = ::SaveDC(hMemDC);
+					::IntersectClipRect(
+						hMemDC,
+						ps.rcPaint.left, ps.rcPaint.top, ps.rcPaint.right, ps.rcPaint.bottom
+					);
+
+					DarkMode::paintHeader(hWnd, hMemDC, *pHeaderData);
+
+					::RestoreDC(hMemDC, savedState);
+
+					::BitBlt(
+						hdc,
+						ps.rcPaint.left, ps.rcPaint.top,
+						ps.rcPaint.right - ps.rcPaint.left,
+						ps.rcPaint.bottom - ps.rcPaint.top,
+						hMemDC,
+						ps.rcPaint.left, ps.rcPaint.top,
+						SRCCOPY
+					);
+				}
+
+				::EndPaint(hWnd, &ps);
+				return 0;
+			}
+
+			case WM_DPICHANGED:
+			case WM_DPICHANGED_AFTERPARENT:
+			{
+				themeData.closeTheme();
+				return 0;
+			}
+
+			case WM_THEMECHANGED:
+			{
+				themeData.closeTheme();
+				break;
+			}
+
+			case WM_LBUTTONDOWN:
+			{
+				if (!pHeaderData->_hasBtnStyle)
+				{
+					break;
+				}
+
+				pHeaderData->_isPressed = true;
+				break;
+			}
+
+			case WM_LBUTTONUP:
+			{
+				if (!pHeaderData->_hasBtnStyle)
+				{
+					break;
+				}
+
+				pHeaderData->_isPressed = false;
+				break;
+			}
+
+			case WM_MOUSEMOVE:
+			{
+				if (!pHeaderData->_hasBtnStyle || pHeaderData->_isPressed)
+				{
+					break;
+				}
+
+				TRACKMOUSEEVENT tme{};
+
+				if (!pHeaderData->_isHot)
+				{
+					tme.cbSize = sizeof(TRACKMOUSEEVENT);
+					tme.dwFlags = TME_LEAVE;
+					tme.hwndTrack = hWnd;
+
+					::TrackMouseEvent(&tme);
+
+					pHeaderData->_isHot = true;
+				}
+
+				pHeaderData->_pt.x = GET_X_LPARAM(lParam);
+				pHeaderData->_pt.y = GET_Y_LPARAM(lParam);
+
+				::InvalidateRect(hWnd, nullptr, FALSE);
+				break;
+			}
+
+			case WM_MOUSELEAVE:
+			{
+				if (!pHeaderData->_hasBtnStyle)
+				{
+					break;
+				}
+
+				const LRESULT retVal = ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
+
+				pHeaderData->_isHot = false;
+				pHeaderData->_pt.x = LONG_MIN;
+				pHeaderData->_pt.y = LONG_MIN;
+
+				::InvalidateRect(hWnd, nullptr, TRUE);
+
+				return retVal;
+			}
+
+			default:
+			{
+				break;
+			}
+		}
+		return ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
+	}
+
+	void setHeaderCtrlSubclass(HWND hWnd)
+	{
+		const bool hasBtnStyle = (::GetWindowLongPtr(hWnd, GWL_STYLE) & HDS_BUTTONS) == HDS_BUTTONS;
+		DarkMode::setSubclass<HeaderData>(hWnd, HeaderSubclass, kHeaderSubclassID, hasBtnStyle);
+	}
+
+	void removeHeaderCtrlSubclass(HWND hWnd)
+	{
+		DarkMode::removeSubclass<HeaderData>(hWnd, HeaderSubclass, kHeaderSubclassID);
+	}
+
+	struct StatusBarData
+	{
+		ThemeData _themeData{ VSCLASS_STATUS };
+		BufferData _bufferData;
+		FontData _fontData;
+
+		StatusBarData() = delete;
+
+		explicit StatusBarData(const HFONT& hFont)
+			: _fontData(hFont)
+		{}
+	};
+
+	static void paintStatusBar(HWND hWnd, HDC hdc, StatusBarData& statusBarData)
+	{
+		const auto& hFont = statusBarData._fontData.getFont();
+
+		struct {
+			int horizontal = 0;
+			int vertical = 0;
+			int between = 0;
+		} borders{};
+
+		::SendMessage(hWnd, SB_GETBORDERS, 0, reinterpret_cast<LPARAM>(&borders));
+
+		const auto nStyle = ::GetWindowLongPtr(hWnd, GWL_STYLE);
+		const bool hasSizeGrip = (nStyle & SBARS_SIZEGRIP) == SBARS_SIZEGRIP;
+
+		auto holdPen = static_cast<HPEN>(::SelectObject(hdc, DarkMode::getEdgePen()));
+		auto holdFont = static_cast<HFONT>(::SelectObject(hdc, hFont));
+
+		::SetBkMode(hdc, TRANSPARENT);
+		::SetTextColor(hdc, DarkMode::getTextColor());
+
+		RECT rcClient{};
+		::GetClientRect(hWnd, &rcClient);
+
+		::FillRect(hdc, &rcClient, DarkMode::getBackgroundBrush());
+
+		const auto nParts = static_cast<int>(::SendMessage(hWnd, SB_GETPARTS, 0, 0));
+		std::wstring str;
+		RECT rcPart{};
+		RECT rcIntersect{};
+		const int iLastDiv = nParts - (hasSizeGrip ? 1 : 0);
+		const bool drawEdge = (nParts >= 2 || !hasSizeGrip);
+		for (int i = 0; i < nParts; ++i)
+		{
+			::SendMessage(hWnd, SB_GETRECT, static_cast<WPARAM>(i), reinterpret_cast<LPARAM>(&rcPart));
+			if (::IntersectRect(&rcIntersect, &rcPart, &rcClient) == FALSE)
+			{
+				continue;
+			}
+
+			if (drawEdge && (i < iLastDiv))
+			{
+				const std::array<POINT, 2> edges{ {
+					{ rcPart.right - borders.between, rcPart.top + 1 },
+					{ rcPart.right - borders.between, rcPart.bottom - 3 }
+				} };
+				::Polyline(hdc, edges.data(), static_cast<int>(edges.size()));
+			}
+
+			rcPart.left += borders.between;
+			rcPart.right -= borders.vertical;
+
+			const LRESULT retValLen = ::SendMessage(hWnd, SB_GETTEXTLENGTH, static_cast<WPARAM>(i), 0);
+			const DWORD cchText = LOWORD(retValLen);
+
+			str.resize(static_cast<size_t>(cchText) + 1);
+			const LRESULT retValText = ::SendMessage(hWnd, SB_GETTEXT, static_cast<WPARAM>(i), reinterpret_cast<LPARAM>(str.data()));
+
+			if (cchText == 0 && (HIWORD(retValLen) & SBT_OWNERDRAW) != 0)
+			{
+				const auto id = static_cast<UINT>(::GetDlgCtrlID(hWnd));
+				DRAWITEMSTRUCT dis{
+					0
+					, 0
+					, static_cast<UINT>(i)
+					, ODA_DRAWENTIRE
+					, id
+					, hWnd
+					, hdc
+					, rcPart
+					, static_cast<ULONG_PTR>(retValText)
+				};
+
+				::SendMessage(::GetParent(hWnd), WM_DRAWITEM, id, reinterpret_cast<LPARAM>(&dis));
+			}
+			else
+			{
+				::DrawText(hdc, str.c_str(), -1, &rcPart, DT_SINGLELINE | DT_VCENTER | DT_LEFT);
+			}
+		}
+
+#if 0 // for horizontal edge
+		POINT edgeHor[]{
+			{rcClient.left, rcClient.top},
+			{rcClient.right, rcClient.top}
+		};
+		Polyline(hdc, edgeHor, _countof(edgeHor));
+#endif
+
+		if (hasSizeGrip)
+		{
+			auto& themeData = statusBarData._themeData;
+			const auto& hTheme = themeData.getHTheme();
+			const bool hasTheme = themeData.ensureTheme(hWnd);
+			if (hasTheme)
+			{
+				SIZE szGrip{};
+				::GetThemePartSize(hTheme, hdc, SP_GRIPPER, 0, &rcClient, TS_DRAW, &szGrip);
+				RECT rcGrip{ rcClient };
+				rcGrip.left = rcGrip.right - szGrip.cx;
+				rcGrip.top = rcGrip.bottom - szGrip.cy;
+				::DrawThemeBackground(hTheme, hdc, SP_GRIPPER, 0, &rcGrip, nullptr);
+			}
+		}
+
+		::SelectObject(hdc, holdFont);
+		::SelectObject(hdc, holdPen);
+	}
+
+	/**
+	 * @brief Window subclass procedure for owner drawn status bar control.
+	 *
+	 * @param hWnd Window handle being subclassed.
+	 * @param uMsg Message identifier.
+	 * @param wParam Message-specific data.
+	 * @param lParam Message-specific data.
+	 * @param uIdSubclass Subclass identifier.
+	 * @param dwRefData StatusBarData instance.
+	 * @return LRESULT Result of message processing.
+	 *
+	 * @see DarkMode::setStatusBarCtrlSubclass()
+	 * @see DarkMode::removeStatusBarCtrlSubclass()
+	 */
+	static LRESULT CALLBACK StatusBarSubclass(
+		HWND hWnd,
+		UINT uMsg,
+		WPARAM wParam,
+		LPARAM lParam,
+		UINT_PTR uIdSubclass,
+		DWORD_PTR dwRefData)
+	{
+		auto* pStatusBarData = reinterpret_cast<StatusBarData*>(dwRefData);
+		auto& themeData = pStatusBarData->_themeData;
+		auto& bufferData = pStatusBarData->_bufferData;
+		const auto& hMemDC = bufferData.getHMemDC();
+
+		switch (uMsg)
+		{
+			case WM_NCDESTROY:
+			{
+				::RemoveWindowSubclass(hWnd, StatusBarSubclass, uIdSubclass);
+				delete pStatusBarData;
+				break;
+			}
+
+			case WM_ERASEBKGND:
+			{
+				if (!DarkMode::isEnabled() || !themeData.ensureTheme(hWnd))
+				{
+					break;
+				}
+
+				const auto* hdc = reinterpret_cast<HDC>(wParam);
+				if (hdc != hMemDC)
+				{
+					return FALSE;
+				}
+				return TRUE;
+			}
+
+			case WM_PAINT:
+			{
+				if (!DarkMode::isEnabled())
+				{
+					break;
+				}
+
+				PAINTSTRUCT ps{};
+				HDC hdc = ::BeginPaint(hWnd, &ps);
+
+				if (ps.rcPaint.right <= ps.rcPaint.left || ps.rcPaint.bottom <= ps.rcPaint.top)
+				{
+					::EndPaint(hWnd, &ps);
+					return 0;
+				}
+
+				RECT rcClient{};
+				::GetClientRect(hWnd, &rcClient);
+
+				if (bufferData.ensureBuffer(hdc, rcClient))
+				{
+					const int savedState = ::SaveDC(hMemDC);
+					::IntersectClipRect(
+						hMemDC,
+						ps.rcPaint.left, ps.rcPaint.top, ps.rcPaint.right, ps.rcPaint.bottom
+					);
+
+					DarkMode::paintStatusBar(hWnd, hMemDC, *pStatusBarData);
+
+					::RestoreDC(hMemDC, savedState);
+
+					::BitBlt(
+						hdc,
+						ps.rcPaint.left, ps.rcPaint.top,
+						ps.rcPaint.right - ps.rcPaint.left,
+						ps.rcPaint.bottom - ps.rcPaint.top,
+						hMemDC,
+						ps.rcPaint.left, ps.rcPaint.top,
+						SRCCOPY
+					);
+				}
+
+				::EndPaint(hWnd, &ps);
+				return 0;
+			}
+
+			case WM_DPICHANGED:
+			case WM_DPICHANGED_AFTERPARENT:
+			case WM_THEMECHANGED:
+			{
+				themeData.closeTheme();
+
+				LOGFONT lf{};
+				NONCLIENTMETRICS ncm{};
+				ncm.cbSize = sizeof(NONCLIENTMETRICS);
+				if (::SystemParametersInfoW(SPI_GETNONCLIENTMETRICS, sizeof(NONCLIENTMETRICS), &ncm, 0) != FALSE)
+				{
+					lf = ncm.lfStatusFont;
+					pStatusBarData->_fontData.setFont(::CreateFontIndirect(&lf));
+				}
+
+				if (uMsg != WM_THEMECHANGED)
+				{
+					return 0;
+				}
+				break;
+			}
+
+			default:
+			{
+				break;
+			}
+		}
+		return ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
+	}
+
+	void setStatusBarCtrlSubclass(HWND hWnd)
+	{
+		LOGFONT lf{};
+		NONCLIENTMETRICS ncm{};
+		ncm.cbSize = sizeof(NONCLIENTMETRICS);
+		if (::SystemParametersInfoW(SPI_GETNONCLIENTMETRICS, sizeof(NONCLIENTMETRICS), &ncm, 0) != FALSE)
+		{
+			lf = ncm.lfStatusFont;
+		}
+		DarkMode::setSubclass<StatusBarData>(hWnd, StatusBarSubclass, kStatusBarSubclassID, ::CreateFontIndirect(&lf));
+	}
+
+	void removeStatusBarCtrlSubclass(HWND hWnd)
+	{
+		DarkMode::removeSubclass<StatusBarData>(hWnd, StatusBarSubclass, kStatusBarSubclassID);
+	}
+
+	static void setStatusBarCtrlSubclass(HWND hWnd, DarkModeParams p)
+	{
+		if (p._subclass)
+		{
+			DarkMode::setStatusBarCtrlSubclass(hWnd);
+		}
+	}
+
+	struct ProgressBarData
+	{
+		ThemeData _themeData{ VSCLASS_PROGRESS };
+		BufferData _bufferData;
+
+		int _iStateID = PBFS_PARTIAL;
+
+		explicit ProgressBarData(HWND hWnd)
+			: _iStateID(static_cast<int>(::SendMessage(hWnd, PBM_GETSTATE, 0, 0)))
+		{}
+	};
+
+	static void getProgressBarRects(HWND hWnd, RECT* rcEmpty, RECT* rcFilled)
+	{
+		const auto pos = static_cast<int>(::SendMessage(hWnd, PBM_GETPOS, 0, 0));
+
+		PBRANGE range{};
+		::SendMessage(hWnd, PBM_GETRANGE, TRUE, reinterpret_cast<LPARAM>(&range));
+		const int iMin = range.iLow;
+
+		const int currPos = pos - iMin;
+		if (currPos != 0)
+		{
+			const int totalWidth = rcEmpty->right - rcEmpty->left;
+			rcFilled->left = rcEmpty->left;
+			rcFilled->top = rcEmpty->top;
+			rcFilled->bottom = rcEmpty->bottom;
+			rcFilled->right = rcEmpty->left + static_cast<int>(static_cast<double>(currPos) / (range.iHigh - iMin) * totalWidth);
+
+			rcEmpty->left = rcFilled->right; // to avoid painting under filled part
+		}
+	}
+
+	static void paintProgressBar(HWND hWnd, HDC hdc, const ProgressBarData& progressBarData)
+	{
+		const auto& hTheme = progressBarData._themeData.getHTheme();
+
+		RECT rcClient{};
+		::GetClientRect(hWnd, &rcClient);
+
+		DarkMode::paintRoundFrameRect(hdc, rcClient, DarkMode::getEdgePen(), 0, 0);
+
+		::InflateRect(&rcClient, -1, -1);
+		rcClient.left = 1;
+
+		RECT rcFill{};
+		DarkMode::getProgressBarRects(hWnd, &rcClient, &rcFill);
+		::DrawThemeBackground(hTheme, hdc, PP_FILL, progressBarData._iStateID, &rcFill, nullptr);
+		::FillRect(hdc, &rcClient, DarkMode::getCtrlBackgroundBrush());
+	}
+
+	/**
+	 * @brief Window subclass procedure for owner drawn progress bar control.
+	 *
+	 * @param hWnd Window handle being subclassed.
+	 * @param uMsg Message identifier.
+	 * @param wParam Message-specific data.
+	 * @param lParam Message-specific data.
+	 * @param uIdSubclass Subclass identifier.
+	 * @param dwRefData ProgressBarData instance.
+	 * @return LRESULT Result of message processing.
+	 *
+	 * @see DarkMode::setProgressBarCtrlSubclass()
+	 * @see DarkMode::removeProgressBarCtrlSubclass()
+	 */
+	static LRESULT CALLBACK ProgressBarSubclass(
+		HWND hWnd,
+		UINT uMsg,
+		WPARAM wParam,
+		LPARAM lParam,
+		UINT_PTR uIdSubclass,
+		DWORD_PTR dwRefData
+	)
+	{
+		auto* pProgressBarData = reinterpret_cast<ProgressBarData*>(dwRefData);
+		auto& themeData = pProgressBarData->_themeData;
+		auto& bufferData = pProgressBarData->_bufferData;
+		const auto& hMemDC = bufferData.getHMemDC();
+
+		switch (uMsg)
+		{
+			case WM_NCDESTROY:
+			{
+				::RemoveWindowSubclass(hWnd, ProgressBarSubclass, uIdSubclass);
+				delete pProgressBarData;
+				break;
+			}
+
+			case WM_ERASEBKGND:
+			{
+				if (!DarkMode::isEnabled() || !themeData.ensureTheme(hWnd))
+				{
+					break;
+				}
+
+				const auto* hdc = reinterpret_cast<HDC>(wParam);
+				if (hdc != hMemDC)
+				{
+					return FALSE;
+				}
+				return TRUE;
+			}
+
+			case WM_PAINT:
+			{
+				if (!DarkMode::isEnabled())
+				{
+					break;
+				}
+
+				PAINTSTRUCT ps{};
+				HDC hdc = ::BeginPaint(hWnd, &ps);
+
+				if (ps.rcPaint.right <= ps.rcPaint.left || ps.rcPaint.bottom <= ps.rcPaint.top)
+				{
+					::EndPaint(hWnd, &ps);
+					return 0;
+				}
+
+				RECT rcClient{};
+				::GetClientRect(hWnd, &rcClient);
+
+				if (bufferData.ensureBuffer(hdc, rcClient))
+				{
+					const int savedState = ::SaveDC(hMemDC);
+					::IntersectClipRect(
+						hMemDC,
+						ps.rcPaint.left, ps.rcPaint.top, ps.rcPaint.right, ps.rcPaint.bottom
+					);
+
+					DarkMode::paintProgressBar(hWnd, hMemDC, *pProgressBarData);
+
+					::RestoreDC(hMemDC, savedState);
+
+					::BitBlt(
+						hdc,
+						ps.rcPaint.left, ps.rcPaint.top,
+						ps.rcPaint.right - ps.rcPaint.left,
+						ps.rcPaint.bottom - ps.rcPaint.top,
+						hMemDC,
+						ps.rcPaint.left, ps.rcPaint.top,
+						SRCCOPY
+					);
+				}
+
+				::EndPaint(hWnd, &ps);
+				return 0;
+			}
+
+			case WM_DPICHANGED:
+			case WM_DPICHANGED_AFTERPARENT:
+			{
+				themeData.closeTheme();
+				return 0;
+			}
+
+			case WM_THEMECHANGED:
+			{
+				themeData.closeTheme();
+				break;
+			}
+
+			case PBM_SETSTATE:
+			{
+				switch (wParam)
+				{
+					case PBST_NORMAL:
+					{
+						pProgressBarData->_iStateID = PBFS_NORMAL; // green
+						break;
+					}
+
+					case PBST_ERROR:
+					{
+						pProgressBarData->_iStateID = PBFS_ERROR; // red
+						break;
+					}
+
+					case PBST_PAUSED:
+					{
+						pProgressBarData->_iStateID = PBFS_PAUSED; // yellow
+						break;
+					}
+
+					default:
+					{
+						pProgressBarData->_iStateID = PBFS_PARTIAL; // cyan
+						break;
+					}
+				}
+				break;
+			}
+
+			default:
+			{
+				break;
+			}
+		}
+		return ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
+	}
+
+	void setProgressBarCtrlSubclass(HWND hWnd)
+	{
+		DarkMode::setSubclass<ProgressBarData>(hWnd, ProgressBarSubclass, kProgressBarSubclassID, hWnd);
+	}
+
+	void removeProgressBarCtrlSubclass(HWND hWnd)
+	{
+		DarkMode::removeSubclass<ProgressBarData>(hWnd, ProgressBarSubclass, kProgressBarSubclassID);
+	}
+
+	static void setProgressBarCtrlSubclass(HWND hWnd, DarkModeParams p)
+	{
+		const auto nStyle = ::GetWindowLongPtr(hWnd, GWL_STYLE);
+		if (p._theme && (nStyle & PBS_MARQUEE) == PBS_MARQUEE)
+		{
+			DarkMode::setProgressBarClassicTheme(hWnd);
+		}
+		else if (p._subclass)
+		{
+			DarkMode::setProgressBarCtrlSubclass(hWnd);
+		}
+	}
+
+	struct StaticTextData
+	{
+		bool _isEnabled = true;
+
+		StaticTextData() = default;
+
+		explicit StaticTextData(HWND hWnd)
+			: _isEnabled(::IsWindowEnabled(hWnd) == TRUE)
+		{}
+	};
+
+	/**
+	 * @brief Window subclass procedure for better disabled state appearence for static control with text.
+	 *
+	 * @param hWnd Window handle being subclassed.
+	 * @param uMsg Message identifier.
+	 * @param wParam Message-specific data.
+	 * @param lParam Message-specific data.
+	 * @param uIdSubclass Subclass identifier.
+	 * @param dwRefData StaticTextData instance.
+	 * @return LRESULT Result of message processing.
+	 *
+	 * @see DarkMode::setStaticTextCtrlSubclass()
+	 * @see DarkMode::removeStaticTextCtrlSubclass()
+	 */
+	static LRESULT CALLBACK StaticTextSubclass(
+		HWND hWnd,
+		UINT uMsg,
+		WPARAM wParam,
+		LPARAM lParam,
+		UINT_PTR uIdSubclass,
+		DWORD_PTR dwRefData
+	)
+	{
+		auto* pStaticTextData = reinterpret_cast<StaticTextData*>(dwRefData);
+
+		switch (uMsg)
+		{
+			case WM_NCDESTROY:
+			{
+				::RemoveWindowSubclass(hWnd, StaticTextSubclass, uIdSubclass);
+				delete pStaticTextData;
+				break;
+			}
+
+			case WM_ENABLE:
+			{
+				pStaticTextData->_isEnabled = (wParam == TRUE);
+
+				const auto nStyle = ::GetWindowLongPtr(hWnd, GWL_STYLE);
+				if (!pStaticTextData->_isEnabled)
+				{
+					::SetWindowLongPtr(hWnd, GWL_STYLE, nStyle & ~WS_DISABLED);
+				}
+
+				RECT rcClient{};
+				::GetClientRect(hWnd, &rcClient);
+				::MapWindowPoints(hWnd, ::GetParent(hWnd), reinterpret_cast<LPPOINT>(&rcClient), 2);
+				::RedrawWindow(::GetParent(hWnd), &rcClient, nullptr, RDW_INVALIDATE | RDW_UPDATENOW);
+
+				if (!pStaticTextData->_isEnabled)
+				{
+					::SetWindowLongPtr(hWnd, GWL_STYLE, nStyle | WS_DISABLED);
+				}
+
+				return 0;
+			}
+
+			default:
+			{
+				break;
+			}
+		}
+		return ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
+	}
+
+	void setStaticTextCtrlSubclass(HWND hWnd)
+	{
+		DarkMode::setSubclass<StaticTextData>(hWnd, StaticTextSubclass, kStaticTextSubclassID, hWnd);
+	}
+
+	void removeStaticTextCtrlSubclass(HWND hWnd)
+	{
+		DarkMode::removeSubclass<StaticTextData>(hWnd, StaticTextSubclass, kStaticTextSubclassID);
+	}
+
+	static void setStaticTextCtrlSubclass(HWND hWnd, DarkModeParams p)
+	{
+		if (p._subclass)
+		{
+			DarkMode::setStaticTextCtrlSubclass(hWnd);
+		}
+	}
+
+	static void setTreeViewCtrlTheme(HWND hWnd, DarkModeParams p)
+	{
+		if (p._theme)
+		{
+			TreeView_SetTextColor(hWnd, DarkMode::getViewTextColor());
+			TreeView_SetBkColor(hWnd, DarkMode::getViewBackgroundColor());
+
+			DarkMode::setTreeViewWindowTheme(hWnd, p._theme);
+			DarkMode::setDarkTooltips(hWnd, DarkMode::ToolTipsType::treeview);
+		}
+	}
+
+	static void setRebarCtrlSubclass(HWND hWnd, DarkModeParams p)
+	{
+		if (p._subclass)
+		{
+			DarkMode::setWindowEraseBgSubclass(hWnd);
+		}
+	}
+
+	static void setToolbarCtrlTheme(HWND hWnd, DarkModeParams p)
+	{
+		if (p._theme)
+		{
+			DarkMode::setDarkLineAbovePanelToolbar(hWnd);
+			DarkMode::setDarkTooltips(hWnd, DarkMode::ToolTipsType::toolbar);
+		}
+	}
+
+	static void setScrollBarCtrlTheme(HWND hWnd, DarkModeParams p)
+	{
+		if (p._theme)
+		{
+			DarkMode::setDarkScrollBar(hWnd);
+		}
+	}
+
+	static void enableSysLinkCtrlCtlColor(HWND hWnd, DarkModeParams p)
+	{
+		if (p._theme)
+		{
+			DarkMode::enableSysLinkCtrlCtlColor(hWnd);
+		}
+	}
+
+	static void setRichEditCtrlTheme(HWND hWnd, DarkModeParams p)
+	{
+		if (p._theme)
+		{
+			DarkMode::setDarkRichEdit(hWnd);
+		}
+	}
+
+	static void setTrackbarCtrlTheme(HWND hWnd, DarkModeParams p)
+	{
+		if (p._theme)
+		{
+			DarkMode::setDarkTooltips(hWnd, ToolTipsType::trackbar);
+			DarkMode::setWindowStyle(hWnd, DarkMode::isEnabled(), TBS_TRANSPARENTBKGND);
+		}
+	}
+
+	static BOOL CALLBACK DarkEnumChildProc(HWND hWnd, LPARAM lParam)
+	{
+		const auto& p = *reinterpret_cast<DarkModeParams*>(lParam);
+		const std::wstring className = GetWndClassName(hWnd);
+
+		if (className == WC_BUTTON)
+		{
+			DarkMode::setBtnCtrlSubclassAndTheme(hWnd, p);
+			return TRUE;
+		}
+
+		if (className == WC_STATIC)
+		{
+			DarkMode::setStaticTextCtrlSubclass(hWnd, p);
+			return TRUE;
+		}
+
+		if (className == WC_COMBOBOX)
+		{
+			DarkMode::setComboBoxCtrlSubclassAndTheme(hWnd, p);
+			return TRUE;
+		}
+
+		if (className == WC_EDIT)
+		{
+			DarkMode::setCustomBorderForListBoxOrEditCtrlSubclassAndTheme(hWnd, p, false);
+			return TRUE;
+		}
+
+		if (className == WC_LISTBOX)
+		{
+			DarkMode::setCustomBorderForListBoxOrEditCtrlSubclassAndTheme(hWnd, p, true);
+			return TRUE;
+		}
+
+		if (className == WC_LISTVIEW)
+		{
+			DarkMode::setListViewCtrlSubclassAndTheme(hWnd, p);
+			return TRUE;
+		}
+
+		if (className == WC_TREEVIEW)
+		{
+			DarkMode::setTreeViewCtrlTheme(hWnd, p);
+			return TRUE;
+		}
+
+		if (className == REBARCLASSNAMEW)
+		{
+			DarkMode::setRebarCtrlSubclass(hWnd, p);
+			return TRUE;
+		}
+
+		if (className == TOOLBARCLASSNAME)
+		{
+			DarkMode::setToolbarCtrlTheme(hWnd, p);
+			return TRUE;
+		}
+
+		if (className == UPDOWN_CLASS)
+		{
+			DarkMode::setUpDownCtrlSubclassAndTheme(hWnd, p);
+			return TRUE;
+		}
+
+		if (className == WC_TABCONTROL)
+		{
+			DarkMode::setTabCtrlSubclassAndTheme(hWnd, p);
+			return TRUE;
+		}
+
+		if (className == STATUSCLASSNAME)
+		{
+			DarkMode::setStatusBarCtrlSubclass(hWnd, p);
+			return TRUE;
+		}
+
+		if (className == WC_SCROLLBAR)
+		{
+			DarkMode::setScrollBarCtrlTheme(hWnd, p);
+			return TRUE;
+		}
+
+		if (className == WC_COMBOBOXEX)
+		{
+			DarkMode::setComboBoxExCtrlSubclass(hWnd, p);
+			return TRUE;
+		}
+
+		if (className == PROGRESS_CLASS)
+		{
+			DarkMode::setProgressBarCtrlSubclass(hWnd, p);
+			return TRUE;
+		}
+
+		if (className == WC_LINK)
+		{
+			DarkMode::enableSysLinkCtrlCtlColor(hWnd, p);
+			return TRUE;
+		}
+
+		if (className == RICHEDIT_CLASS || className == MSFTEDIT_CLASS)
+		{
+			DarkMode::setRichEditCtrlTheme(hWnd, p);
+			return TRUE;
+		}
+
+		if (className == TRACKBAR_CLASS)
+		{
+			DarkMode::setTrackbarCtrlTheme(hWnd, p);
+			return TRUE;
+		}
+
+#if 0 // for debugging
+		if (className == L"#32770") // dialog
+		{
+			return TRUE;
+		}
+#endif
+
+		return TRUE;
+	}
+
+	void setChildCtrlsSubclassAndTheme(HWND hParent, bool subclass, bool theme)
+	{
+		DarkModeParams p{
+			DarkMode::isExperimentalActive() ? L"DarkMode_Explorer" : nullptr
+			, subclass
+			, theme
+		};
+
+		::EnumChildWindows(hParent, DarkMode::DarkEnumChildProc, reinterpret_cast<LPARAM>(&p));
+	}
+
+	void setChildCtrlsTheme(HWND hParent)
+	{
+#if defined(_DARKMODELIB_ALLOW_OLD_OS) && (_DARKMODELIB_ALLOW_OLD_OS > 1)
+		DarkMode::setChildCtrlsSubclassAndTheme(hParent, false, true);
+#else
+		DarkMode::setChildCtrlsSubclassAndTheme(hParent, false, DarkMode::isAtLeastWindows10());
+#endif
+	}
+
+	/**
+	 * @brief Window subclass procedure for handling `WM_ERASEBKGND` message.
+	 *
+	 * Handles `WM_ERASEBKGND` to fill the window's client area with the custom color brush,
+	 * preventing default light gray flicker or mismatched fill.
+	 *
+	 * @param hWnd Window handle being subclassed.
+	 * @param uMsg Message identifier.
+	 * @param wParam Message-specific data.
+	 * @param lParam Message-specific data.
+	 * @param uIdSubclass Subclass identifier.
+	 * @param dwRefData Reserved data (unused).
+	 * @return LRESULT Result of message processing.
+	 *
+	 * @see DarkMode::setWindowEraseBgSubclass()
+	 * @see DarkMode::removeWindowEraseBgSubclass()
+	 */
+	static LRESULT CALLBACK WindowEraseBgSubclass(
+		HWND hWnd,
+		UINT uMsg,
+		WPARAM wParam,
+		LPARAM lParam,
+		UINT_PTR uIdSubclass,
+		[[maybe_unused]] DWORD_PTR dwRefData
+	)
+	{
+		switch (uMsg)
+		{
+			case WM_NCDESTROY:
+			{
+				::RemoveWindowSubclass(hWnd, WindowEraseBgSubclass, uIdSubclass);
+				break;
+			}
+
+			case WM_ERASEBKGND:
+			{
+				if (!DarkMode::isEnabled())
+				{
+					break;
+				}
+
+				RECT rcClient{};
+				::GetClientRect(hWnd, &rcClient);
+				::FillRect(reinterpret_cast<HDC>(wParam), &rcClient, DarkMode::getDlgBackgroundBrush());
+				return TRUE;
+			}
+
+			default:
+			{
+				break;
+			}
+		}
+		return ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
+	}
+
+	/**
+	 * @brief Applies window subclassing to handle `WM_ERASEBKGND` message.
+	 *
+	 * @param hWnd Handle to the control to subclass.
+	 *
+	 * @see DarkMode::WindowEraseBgSubclass()
+	 * @see DarkMode::removeWindowEraseBgSubclass()
+	 */
+	void setWindowEraseBgSubclass(HWND hWnd)
+	{
+		DarkMode::setSubclass(hWnd, WindowEraseBgSubclass, kWindowEraseBgSubclassID);
+	}
+
+	/**
+	 * @brief Removes the subclass used for `WM_ERASEBKGND` message handling.
+	 *
+	 * Detaches the window's subclass proc used for `WM_ERASEBKGND` message handling.
+	 *
+	 * @param hWnd Handle to the previously subclassed window.
+	 *
+	 * @see DarkMode::WindowEraseBgSubclass()
+	 * @see DarkMode::removeWindowEraseBgSubclass()
+	 */
+	void removeWindowEraseBgSubclass(HWND hWnd)
+	{
+		DarkMode::removeSubclass(hWnd, WindowEraseBgSubclass, kWindowEraseBgSubclassID);
+	}
+
+	/**
+	 * @brief Window subclass procedure for handling `WM_CTLCOLOR*` messages.
+	 *
+	 * Handles control drawing messages to apply foreground and background
+	 * styling based on control type and class.
+	 *
+	 * Handles:
+	 * - `WM_CTLCOLOREDIT`, `WM_CTLCOLORLISTBOX`, `WM_CTLCOLORDLG`, `WM_CTLCOLORSTATIC`
+	 * - `WM_PRINTCLIENT` for removing light border for push buttons in dark mode
+	 *
+	 * Cleans up subclass on `WM_NCDESTROY`
+	 *
+	 * Uses `DarkMode::onCtlColor*` utilities.
+	 *
+	 * @param hWnd Window handle being subclassed.
+	 * @param uMsg Message identifier.
+	 * @param wParam Message-specific data.
+	 * @param lParam Message-specific data.
+	 * @param uIdSubclass Subclass identifier.
+	 * @param dwRefData Reserved data (unused).
+	 * @return LRESULT Result of message processing.
+	 *
+	 * @see DarkMode::onCtlColor()
+	 * @see DarkMode::onCtlColorDlg()
+	 * @see DarkMode::onCtlColorDlgStaticText()
+	 * @see DarkMode::onCtlColorDlgLinkText()
+	 * @see DarkMode::onCtlColorListbox()
+	 */
+	static LRESULT CALLBACK WindowCtlColorSubclass(
+		HWND hWnd,
+		UINT uMsg,
+		WPARAM wParam,
+		LPARAM lParam,
+		UINT_PTR uIdSubclass,
+		[[maybe_unused]] DWORD_PTR dwRefData
+	)
+	{
+		switch (uMsg)
+		{
+			case WM_NCDESTROY:
+			{
+				::RemoveWindowSubclass(hWnd, WindowCtlColorSubclass, uIdSubclass);
+				break;
+			}
+
+			case WM_CTLCOLOREDIT:
+			{
+				if (!DarkMode::isEnabled())
+				{
+					break;
+				}
+				return DarkMode::onCtlColorCtrl(reinterpret_cast<HDC>(wParam));
+			}
+
+			case WM_CTLCOLORLISTBOX:
+			{
+				if (!DarkMode::isEnabled())
+				{
+					break;
+				}
+				return DarkMode::onCtlColorListbox(wParam, lParam);
+			}
+
+			case WM_CTLCOLORDLG:
+			{
+
+				if (!DarkMode::isEnabled())
+				{
+					break;
+				}
+				return DarkMode::onCtlColorDlg(reinterpret_cast<HDC>(wParam));
+			}
+
+			case WM_CTLCOLORSTATIC:
+			{
+				if (!DarkMode::isEnabled())
+				{
+					break;
+				}
+
+				auto hChild = reinterpret_cast<HWND>(lParam);
+				const bool isChildEnabled = ::IsWindowEnabled(hChild) == TRUE;
+				const std::wstring className = GetWndClassName(hChild);
+
+				auto hdc = reinterpret_cast<HDC>(wParam);
+
+				if (className == WC_EDIT)
+				{
+					if (isChildEnabled)
+					{
+						return DarkMode::onCtlColor(hdc);
+					}
+					return DarkMode::onCtlColorDlg(hdc);
+				}
+
+				if (className == WC_LINK)
+				{
+					return DarkMode::onCtlColorDlgLinkText(hdc, isChildEnabled);
+				}
+
+				DWORD_PTR dwRefDataStaticText = 0;
+				if (::GetWindowSubclass(hChild, StaticTextSubclass, kStaticTextSubclassID, &dwRefDataStaticText) == TRUE)
+				{
+					const bool isTextEnabled = (reinterpret_cast<StaticTextData*>(dwRefDataStaticText))->_isEnabled;
+					return DarkMode::onCtlColorDlgStaticText(hdc, isTextEnabled);
+				}
+				return DarkMode::onCtlColorDlg(hdc);
+			}
+
+			case WM_PRINTCLIENT:
+			{
+				if (!DarkMode::isEnabled())
+				{
+					break;
+				}
+				return TRUE;
+			}
+
+			default:
+			{
+				break;
+			}
+		}
+		return ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
+	}
+
+	/**
+	 * @brief Applies window subclassing to handle `WM_CTLCOLOR*` messages.
+	 *
+	 * Enable custom colors for edit, listbox, static, and dialog elements
+	 * via @ref DarkMode::WindowCtlColorSubclass.
+	 *
+	 * @param hWnd Handle to the parent or composite control (dialog, rebar, toolbar, ...) to subclass.
+	 *
+	 * @see DarkMode::WindowCtlColorSubclass()
+	 * @see DarkMode::removeWindowCtlColorSubclass()
+	 */
+	void setWindowCtlColorSubclass(HWND hWnd)
+	{
+		DarkMode::setSubclass(hWnd, WindowCtlColorSubclass, kWindowCtlColorSubclassID);
+	}
+
+	/**
+	 * @brief Removes the subclass used for `WM_CTLCOLOR*` messages handling.
+	 *
+	 * Detaches the window's subclass proc used for `WM_CTLCOLOR*` messages handling.
+	 *
+	 * @param hWnd Handle to the previously subclassed window.
+	 *
+	 * @see DarkMode::WindowCtlColorSubclass()
+	 * @see DarkMode::setWindowCtlColorSubclass()
+	 */
+	void removeWindowCtlColorSubclass(HWND hWnd)
+	{
+		DarkMode::removeSubclass(hWnd, WindowCtlColorSubclass, kWindowCtlColorSubclassID);
+	}
+
+	/**
+	 * @brief Applies custom drawing to a toolbar items (buttons) during `CDDS_ITEMPREPAINT`
+	 *
+	 * Handles color assignment and background painting for toolbar buttons during the
+	 * `CDDS_ITEMPREPAINT` stage of `NMTBCUSTOMDRAW`. Applies appropriate brushes, pens,
+	 * and background rendering depending on the button state:
+	 * - **Hot**: Uses hot background and edge styling.
+	 * - **Checked**: Uses control background and standard edge styling.
+	 * - **Drop-down**: Calculates and paints iconic split-button drop arrow.
+	 *
+	 * Also configures transparency and color usage for text, hot-tracking, and background fills.
+	 * Ensures hot/checked states are visually overridden by custom color highlights.
+	 *
+	 * @param lptbcd Reference to the toolbar's custom draw structure.
+	 * @return Flags to control draw behavior (`TBCDRF_USECDCOLORS`, `TBCDRF_NOBACKGROUND`, `CDRF_NOTIFYPOSTPAINT`).
+	 *
+	 * @note This function clears `CDIS_HOT`/`CDIS_CHECKED` to allow manual visual overrides.
+	 *
+	 * @see DarkMode::postpaintToolbarItem()
+	 * @see DarkMode::darkToolbarNotifyCustomDraw()
+	 */
+	[[nodiscard]] static LRESULT prepaintToolbarItem(LPNMTBCUSTOMDRAW& lptbcd)
+	{
+		// Set colors
+
+		lptbcd->hbrMonoDither = DarkMode::getBackgroundBrush();
+		lptbcd->hbrLines = DarkMode::getEdgeBrush();
+		lptbcd->hpenLines = DarkMode::getEdgePen();
+		lptbcd->clrText = DarkMode::getDarkerTextColor();
+		lptbcd->clrTextHighlight = DarkMode::getTextColor();
+		lptbcd->clrBtnFace = DarkMode::getBackgroundColor();
+		lptbcd->clrBtnHighlight = DarkMode::getCtrlBackgroundColor();
+		lptbcd->clrHighlightHotTrack = DarkMode::getHotBackgroundColor();
+		lptbcd->nStringBkMode = TRANSPARENT;
+		lptbcd->nHLStringBkMode = TRANSPARENT;
+
+		// Get styles and rectangles
+
+		const bool isHot = (lptbcd->nmcd.uItemState & CDIS_HOT) == CDIS_HOT;
+		const bool isChecked = (lptbcd->nmcd.uItemState & CDIS_CHECKED) == CDIS_CHECKED;
+
+		RECT rcItem{ lptbcd->nmcd.rc };
+		RECT rcDrop{};
+
+		TBBUTTONINFOW tbi{};
+		tbi.cbSize = sizeof(TBBUTTONINFOW);
+		tbi.dwMask = TBIF_IMAGE | TBIF_STYLE;
+		::SendMessage(lptbcd->nmcd.hdr.hwndFrom, TB_GETBUTTONINFO, lptbcd->nmcd.dwItemSpec, reinterpret_cast<LPARAM>(&tbi));
+
+		const bool isIcon = tbi.iImage != I_IMAGENONE;
+		const bool isDropDown = ((tbi.fsStyle & BTNS_DROPDOWN) == BTNS_DROPDOWN) && isIcon; // has 2 "buttons"
+		if (isDropDown)
+		{
+			const auto idx = ::SendMessage(lptbcd->nmcd.hdr.hwndFrom, TB_COMMANDTOINDEX, lptbcd->nmcd.dwItemSpec, 0);
+			::SendMessage(lptbcd->nmcd.hdr.hwndFrom, TB_GETITEMDROPDOWNRECT, static_cast<WPARAM>(idx), reinterpret_cast<LPARAM>(&rcDrop));
+
+			rcItem.right = rcDrop.left;
+		}
+
+		static const int roundness = DarkMode::isAtLeastWindows11() ? kWin11CornerRoundness + 1 : 0;
+
+		// Paint part
+
+		if (isHot) // hot must have higher priority to overwrite checked state
+		{
+			if (!isIcon)
+			{
+				::FillRect(lptbcd->nmcd.hdc, &rcItem, DarkMode::getHotBackgroundBrush());
+			}
+			else
+			{
+				DarkMode::paintRoundRect(lptbcd->nmcd.hdc, rcItem, DarkMode::getHotEdgePen(), DarkMode::getHotBackgroundBrush(), roundness, roundness);
+				if (isDropDown)
+				{
+					DarkMode::paintRoundRect(lptbcd->nmcd.hdc, rcDrop, DarkMode::getHotEdgePen(), DarkMode::getHotBackgroundBrush(), roundness, roundness);
+				}
+			}
+
+			lptbcd->nmcd.uItemState &= ~static_cast<UINT>(CDIS_CHECKED | CDIS_HOT); // clears states to use custom highlight
+		}
+		else if (isChecked)
+		{
+			if (!isIcon)
+			{
+				::FillRect(lptbcd->nmcd.hdc, &rcItem, DarkMode::getCtrlBackgroundBrush());
+			}
+			else
+			{
+				DarkMode::paintRoundRect(lptbcd->nmcd.hdc, rcItem, DarkMode::getEdgePen(), DarkMode::getCtrlBackgroundBrush(), roundness, roundness);
+				if (isDropDown)
+				{
+					DarkMode::paintRoundRect(lptbcd->nmcd.hdc, rcDrop, DarkMode::getEdgePen(), DarkMode::getCtrlBackgroundBrush(), roundness, roundness);
+				}
+			}
+
+			lptbcd->nmcd.uItemState &= ~static_cast<UINT>(CDIS_CHECKED); // clears state to use custom highlight
+		}
+
+		LRESULT retVal = TBCDRF_USECDCOLORS;
+		if ((lptbcd->nmcd.uItemState & CDIS_SELECTED) == CDIS_SELECTED)
+		{
+			retVal |= TBCDRF_NOBACKGROUND;
+		}
+
+		if (isDropDown)
+		{
+			retVal |= CDRF_NOTIFYPOSTPAINT;
+		}
+
+		return retVal;
+	}
+
+	/**
+	 * @brief Applies custom drawing to a toolbar items (buttons) during `CDDS_ITEMPOSTPAINT.
+	 *
+	 * Paints arrow glyph with custom color over system black "⏷" for button with style `BTNS_DROPDOWN`.
+	 * Triggered by `CDRF_NOTIFYPOSTPAINT` from @ref DarkMode::prepaintToolbarItem.
+	 *
+	 * Logic:
+	 * - Retrieves the drop-down rectangle via `TB_GETITEMDROPDOWNRECT`.
+	 * - Selects the toolbar font and draws a centered arrow glyph with custom text color.
+	 *
+	 * @param lptbcd Reference to `LPNMTBCUSTOMDRAW`.
+	 * @return `CDRF_DODEFAULT` to let default text/icon rendering proceed normally.
+	 *
+	 * @note Only applies to iconic buttons.
+	 *
+	 * @see DarkMode::prepaintToolbarItem()
+	 * @see DarkMode::darkToolbarNotifyCustomDraw()
+	 */
+	[[nodiscard]] static LRESULT postpaintToolbarItem(LPNMTBCUSTOMDRAW& lptbcd)
+	{
+		TBBUTTONINFOW tbi{};
+		tbi.cbSize = sizeof(TBBUTTONINFOW);
+		tbi.dwMask = TBIF_IMAGE;
+		::SendMessage(lptbcd->nmcd.hdr.hwndFrom, TB_GETBUTTONINFO, lptbcd->nmcd.dwItemSpec, reinterpret_cast<LPARAM>(&tbi));
+		const bool isIcon = tbi.iImage != I_IMAGENONE;
+		if (!isIcon)
+		{
+			return CDRF_DODEFAULT;
+		}
+
+		auto hFont = reinterpret_cast<HFONT>(::SendMessage(lptbcd->nmcd.hdr.hwndFrom, WM_GETFONT, 0, 0));
+		auto holdFont = static_cast<HFONT>(::SelectObject(lptbcd->nmcd.hdc, hFont));
+
+		RECT rcArrow{};
+		const auto idx = ::SendMessage(lptbcd->nmcd.hdr.hwndFrom, TB_COMMANDTOINDEX, lptbcd->nmcd.dwItemSpec, 0);
+		::SendMessage(lptbcd->nmcd.hdr.hwndFrom, TB_GETITEMDROPDOWNRECT, static_cast<WPARAM>(idx), reinterpret_cast<LPARAM>(&rcArrow));
+		rcArrow.left += 1;
+		rcArrow.bottom -= 3;
+
+		::SetBkMode(lptbcd->nmcd.hdc, TRANSPARENT);
+		::SetTextColor(lptbcd->nmcd.hdc, DarkMode::getTextColor());
+		::DrawText(lptbcd->nmcd.hdc, L"⏷", -1, &rcArrow, DT_NOPREFIX | DT_CENTER | DT_VCENTER | DT_SINGLELINE | DT_NOCLIP);
+		::SelectObject(lptbcd->nmcd.hdc, holdFont);
+
+		return CDRF_DODEFAULT;
+	}
+
+	/**
+	 * @brief Handles custom draw notifications for a toolbar control.
+	 *
+	 * Processes `NMTBCUSTOMDRAW` messages to provide custom color painting
+	 * at each stage of the custom draw cycle:
+	 * - **CDDS_PREPAINT**: Fills the toolbar background and requests item-level drawing.
+	 * - **CDDS_ITEMPREPAINT**: Applies custom item painting via @ref DarkMode::prepaintToolbarItem.
+	 * - **CDDS_ITEMPOSTPAINT**: Paints dropdown arrows glyphs via @ref DarkMode::postpaintToolbarItem.
+	 *
+	 * @param hWnd Handle to the toolbar control.
+	 * @param uMsg Should be `WM_NOTIFY` with custom draw type (forwarded to default subclass processing).
+	 * @param wParam Message parameter (forwarded to default subclass processing).
+	 * @param lParam Pointer to `NMTBCUSTOMDRAW`.
+	 * @return `LRESULT` containing draw flags or the result of default subclass processing.
+	 *
+	 * @see DarkMode::prepaintToolbarItem()
+	 * @see DarkMode::postpaintToolbarItem()
+	 */
+	[[nodiscard]] static LRESULT darkToolbarNotifyCustomDraw(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
+	{
+		auto* lptbcd = reinterpret_cast<LPNMTBCUSTOMDRAW>(lParam);
+
+		switch (lptbcd->nmcd.dwDrawStage)
+		{
+			case CDDS_PREPAINT:
+			{
+				::FillRect(lptbcd->nmcd.hdc, &lptbcd->nmcd.rc, DarkMode::getDlgBackgroundBrush());
+				return CDRF_NOTIFYITEMDRAW | CDRF_NOTIFYPOSTPAINT;
+			}
+
+			case CDDS_ITEMPREPAINT:
+			{
+				return DarkMode::prepaintToolbarItem(lptbcd);
+			}
+
+			case CDDS_ITEMPOSTPAINT:
+			{
+				return DarkMode::postpaintToolbarItem(lptbcd);
+			}
+
+			default:
+			{
+				break;
+			}
+		}
+		return ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
+	}
+
+	/**
+	 * @brief Applies custom drawing to a list view item during `CDDS_ITEMPREPAINT`.
+	 *
+	 * Sets text/background colors and fills the item rectangle based on state and style.
+	 * Handles list view custom colors and styles, and adapts to grid line configuration.
+	 *
+	 * Behavior:
+	 * - **Selected**: Uses `DarkMode::getCtrlBackground*()` colors and text brush.
+	 * - **Hot**: Uses `DarkMode::getHotBackground*()` colors with optional hover frame.
+	 * - **Gridlines active**: Fills the entire row background, column by column.
+	 *
+	 * @param lplvcd Reference to `LPNMLVCUSTOMDRAW`.
+	 * @param isReport Whether list view is in `LVS_REPORT` mode.
+	 * @param hasGridLines Whether grid lines are enabled (`LVS_EX_GRIDLINES`).
+	 *
+	 * @see DarkMode::darkListViewNotifyCustomDraw()
+	 */
+	static void prepaintListViewItem(LPNMLVCUSTOMDRAW& lplvcd, bool isReport, bool hasGridLines)
+	{
+		const auto& hList = lplvcd->nmcd.hdr.hwndFrom;
+		const bool isSelected = ListView_GetItemState(hList, lplvcd->nmcd.dwItemSpec, LVIS_SELECTED) == LVIS_SELECTED;
+		const bool isFocused = ListView_GetItemState(hList, lplvcd->nmcd.dwItemSpec, LVIS_FOCUSED) == LVIS_FOCUSED;
+		const bool isHot = (lplvcd->nmcd.uItemState & CDIS_HOT) == CDIS_HOT;
+
+		HBRUSH hBrush = nullptr;
+
+		if (isSelected)
+		{
+			lplvcd->clrText = DarkMode::getTextColor();
+			lplvcd->clrTextBk = DarkMode::getCtrlBackgroundColor();
+			hBrush = DarkMode::getCtrlBackgroundBrush();
+		}
+		else if (isHot)
+		{
+			lplvcd->clrText = DarkMode::getTextColor();
+			lplvcd->clrTextBk = DarkMode::getHotBackgroundColor();
+			hBrush = DarkMode::getHotBackgroundBrush();
+		}
+
+		if (hBrush != nullptr)
+		{
+			if (!isReport || hasGridLines)
+			{
+				::FillRect(lplvcd->nmcd.hdc, &lplvcd->nmcd.rc, hBrush);
+			}
+			else
+			{
+				HWND hHeader = ListView_GetHeader(hList);
+				const int nCol = Header_GetItemCount(hHeader);
+				const LONG paddingLeft = DarkMode::isThemeDark() ? 1 : 0;
+				const LONG paddingRight = DarkMode::isThemeDark() ? 2 : 1;
+
+				LVITEMINDEX lvii{ static_cast<int>(lplvcd->nmcd.dwItemSpec), 0 };
+				RECT rcSubitem{
+					lplvcd->nmcd.rc.left
+					, lplvcd->nmcd.rc.top
+					, lplvcd->nmcd.rc.left + ListView_GetColumnWidth(hList, 0) - paddingRight
+					, lplvcd->nmcd.rc.bottom
+				};
+				::FillRect(lplvcd->nmcd.hdc, &rcSubitem, hBrush);
+
+				for (int i = 1; i < nCol; ++i)
+				{
+					ListView_GetItemIndexRect(hList, &lvii, i, LVIR_BOUNDS, &rcSubitem);
+					rcSubitem.left -= paddingLeft;
+					rcSubitem.right -= paddingRight;
+					::FillRect(lplvcd->nmcd.hdc, &rcSubitem, hBrush);
+				}
+			}
+		}
+		else if (hasGridLines)
+		{
+			::FillRect(lplvcd->nmcd.hdc, &lplvcd->nmcd.rc, DarkMode::getViewBackgroundBrush());
+		}
+
+		if (isFocused)
+		{
+#if 0 // for testing
+			::DrawFocusRect(lplvcd->nmcd.hdc, &lplvcd->nmcd.rc);
+#endif
+		}
+		else if (!isSelected && isHot && !hasGridLines)
+		{
+			::FrameRect(lplvcd->nmcd.hdc, &lplvcd->nmcd.rc, DarkMode::getHotEdgeBrush());
+		}
+	}
+
+	/**
+	 * @brief Handles custom draw notifications for a list view control.
+	 *
+	 * Processes `NMLVCUSTOMDRAW` messages to provide custom color painting
+	 * at each stage of the custom draw cycle:
+	 * - **CDDS_PREPAINT**: Optionally fills the list view with grid lines
+	 *                      with custom background color and requests item-level drawing.
+	 * - **CDDS_ITEMPREPAINT**: Applies custom item painting via @ref DarkMode::prepaintListViewItem.
+	 *
+	 * @param hWnd Handle to the list view control.
+	 * @param uMsg Should be `WM_NOTIFY` with custom draw type (forwarded to default subclass processing).
+	 * @param wParam Message parameter (forwarded to default subclass processing).
+	 * @param lParam Pointer to `NMLVCUSTOMDRAW`.
+	 * @return `LRESULT` containing draw flags or the result of default subclass processing.
+	 *
+	 * @see DarkMode::prepaintListViewItem()
+	 */
+	[[nodiscard]] static LRESULT darkListViewNotifyCustomDraw(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
+	{
+		auto* lplvcd = reinterpret_cast<LPNMLVCUSTOMDRAW>(lParam);
+		const auto& hList = lplvcd->nmcd.hdr.hwndFrom;
+		const auto lvStyle = ::GetWindowLongPtr(hList, GWL_STYLE) & LVS_TYPEMASK;
+		const bool isReport = (lvStyle == LVS_REPORT);
+		bool hasGridlines = false;
+		if (isReport)
+		{
+			const auto lvExStyle = ListView_GetExtendedListViewStyle(hList);
+			hasGridlines = (lvExStyle & LVS_EX_GRIDLINES) == LVS_EX_GRIDLINES;
+		}
+
+		switch (lplvcd->nmcd.dwDrawStage)
+		{
+			case CDDS_PREPAINT:
+			{
+				if (isReport && hasGridlines)
+				{
+					::FillRect(lplvcd->nmcd.hdc, &lplvcd->nmcd.rc, DarkMode::getViewBackgroundBrush());
+				}
+
+				return CDRF_NOTIFYITEMDRAW;
+			}
+
+			case CDDS_ITEMPREPAINT:
+			{
+				DarkMode::prepaintListViewItem(lplvcd, isReport, hasGridlines);
+				return CDRF_NEWFONT;
+			}
+
+			default:
+			{
+				break;
+			}
+		}
+		return ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
+	}
+
+	/**
+	 * @brief Applies custom drawing to a tree view node during `CDDS_ITEMPREPAINT`.
+	 *
+	 * Colors the node background for selection/hot states, assigns text color,
+	 * and requests optional post-paint framing.
+	 *
+	 * @param lptvcd Reference to `LPNMTVCUSTOMDRAW`.
+	 * @return Bitmask with `CDRF_NEWFONT`, `CDRF_NOTIFYPOSTPAINT` if drawing was applied.
+	 *
+	 * @see DarkMode::postpaintTreeViewItem()
+	 * @see DarkMode::darkTreeViewNotifyCustomDraw()
+	 */
+	[[nodiscard]] static LRESULT prepaintTreeViewItem(LPNMTVCUSTOMDRAW& lptvcd)
+	{
+		LRESULT retVal = CDRF_DODEFAULT;
+
+		if ((lptvcd->nmcd.uItemState & CDIS_SELECTED) == CDIS_SELECTED)
+		{
+			lptvcd->clrText = DarkMode::getTextColor();
+			lptvcd->clrTextBk = DarkMode::getCtrlBackgroundColor();
+			::FillRect(lptvcd->nmcd.hdc, &lptvcd->nmcd.rc, DarkMode::getCtrlBackgroundBrush());
+
+			retVal |= CDRF_NEWFONT | CDRF_NOTIFYPOSTPAINT;
+		}
+		else if ((lptvcd->nmcd.uItemState & CDIS_HOT) == CDIS_HOT)
+		{
+			lptvcd->clrText = DarkMode::getTextColor();
+			lptvcd->clrTextBk = DarkMode::getHotBackgroundColor();
+
+			if (DarkMode::isAtLeastWindows10() || DarkMode::getTreeViewStyle() == TreeViewStyle::light)
+			{
+				::FillRect(lptvcd->nmcd.hdc, &lptvcd->nmcd.rc, DarkMode::getHotBackgroundBrush());
+				retVal |= CDRF_NOTIFYPOSTPAINT;
+			}
+			retVal |= CDRF_NEWFONT;
+		}
+
+		return retVal;
+	}
+
+	/**
+	 * @brief Applies custom drawing to a tree view node during `CDDS_ITEMPOSTPAINT`.
+	 *
+	 * Paints a frame around a tree view node after painting based on state.
+	 *
+	 * @param lptvcd Reference to `LPNMTVCUSTOMDRAW`.
+	 *
+	 * @see DarkMode::prepaintTreeViewItem()
+	 * @see DarkMode::darkTreeViewNotifyCustomDraw()
+	 */
+	static void postpaintTreeViewItem(LPNMTVCUSTOMDRAW& lptvcd)
+	{
+		RECT rcFrame{ lptvcd->nmcd.rc };
+		::InflateRect(&rcFrame, 1, 0);
+
+		if ((lptvcd->nmcd.uItemState & CDIS_HOT) == CDIS_HOT)
+		{
+			DarkMode::paintRoundFrameRect(lptvcd->nmcd.hdc, rcFrame, DarkMode::getHotEdgePen(), 0, 0);
+		}
+		else if ((lptvcd->nmcd.uItemState & CDIS_SELECTED) == CDIS_SELECTED)
+		{
+			DarkMode::paintRoundFrameRect(lptvcd->nmcd.hdc, rcFrame, DarkMode::getEdgePen(), 0, 0);
+		}
+	}
+
+	/**
+	 * @brief Handles custom draw notifications for a tree view control.
+	 *
+	 * Processes `NMTVCUSTOMDRAW` messages to provide custom color painting
+	 * at each stage of the custom draw cycle:
+	 * - **CDDS_PREPAINT**: Requests item-level drawing.
+	 * - **CDDS_ITEMPREPAINT**: Applies custom item painting based on state via @ref DarkMode::prepaintTreeViewItem.
+	 * - **CDDS_ITEMPOSTPAINT**: Paints frames based on state via @ref DarkMode::postpaintTreeViewItem.
+	 *
+	 * @param hWnd Handle to the tree view control.
+	 * @param uMsg Should be `WM_NOTIFY` with custom draw type (forwarded to default subclass processing).
+	 * @param wParam Message parameter (forwarded to default subclass processing).
+	 * @param lParam Pointer to `NMTVCUSTOMDRAW`.
+	 * @return `LRESULT` containing draw flags or the result of default subclass processing.
+	 *
+	 * @see DarkMode::prepaintTreeViewItem()
+	 * @see DarkMode::postpaintTreeViewItem()
+	 */
+	[[nodiscard]] static LRESULT darkTreeViewNotifyCustomDraw(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
+	{
+		auto* lptvcd = reinterpret_cast<LPNMTVCUSTOMDRAW>(lParam);
+
+		switch (lptvcd->nmcd.dwDrawStage)
+		{
+			case CDDS_PREPAINT:
+			{
+				return CDRF_NOTIFYITEMDRAW;
+			}
+
+			case CDDS_ITEMPREPAINT:
+			{
+				const LRESULT retVal = DarkMode::prepaintTreeViewItem(lptvcd);
+				if (retVal == CDRF_DODEFAULT)
+				{
+					break;
+				}
+				return retVal;
+			}
+
+			case CDDS_ITEMPOSTPAINT:
+			{
+				DarkMode::postpaintTreeViewItem(lptvcd);
+				return CDRF_DODEFAULT;
+			}
+
+			default:
+			{
+				break;
+			}
+		}
+		return ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
+	}
+
+	/**
+	 * @brief Applies custom drawing to a trackbar items during `CDDS_ITEMPREPAINT`.
+	 *
+	 * Colors the trackbar thumb background for selection state,
+	 * and colors the trackbar slider based on if tracbar is enabled.
+	 * For trackbar with style `TBS_AUTOTICKS` default handling is used.
+	 *
+	 * @param lpnmcd Reference to `LPNMCUSTOMDRAW`.
+	 * @return `CDRF_SKIPDEFAULT` if drawing was applied.
+	 *
+	 * @see DarkMode::darkTrackbarNotifyCustomDraw()
+	 */
+	[[nodiscard]] static LRESULT prepaintTrackbarItem(LPNMCUSTOMDRAW& lpnmcd)
+	{
+		LRESULT retVal = CDRF_DODEFAULT;
+
+		switch (lpnmcd->dwItemSpec)
+		{
+			case TBCD_TICS:
+			{
+				break;
+			}
+
+			case TBCD_THUMB:
+			{
+				if ((lpnmcd->uItemState & CDIS_SELECTED) == CDIS_SELECTED)
+				{
+					::FillRect(lpnmcd->hdc, &lpnmcd->rc, DarkMode::getCtrlBackgroundBrush());
+					retVal = CDRF_SKIPDEFAULT;
+				}
+				break;
+			}
+
+			case TBCD_CHANNEL: // slider
+			{
+				if (::IsWindowEnabled(lpnmcd->hdr.hwndFrom) == FALSE)
+				{
+					::FillRect(lpnmcd->hdc, &lpnmcd->rc, DarkMode::getDlgBackgroundBrush());
+					DarkMode::paintRoundFrameRect(lpnmcd->hdc, lpnmcd->rc, DarkMode::getEdgePen(), 0, 0);
+				}
+				else
+				{
+					::FillRect(lpnmcd->hdc, &lpnmcd->rc, DarkMode::getCtrlBackgroundBrush());
+				}
+
+				retVal = CDRF_SKIPDEFAULT;
+				break;
+			}
+
+			default:
+			{
+				break;
+			}
+		}
+
+		return retVal;
+	}
+
+	/**
+	 * @brief Handles custom draw notifications for a trackbar control.
+	 *
+	 * Processes `NMCUSTOMDRAW` messages to provide custom color painting
+	 * at each stage of the custom draw cycle:
+	 * - **CDDS_PREPAINT**: Requests item-level drawing.
+	 * - **CDDS_ITEMPREPAINT**: Applies custom item painting based on item type via @ref DarkMode::prepaintTrackbarItem.
+	 *
+	 * @param hWnd Handle to the trackbar control.
+	 * @param uMsg Should be `WM_NOTIFY` with custom draw type (forwarded to default subclass processing).
+	 * @param wParam Message parameter (forwarded to default subclass processing).
+	 * @param lParam Pointer to `NMCUSTOMDRAW`.
+	 * @return `LRESULT` containing draw flags or the result of default subclass processing.
+	 *
+	 * @see DarkMode::prepaintTrackbarItem()
+	 */
+	[[nodiscard]] static LRESULT darkTrackbarNotifyCustomDraw(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
+	{
+		auto* lpnmcd = reinterpret_cast<LPNMCUSTOMDRAW>(lParam);
+
+		switch (lpnmcd->dwDrawStage)
+		{
+			case CDDS_PREPAINT:
+			{
+				return CDRF_NOTIFYITEMDRAW;
+			}
+
+			case CDDS_ITEMPREPAINT:
+			{
+				const LRESULT retVal = DarkMode::prepaintTrackbarItem(lpnmcd);
+				if (retVal == CDRF_DODEFAULT)
+				{
+					break;
+				}
+				return retVal;
+			}
+
+			default:
+			{
+				break;
+			}
+		}
+		return ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
+	}
+
+	/**
+	 * @brief Applies custom drawing to a rebar control during `CDDS_PREPAINT`.
+	 *
+	 * Paints chevrons and 'gripper' edges for all bands if applicable.
+	 *
+	 * @param lpnmcd Reference to `LPNMCUSTOMDRAW`.
+	 * @return `CDRF_SKIPDEFAULT` if drawing was applied.
+	 *
+	 * @see DarkMode::darkRebarNotifyCustomDraw()
+	 */
+	[[nodiscard]] static LRESULT prepaintRebar(LPNMCUSTOMDRAW& lpnmcd)
+	{
+		::FillRect(lpnmcd->hdc, &lpnmcd->rc, DarkMode::getDlgBackgroundBrush());
+
+		REBARBANDINFO rbBand{};
+		rbBand.cbSize = sizeof(REBARBANDINFO);
+		rbBand.fMask = RBBIM_STYLE | RBBIM_CHEVRONLOCATION | RBBIM_CHEVRONSTATE;
+
+		const auto nBands = static_cast<UINT>(::SendMessage(lpnmcd->hdr.hwndFrom, RB_GETBANDCOUNT, 0, 0));
+		for (UINT i = 0; i < nBands; ++i)
+		{
+			::SendMessage(lpnmcd->hdr.hwndFrom, RB_GETBANDINFO, static_cast<WPARAM>(i), reinterpret_cast<LPARAM>(&rbBand));
+
+			// paints chevron
+			if ((rbBand.fStyle & RBBS_USECHEVRON) == RBBS_USECHEVRON
+				&& (rbBand.rcChevronLocation.right - rbBand.rcChevronLocation.left) > 0)
+			{
+				static const int roundness = DarkMode::isAtLeastWindows11() ? kWin11CornerRoundness + 1 : 0;
+
+				const bool isHot = (rbBand.uChevronState & STATE_SYSTEM_HOTTRACKED) == STATE_SYSTEM_HOTTRACKED;
+				const bool isPressed = (rbBand.uChevronState & STATE_SYSTEM_PRESSED) == STATE_SYSTEM_PRESSED;
+
+				if (isHot)
+				{
+					DarkMode::paintRoundRect(lpnmcd->hdc, rbBand.rcChevronLocation, DarkMode::getHotEdgePen(), DarkMode::getHotBackgroundBrush(), roundness, roundness);
+				}
+				else if (isPressed)
+				{
+					DarkMode::paintRoundRect(lpnmcd->hdc, rbBand.rcChevronLocation, DarkMode::getEdgePen(), DarkMode::getCtrlBackgroundBrush(), roundness, roundness);
+				}
+
+				::SetTextColor(lpnmcd->hdc, isHot ? DarkMode::getTextColor() : DarkMode::getDarkerTextColor());
+				::SetBkMode(lpnmcd->hdc, TRANSPARENT);
+
+				static constexpr UINT dtFlags = DT_NOPREFIX | DT_CENTER | DT_TOP | DT_SINGLELINE | DT_NOCLIP;
+				::DrawText(lpnmcd->hdc, L"»", -1, &rbBand.rcChevronLocation, dtFlags);
+			}
+
+			// paints gripper edge
+			if ((rbBand.fStyle & RBBS_GRIPPERALWAYS) == RBBS_GRIPPERALWAYS
+				&& ((rbBand.fStyle & RBBS_FIXEDSIZE) != RBBS_FIXEDSIZE
+					|| (rbBand.fStyle & RBBS_NOGRIPPER) != RBBS_NOGRIPPER))
+			{
+				auto holdPen = static_cast<HPEN>(::SelectObject(lpnmcd->hdc, DarkMode::getDarkerTextPen()));
+
+				RECT rcBand{};
+				::SendMessage(lpnmcd->hdr.hwndFrom, RB_GETRECT, static_cast<WPARAM>(i), reinterpret_cast<LPARAM>(&rcBand));
+
+				static constexpr LONG offset = 5;
+				const std::array<POINT, 2> edges{ {
+					{ rcBand.left, rcBand.top + offset},
+					{ rcBand.left, rcBand.bottom - offset}
+				} };
+				::Polyline(lpnmcd->hdc, edges.data(), static_cast<int>(edges.size()));
+
+				::SelectObject(lpnmcd->hdc, holdPen);
+			}
+		}
+		return CDRF_SKIPDEFAULT;
+	}
+
+	/**
+	 * @brief Handles custom draw notifications for a rebar control.
+	 *
+	 * Processes `NMCUSTOMDRAW` messages to provide custom color painting
+	 * at each stage of the custom draw cycle:
+	 * - **CDDS_PREPAINT**: Applies custom painting based on item type via @ref DarkMode::prepaintRebar.
+	 *
+	 * @param hWnd Handle to the rebar control.
+	 * @param uMsg Should be `WM_NOTIFY` with custom draw type (forwarded to default subclass processing).
+	 * @param wParam Message parameter (forwarded to default subclass processing).
+	 * @param lParam Pointer to `NMCUSTOMDRAW`.
+	 * @return `LRESULT` containing draw flags or the result of default subclass processing.
+	 *
+	 * @see DarkMode::prepaintRebar()
+	 */
+	[[nodiscard]] static LRESULT darkRebarNotifyCustomDraw(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
+	{
+		auto* lpnmcd = reinterpret_cast<LPNMCUSTOMDRAW>(lParam);
+		if (lpnmcd->dwDrawStage == CDDS_PREPAINT)
+		{
+			return DarkMode::prepaintRebar(lpnmcd);
+		}
+		return ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
+	}
+
+	/**
+	 * @brief Window subclass procedure for handling `WM_NOTIFY` message for custom draw for supported controls.
+	 *
+	 * Handles `WM_NOTIFY` for custom draw for supported controls:
+	 * - toolbar, list view, tree view, trackbar, and rebar.
+	 *
+	 * @param hWnd Window handle being subclassed.
+	 * @param uMsg Message identifier.
+	 * @param wParam Message-specific data.
+	 * @param lParam Message-specific data.
+	 * @param uIdSubclass Subclass identifier.
+	 * @param dwRefData Reserved data (unused).
+	 * @return LRESULT Result of message processing.
+	 *
+	 * @see DarkMode::setWindowNotifyCustomDrawSubclass()
+	 * @see DarkMode::removeWindowNotifyCustomDrawSubclass()
+	 */
+	static LRESULT CALLBACK WindowNotifySubclass(
+		HWND hWnd,
+		UINT uMsg,
+		WPARAM wParam,
+		LPARAM lParam,
+		UINT_PTR uIdSubclass,
+		[[maybe_unused]] DWORD_PTR dwRefData
+	)
+	{
+		switch (uMsg)
+		{
+			case WM_NCDESTROY:
+			{
+				::RemoveWindowSubclass(hWnd, WindowNotifySubclass, uIdSubclass);
+				break;
+			}
+
+			case WM_NOTIFY:
+			{
+				if (!DarkMode::isEnabled())
+				{
+					break;
+				}
+
+				auto* lpnmhdr = reinterpret_cast<LPNMHDR>(lParam);
+				if (lpnmhdr->code == NM_CUSTOMDRAW)
+				{
+					const std::wstring className = GetWndClassName(lpnmhdr->hwndFrom);
+
+					if (className == TOOLBARCLASSNAME)
+					{
+						return DarkMode::darkToolbarNotifyCustomDraw(hWnd, uMsg, wParam, lParam);
+					}
+
+					if (className == WC_LISTVIEW)
+					{
+						return DarkMode::darkListViewNotifyCustomDraw(hWnd, uMsg, wParam, lParam);
+					}
+
+					if (className == WC_TREEVIEW)
+					{
+						return DarkMode::darkTreeViewNotifyCustomDraw(hWnd, uMsg, wParam, lParam);
+					}
+
+					if (className == TRACKBAR_CLASS)
+					{
+						return DarkMode::darkTrackbarNotifyCustomDraw(hWnd, uMsg, wParam, lParam);
+					}
+
+					if (className == REBARCLASSNAME)
+					{
+						return DarkMode::darkRebarNotifyCustomDraw(hWnd, uMsg, wParam, lParam);
+					}
+				}
+				break;
+			}
+
+			default:
+			{
+				break;
+			}
+		}
+		return ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
+	}
+
+	/**
+	 * @brief Applies window subclassing for handling `NM_CUSTOMDRAW` notifications for custom drawing.
+	 *
+	 * Installs @ref DarkMode::WindowNotifySubclass.
+	 * Enables handling of `WM_NOTIFY` `NM_CUSTOMDRAW` notifications for custom drawing
+	 * behavior for supported controls.
+	 *
+	 * @param hWnd Handle to the window with child which support `NM_CUSTOMDRAW`.
+	 *
+	 * @see DarkMode::WindowNotifySubclass()
+	 * @see DarkMode::removeWindowNotifyCustomDrawSubclass()
+	 */
+	void setWindowNotifyCustomDrawSubclass(HWND hWnd)
+	{
+		DarkMode::setSubclass(hWnd, WindowNotifySubclass, kWindowNotifySubclassID);
+	}
+
+	/**
+	 * @brief Removes the subclass used for handling `NM_CUSTOMDRAW` notifications for custom drawing.
+	 *
+	 * Detaches the window's subclass proc used for handling `NM_CUSTOMDRAW` notifications for custom drawing.
+	 *
+	 * @param hWnd Handle to the previously subclassed window.
+	 *
+	 * @see DarkMode::WindowNotifySubclass()
+	 * @see DarkMode::setWindowNotifyCustomDrawSubclass()
+	 */
+	void removeWindowNotifyCustomDrawSubclass(HWND hWnd)
+	{
+		DarkMode::removeSubclass(hWnd, WindowNotifySubclass, kWindowNotifySubclassID);
+	}
+
+	/**
+	 * @brief Fills the menu bar background custom color.
+	 *
+	 * Uses `GetMenuBarInfo` and `GetWindowRect` to compute the menu bar rectangle
+	 * in client-relative coordinates, then fills it with @ref DarkMode::getDlgBackgroundBrush.
+	 *
+	 * @param hWnd Handle to the window with a menu bar.
+	 * @param hdc Target device context for painting.
+	 *
+	 * @note Offsets top slightly to account for non-client overlap.
+	 */
+	static void paintMenuBar(HWND hWnd, HDC hdc)
+	{
+		// get the menubar rect
+		MENUBARINFO mbi{};
+		mbi.cbSize = sizeof(MENUBARINFO);
+		::GetMenuBarInfo(hWnd, OBJID_MENU, 0, &mbi);
+
+		RECT rcWindow{};
+		::GetWindowRect(hWnd, &rcWindow);
+
+		// the rcBar is offset by the window rect
+		RECT rcBar{ mbi.rcBar };
+		::OffsetRect(&rcBar, -rcWindow.left, -rcWindow.top);
+
+		rcBar.top -= 1;
+
+		::FillRect(hdc, &rcBar, DarkMode::getDlgBackgroundBrush());
+	}
+
+	/**
+	 * @brief Paints a single menu bar item with custom colors based on state.
+	 *
+	 * Measures and renders menu item text using `DrawThemeTextEx`, and
+	 * fills background using appropriate brush based on `ODS_*` item state.
+	 *
+	 * @param UDMI Reference to `UAHDRAWMENUITEM` struct from `WM_UAHDRAWMENUITEM`.
+	 * @param hTheme The themed handle to `VSCLASS_MENU` (via @ref ThemeData).
+	 *
+	 * @see DarkMode::WindowMenuBarSubclass()
+	 */
+	static void paintMenuBarItems(UAHDRAWMENUITEM& UDMI, const HTHEME& hTheme)
+	{
+		// get the menu item string
+		std::wstring buffer(MAX_PATH, L'\0');
+		MENUITEMINFO mii{};
+		mii.cbSize = sizeof(MENUITEMINFO);
+		mii.fMask = MIIM_STRING;
+		mii.dwTypeData = buffer.data();
+		mii.cch = MAX_PATH - 1;
+
+		::GetMenuItemInfo(UDMI.um.hmenu, static_cast<UINT>(UDMI.umi.iPosition), TRUE, &mii);
+
+		// get the item state for drawing
+
+		DWORD dwFlags = DT_CENTER | DT_SINGLELINE | DT_VCENTER;
+
+		int iTextStateID = MBI_NORMAL;
+		int iBackgroundStateID = MBI_NORMAL;
+		if ((UDMI.dis.itemState & ODS_SELECTED) == ODS_SELECTED)
+		{
+			// clicked
+			iTextStateID = MBI_PUSHED;
+			iBackgroundStateID = MBI_PUSHED;
+		}
+		else if ((UDMI.dis.itemState & ODS_HOTLIGHT) == ODS_HOTLIGHT)
+		{
+			// hot tracking
+			iTextStateID = ((UDMI.dis.itemState & ODS_INACTIVE) == ODS_INACTIVE) ? MBI_DISABLEDHOT : MBI_HOT;
+			iBackgroundStateID = MBI_HOT;
+		}
+		else if (((UDMI.dis.itemState & ODS_GRAYED) == ODS_GRAYED)
+			|| ((UDMI.dis.itemState & ODS_DISABLED) == ODS_DISABLED)
+			|| ((UDMI.dis.itemState & ODS_INACTIVE) == ODS_INACTIVE))
+		{
+			// disabled / grey text / inactive
+			iTextStateID = MBI_DISABLED;
+			iBackgroundStateID = MBI_DISABLED;
+		}
+		else if ((UDMI.dis.itemState & ODS_DEFAULT) == ODS_DEFAULT)
+		{
+			// normal display
+			iTextStateID = MBI_NORMAL;
+			iBackgroundStateID = MBI_NORMAL;
+		}
+
+		if ((UDMI.dis.itemState & ODS_NOACCEL) == ODS_NOACCEL)
+		{
+			dwFlags |= DT_HIDEPREFIX;
+		}
+
+		switch (iBackgroundStateID)
+		{
+			case MBI_NORMAL:
+			case MBI_DISABLED:
+			{
+				::FillRect(UDMI.um.hdc, &UDMI.dis.rcItem, DarkMode::getDlgBackgroundBrush());
+				break;
+			}
+
+			case MBI_HOT:
+			case MBI_DISABLEDHOT:
+			{
+				::FillRect(UDMI.um.hdc, &UDMI.dis.rcItem, DarkMode::getHotBackgroundBrush());
+				break;
+			}
+
+			case MBI_PUSHED:
+			case MBI_DISABLEDPUSHED:
+			{
+				::FillRect(UDMI.um.hdc, &UDMI.dis.rcItem, DarkMode::getCtrlBackgroundBrush());
+				break;
+			}
+
+			default:
+			{
+				::DrawThemeBackground(hTheme, UDMI.um.hdc, MENU_BARITEM, iBackgroundStateID, &UDMI.dis.rcItem, nullptr);
+				break;
+			}
+		}
+
+		DTTOPTS dttopts{};
+		dttopts.dwSize = sizeof(DTTOPTS);
+		dttopts.dwFlags = DTT_TEXTCOLOR;
+		switch (iTextStateID)
+		{
+			case MBI_NORMAL:
+			case MBI_HOT:
+			case MBI_PUSHED:
+			{
+				dttopts.crText = DarkMode::getTextColor();
+				break;
+			}
+
+			case MBI_DISABLED:
+			case MBI_DISABLEDHOT:
+			case MBI_DISABLEDPUSHED:
+			{
+				dttopts.crText = DarkMode::getDisabledTextColor();
+				break;
+			}
+
+			default:
+			{
+				break;
+			}
+		}
+
+		::DrawThemeTextEx(hTheme, UDMI.um.hdc, MENU_BARITEM, iTextStateID, buffer.c_str(), static_cast<int>(mii.cch), dwFlags, &UDMI.dis.rcItem, &dttopts);
+	}
+
+	/**
+	 * @brief Over-paints the 1-pixel light line under a menu bar with custom color.
+	 *
+	 * Called post-paint to overwrite non-client leftovers that break custom color styling.
+	 * Computes exact line position based on `MenuBarInfo`, and fills with custom color.
+	 *
+	 * @param hWnd Handle to the window with a menu bar.
+	 *
+	 * @see DarkMode::WindowMenuBarSubclass()
+	 */
+	static void drawUAHMenuNCBottomLine(HWND hWnd)
+	{
+		MENUBARINFO mbi{};
+		mbi.cbSize = sizeof(MENUBARINFO);
+		if (::GetMenuBarInfo(hWnd, OBJID_MENU, 0, &mbi) == FALSE)
+		{
+			return;
+		}
+
+		RECT rcClient{};
+		::GetClientRect(hWnd, &rcClient);
+		::MapWindowPoints(hWnd, nullptr, reinterpret_cast<POINT*>(&rcClient), 2);
+
+		RECT rcWindow{};
+		::GetWindowRect(hWnd, &rcWindow);
+
+		::OffsetRect(&rcClient, -rcWindow.left, -rcWindow.top);
+
+		// the rcBar is offset by the window rect
+		RECT rcAnnoyingLine{ rcClient };
+		rcAnnoyingLine.bottom = rcAnnoyingLine.top;
+		rcAnnoyingLine.top--;
+
+
+		HDC hdc = ::GetWindowDC(hWnd);
+		::FillRect(hdc, &rcAnnoyingLine, DarkMode::getDlgBackgroundBrush());
+		::ReleaseDC(hWnd, hdc);
+	}
+
+	/**
+	 * @brief Window subclass procedure for custom color for themed menu bar.
+	 *
+	 * Applies custom colors for menu bar, but not for popup menus.
+	 *
+	 * @param hWnd Window handle being subclassed.
+	 * @param uMsg Message identifier.
+	 * @param wParam Message-specific data.
+	 * @param lParam Message-specific data.
+	 * @param uIdSubclass Subclass identifier.
+	 * @param dwRefData ThemeData instance.
+	 * @return LRESULT Result of message processing.
+	 *
+	 * @see DarkMode::setWindowMenuBarSubclass()
+	 * @see DarkMode::removeWindowMenuBarSubclass()
+	 */
+	static LRESULT CALLBACK WindowMenuBarSubclass(
+		HWND hWnd,
+		UINT uMsg,
+		WPARAM wParam,
+		LPARAM lParam,
+		UINT_PTR uIdSubclass,
+		DWORD_PTR dwRefData
+	)
+	{
+		auto* pMenuThemeData = reinterpret_cast<ThemeData*>(dwRefData);
+
+		if (uMsg != WM_NCDESTROY && (!DarkMode::isEnabled() || !pMenuThemeData->ensureTheme(hWnd)))
+		{
+			return ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
+		}
+
+		switch (uMsg)
+		{
+			case WM_NCDESTROY:
+			{
+				::RemoveWindowSubclass(hWnd, WindowMenuBarSubclass, uIdSubclass);
+				delete pMenuThemeData;
+				break;
+			}
+
+			case WM_UAHDRAWMENU:
+			{
+				auto* pUDM = reinterpret_cast<UAHMENU*>(lParam);
+				DarkMode::paintMenuBar(hWnd, pUDM->hdc);
+
+				return 0;
+			}
+
+			case WM_UAHDRAWMENUITEM:
+			{
+				const auto& hTheme = pMenuThemeData->getHTheme();
+				auto* pUDMI = reinterpret_cast<UAHDRAWMENUITEM*>(lParam);
+				DarkMode::paintMenuBarItems(*pUDMI, hTheme);
+
+				return 0;
+			}
+
+#if 0 // for debugging
+			case WM_UAHMEASUREMENUITEM:
+			{
+				auto* pMMI = reinterpret_cast<UAHMEASUREMENUITEM*>(lParam);
+				return ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
+			}
+#endif
+
+			case WM_DPICHANGED:
+			case WM_DPICHANGED_AFTERPARENT:
+			case WM_THEMECHANGED:
+			{
+				pMenuThemeData->closeTheme();
+				break;
+			}
+
+			case WM_NCACTIVATE:
+			case WM_NCPAINT:
+			{
+				const LRESULT retVal = ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
+				DarkMode::drawUAHMenuNCBottomLine(hWnd);
+				return retVal;
+			}
+
+			default:
+			{
+				break;
+			}
+		}
+		return ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
+	}
+
+	/**
+	 * @brief Applies window subclassing for menu bar themed custom drawing.
+	 *
+	 * Installs @ref DarkMode::WindowMenuBarSubclass with an associated `ThemeData` instance
+	 * for the `VSCLASS_MENU` visual style. Enables custom drawing
+	 * behavior for menu bar.
+	 *
+	 * @param hWnd Handle to the window with a menu bar.
+	 *
+	 * @see DarkMode::WindowMenuBarSubclass()
+	 * @see DarkMode::removeWindowMenuBarSubclass()
+	 */
+	void setWindowMenuBarSubclass(HWND hWnd)
+	{
+		DarkMode::setSubclass<ThemeData>(hWnd, WindowMenuBarSubclass, kWindowMenuBarSubclassID, VSCLASS_MENU);
+	}
+
+	/**
+	 * @brief Removes the subclass used for menu bar themed custom drawing.
+	 *
+	 * Detaches the window's subclass proc used for menu bar themed custom drawing.
+	 *
+	 * @param hWnd Handle to the previously subclassed window.
+	 *
+	 * @see DarkMode::WindowMenuBarSubclass()
+	 * @see DarkMode::setWindowMenuBarSubclass()
+	 */
+	void removeWindowMenuBarSubclass(HWND hWnd)
+	{
+		DarkMode::removeSubclass<ThemeData>(hWnd, WindowMenuBarSubclass, kWindowMenuBarSubclassID);
+	}
+
+	/**
+	 * @brief Window subclass procedure for handling `WM_SETTINGCHANGE` message.
+	 *
+	 * Handles `WM_SETTINGCHANGE` to perform changes for dark mode based on system setting.
+	 *
+	 * @param hWnd Window handle being subclassed.
+	 * @param uMsg Message identifier.
+	 * @param wParam Message-specific data.
+	 * @param lParam Message-specific data.
+	 * @param uIdSubclass Subclass identifier.
+	 * @param dwRefData Reserved data (unused).
+	 * @return LRESULT Result of message processing.
+	 *
+	 * @see DarkMode::setWindowSettingChangeSubclass()
+	 * @see DarkMode::removeWindowSettingChangeSubclass()
+	 */
+	static LRESULT CALLBACK WindowSettingChangeSubclass(
+		HWND hWnd,
+		UINT uMsg,
+		WPARAM wParam,
+		LPARAM lParam,
+		UINT_PTR uIdSubclass,
+		[[maybe_unused]] DWORD_PTR dwRefData
+	)
+	{
+		switch (uMsg)
+		{
+			case WM_NCDESTROY:
+			{
+				::RemoveWindowSubclass(hWnd, WindowSettingChangeSubclass, uIdSubclass);
+				break;
+			}
+
+			case WM_SETTINGCHANGE:
+			{
+				if (DarkMode::handleSettingChange(lParam))
+				{
+					DarkMode::setDarkTitleBarEx(hWnd, true);
+					DarkMode::setChildCtrlsTheme(hWnd);
+					::RedrawWindow(hWnd, nullptr, nullptr, RDW_INVALIDATE | RDW_ERASE | RDW_ALLCHILDREN | RDW_UPDATENOW | RDW_FRAME);
+				}
+				break;
+			}
+
+			default:
+			{
+				break;
+			}
+		}
+		return ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
+	}
+
+	/**
+	 * @brief Applies window subclassing to handle `WM_SETTINGCHANGE` message.
+	 *
+	 * Enable monitoring WM_SETTINGCHANGE message,
+	 * allowing the app to respond to system-wide dark mode change.
+	 *
+	 * @param hWnd Handle to the main window.
+	 *
+	 * @see DarkMode::WindowSettingChangeSubclass()
+	 * @see DarkMode::removeWindowSettingChangeSubclass()
+	 */
+	void setWindowSettingChangeSubclass(HWND hWnd)
+	{
+		DarkMode::setSubclass(hWnd, WindowSettingChangeSubclass, kWindowSettingChangeSubclassID);
+	}
+
+	/**
+	 * @brief Removes the subclass used for `WM_SETTINGCHANGE` message handling.
+	 *
+	 * Detaches the window's subclass proc used for `WM_SETTINGCHANGE` messages handling.
+	 *
+	 * @param hWnd Handle to the previously subclassed window.
+	 *
+	 * @see DarkMode::WindowSettingChangeSubclass()
+	 * @see DarkMode::setWindowSettingChangeSubclass()
+	 */
+	void removeWindowSettingChangeSubclass(HWND hWnd)
+	{
+		DarkMode::removeSubclass(hWnd, WindowSettingChangeSubclass, kWindowSettingChangeSubclassID);
+	}
+
+	/**
+	 * @brief Configures the SysLink control to be affected by `WM_CTLCOLORSTATIC` message.
+	 *
+	 * Configures all items to either use default system link colors if in classic mode,
+	 * or to be affected by `WM_CTLCOLORSTATIC` message from its parent.
+	 *
+	 * @param hWnd Handle to the SysLink control.
+	 *
+	 * @note Will affect all items, even if it's static (non-clickable).
+	 */
+	void enableSysLinkCtrlCtlColor(HWND hWnd)
+	{
+		LITEM lItem{};
+		lItem.iLink = 0;
+		lItem.mask = LIF_ITEMINDEX | LIF_STATE;
+		lItem.state = DarkMode::isEnabled() ? LIS_DEFAULTCOLORS : 0;
+		lItem.stateMask = LIS_DEFAULTCOLORS;
+		while (::SendMessage(hWnd, LM_SETITEM, 0, reinterpret_cast<LPARAM>(&lItem)) == TRUE)
+		{
+			++lItem.iLink;
+		}
+	}
+
+	/**
+	 * @brief Sets dark title bar and optional Windows 11 features.
+	 *
+	 * For Windows 10 (2004+) and newer, this function configures the dark title bar using
+	 * `DWMWA_USE_IMMERSIVE_DARK_MODE`. On Windows 11, if `useWin11Features` is `true`, it
+	 * additionally applies:
+	 * - Rounded corners (`DWMWA_WINDOW_CORNER_PREFERENCE`)
+	 * - Border color (`DWMWA_BORDER_COLOR`)
+	 * - Mica backdrop (`DWMWA_SYSTEMBACKDROP_TYPE`) if allowed and compatible
+	 * - Static text color for text and dialog background color for background
+	 *   (`DWMWA_CAPTION_COLOR`, `DWMWA_TEXT_COLOR`),
+	 *   only when frames are not extended to full window
+	 *
+	 * If `_DARKMODELIB_ALLOW_OLD_OS` is defined with non-zero unsigned value
+	 * and running on pre-2004 builds, fallback behavior will enable dark title bars via undocumented APIs.
+	 *
+	 * @param hWnd Handle to the top-level window.
+	 * @param useWin11Features `true` to enable Windows 11 specific features such as Mica and rounded corners.
+	 *
+	 * @note Requires Windows 10 version 2004 (build 19041) or later.
+	 *
+	 * @see DwmSetWindowAttribute
+	 * @see DwmExtendFrameIntoClientArea
+	 */
+	void setDarkTitleBarEx(HWND hWnd, bool useWin11Features)
+	{
+		static constexpr DWORD win10Build2004 = 19041;
+		static constexpr DWORD win11Mica = 22621;
+		if (DarkMode::getWindowsBuildNumber() >= win10Build2004)
+		{
+			const BOOL useDark = DarkMode::isExperimentalActive() ? TRUE : FALSE;
+			::DwmSetWindowAttribute(hWnd, DWMWA_USE_IMMERSIVE_DARK_MODE, &useDark, sizeof(useDark));
+
+			if (useWin11Features && DarkMode::isAtLeastWindows11())
+			{
+				::DwmSetWindowAttribute(hWnd, DWMWA_WINDOW_CORNER_PREFERENCE, &g_dmCfg._roundCorner, sizeof(g_dmCfg._roundCorner));
+				::DwmSetWindowAttribute(hWnd, DWMWA_BORDER_COLOR, &g_dmCfg._borderColor, sizeof(g_dmCfg._borderColor));
+
+				bool canColorizeTitleBar = true;
+
+				if (DarkMode::getWindowsBuildNumber() >= win11Mica)
+				{
+					if (g_dmCfg._micaExtend && g_dmCfg._mica != DWMSBT_AUTO && !DarkMode::isWindowsModeEnabled() && (g_dmCfg._dmType == DarkModeType::dark))
+					{
+						static constexpr MARGINS margins{ -1, 0, 0, 0 };
+						::DwmExtendFrameIntoClientArea(hWnd, &margins);
+					}
+
+					::DwmSetWindowAttribute(hWnd, DWMWA_SYSTEMBACKDROP_TYPE, &g_dmCfg._mica, sizeof(g_dmCfg._mica));
+
+					canColorizeTitleBar = !g_dmCfg._micaExtend;
+				}
+
+				canColorizeTitleBar = g_dmCfg._colorizeTitleBar && canColorizeTitleBar && DarkMode::isEnabled();
+				const COLORREF clrDlg = canColorizeTitleBar ? DarkMode::getDlgBackgroundColor() : DWMWA_COLOR_DEFAULT;
+				const COLORREF clrText = canColorizeTitleBar ? DarkMode::getTextColor() : DWMWA_COLOR_DEFAULT;
+				::DwmSetWindowAttribute(hWnd, DWMWA_CAPTION_COLOR, &clrDlg, sizeof(clrDlg));
+				::DwmSetWindowAttribute(hWnd, DWMWA_TEXT_COLOR, &clrText, sizeof(clrText));
+			}
+		}
+#if defined(_DARKMODELIB_ALLOW_OLD_OS) && (_DARKMODELIB_ALLOW_OLD_OS > 0)
+		else
+		{
+			DarkMode::allowDarkModeForWindow(hWnd, DarkMode::isExperimentalActive());
+			DarkMode::setTitleBarThemeColor(hWnd);
+		}
+#endif
+	}
+
+	/**
+	 * @brief Sets dark mode title bar on supported Windows versions.
+	 *
+	 * Delegates to @ref setDarkTitleBarEx with `useWin11Features = false`.
+	 *
+	 * @param hWnd Handle to the top-level window.
+	 *
+	 * @see DarkMode::setDarkTitleBarEx()
+	 */
+	void setDarkTitleBar(HWND hWnd)
+	{
+		DarkMode::setDarkTitleBarEx(hWnd, false);
+	}
+
+	/**
+	 * @brief Applies an experimental visual style to the specified window, if supported.
+	 *
+	 * When experimental features are supported and active,
+	 * this function enables dark experimental visual style on the window.
+	 *
+	 * @param hWnd Handle to the target window or control.
+	 * @param themeClassName Name of the theme class to apply (e.g. L"Explorer", "ItemsView").
+	 *
+	 * @note This function is a no-op if experimental theming is not supported on the current OS.
+	 *
+	 * @see DarkMode::isExperimentalSupported()
+	 * @see DarkMode::isExperimentalActive()
+	 * @see DarkMode::allowDarkModeForWindow()
+	 */
+	void setDarkThemeExperimental(HWND hWnd, const wchar_t* themeClassName)
+	{
+		if (DarkMode::isExperimentalSupported())
+		{
+			DarkMode::allowDarkModeForWindow(hWnd, DarkMode::isExperimentalActive());
+			::SetWindowTheme(hWnd, themeClassName, nullptr);
+		}
+	}
+
+	/**
+	 * @brief Applies "DarkMode_Explorer" visual style if experimental mode is active.
+	 *
+	 * Useful for controls like list views or tree views to use dark scroll bars
+	 * and explorer style theme in supported environments.
+	 *
+	 * @param hWnd Handle to the control or window to theme.
+	 */
+	void setDarkExplorerTheme(HWND hWnd)
+	{
+		::SetWindowTheme(hWnd, DarkMode::isExperimentalActive() ? L"DarkMode_Explorer" : nullptr, nullptr);
+	}
+
+	/**
+	 * @brief Applies "DarkMode_Explorer" visual style to scroll bars.
+	 *
+	 * Convenience wrapper that calls @ref DarkMode::setDarkExplorerTheme to apply dark scroll bar
+	 * for compatible controls (e.g. list views, tree views).
+	 *
+	 * @param hWnd Handle to the control with scroll bars.
+	 *
+	 * @see DarkMode::setDarkExplorerTheme()
+	 */
+	void setDarkScrollBar(HWND hWnd)
+	{
+		DarkMode::setDarkExplorerTheme(hWnd);
+	}
+
+	/**
+	 * @brief Applies "DarkMode_Explorer" visual style to tooltip controls based on context.
+	 *
+	 * Selects the appropriate `GETTOOLTIPS` message depending on the control type
+	 * (e.g. toolbar, list view, tree view, tab bar) to retrieve the tooltip handle.
+	 * If `ToolTipsType::tooltip` is specified, applies theming directly to `hWnd`.
+	 *
+	 * Internally calls @ref DarkMode::setDarkExplorerTheme to set dark tooltip.
+	 *
+	 * @param hWnd Handle to the parent control or tooltip.
+	 * @param type The tooltip context type (toolbar, list view, etc.).
+	 *
+	 * @see DarkMode::setDarkExplorerTheme()
+	 * @see ToolTipsType
+	 */
+	void setDarkTooltips(HWND hWnd, ToolTipsType type)
+	{
+		UINT msg = 0;
+		switch (type)
+		{
+			case DarkMode::ToolTipsType::toolbar:
+			{
+				msg = TB_GETTOOLTIPS;
+				break;
+			}
+
+			case DarkMode::ToolTipsType::listview:
+			{
+				msg = LVM_GETTOOLTIPS;
+				break;
+			}
+
+			case DarkMode::ToolTipsType::treeview:
+			{
+				msg = TVM_GETTOOLTIPS;
+				break;
+			}
+
+			case DarkMode::ToolTipsType::tabbar:
+			{
+				msg = TCM_GETTOOLTIPS;
+				break;
+			}
+
+			case DarkMode::ToolTipsType::trackbar:
+			{
+				msg = TBM_GETTOOLTIPS;
+				break;
+			}
+
+			case DarkMode::ToolTipsType::rebar:
+			{
+				msg = RB_GETTOOLTIPS;
+				break;
+			}
+
+			case DarkMode::ToolTipsType::tooltip:
+			{
+				msg = 0;
+				break;
+			}
+		}
+
+		if (msg == 0)
+		{
+			DarkMode::setDarkExplorerTheme(hWnd);
+		}
+		else
+		{
+			auto hTips = reinterpret_cast<HWND>(::SendMessage(hWnd, msg, 0, 0));
+			if (hTips != nullptr)
+			{
+				DarkMode::setDarkExplorerTheme(hTips);
+			}
+		}
+	}
+
+	/**
+	 * @brief Sets the color of line above a toolbar control for non-classic mode.
+	 *
+	 * Sends `TB_SETCOLORSCHEME` to customize the line drawn above the toolbar.
+	 * When non-classic mode is enabled, sets both `clrBtnHighlight` and `clrBtnShadow`
+	 * to the dialog background color, otherwise uses system defaults.
+	 *
+	 * @param hWnd Handle to the toolbar control.
+	 */
+	void setDarkLineAbovePanelToolbar(HWND hWnd)
+	{
+		COLORSCHEME scheme{};
+		scheme.dwSize = sizeof(COLORSCHEME);
+
+		if (DarkMode::isEnabled())
+		{
+			scheme.clrBtnHighlight = DarkMode::getDlgBackgroundColor();
+			scheme.clrBtnShadow = DarkMode::getDlgBackgroundColor();
+		}
+		else
+		{
+			scheme.clrBtnHighlight = CLR_DEFAULT;
+			scheme.clrBtnShadow = CLR_DEFAULT;
+		}
+
+		::SendMessage(hWnd, TB_SETCOLORSCHEME, 0, reinterpret_cast<LPARAM>(&scheme));
+	}
+
+	/**
+	 * @brief Applies an experimental Explorer visual style to a list view.
+	 *
+	 * Uses @ref DarkMode::setDarkThemeExperimental with the `"Explorer"` theme class to adapt
+	 * list view visuals (e.g. scroll bars, selection color) for dark mode, if supported.
+	 *
+	 * @param hWnd Handle to the list view control.
+	 *
+	 * @see DarkMode::setDarkThemeExperimental()
+	 */
+	void setDarkListView(HWND hWnd)
+	{
+		DarkMode::setDarkThemeExperimental(hWnd, L"Explorer");
+	}
+
+	/**
+	 * @brief Replaces default list view checkboxes with themed dark-mode versions on Windows 11.
+	 *
+	 * If the list view uses `LVS_EX_CHECKBOXES` and is running on Windows 11 or later,
+	 * this function manually renders the unchecked and checked checkbox visuals using
+	 * themed drawing APIs, then inserts the resulting icons into the state image list.
+	 *
+	 * Uses `"DarkMode_Explorer::Button"` as the theme class if experimental dark mode is active;
+	 * otherwise falls back to `VSCLASS_BUTTON`.
+	 *
+	 * @param hWnd Handle to the list view control with extended checkbox style.
+	 *
+	 * @note Does nothing on pre-Windows 11 systems or if checkboxes are not enabled.
+	 */
+	void setDarkListViewCheckboxes(HWND hWnd)
+	{
+		if (!DarkMode::isAtLeastWindows11())
+		{
+			return;
+		}
+
+		const auto lvExStyle = ListView_GetExtendedListViewStyle(hWnd);
+		if ((lvExStyle & LVS_EX_CHECKBOXES) != LVS_EX_CHECKBOXES)
+		{
+			return;
+		}
+
+		HDC hdc = ::GetDC(nullptr);
+
+		const bool useDark = DarkMode::isExperimentalActive() && DarkMode::isThemeDark();
+		HTHEME hTheme = ::OpenThemeData(nullptr, useDark ? L"DarkMode_Explorer::Button" : VSCLASS_BUTTON);
+
+		SIZE szBox{};
+		::GetThemePartSize(hTheme, hdc, BP_CHECKBOX, CBS_UNCHECKEDNORMAL, nullptr, TS_DRAW, &szBox);
+
+		const RECT rcBox{ 0, 0, szBox.cx, szBox.cy };
+
+		auto hImgList = ListView_GetImageList(hWnd, LVSIL_STATE);
+		if (hImgList == nullptr)
+		{
+			::CloseThemeData(hTheme);
+			::ReleaseDC(nullptr, hdc);
+			return;
+		}
+		::ImageList_RemoveAll(hImgList);
+
+		HDC hBoxDC = ::CreateCompatibleDC(hdc);
+		HBITMAP hBoxBmp = ::CreateCompatibleBitmap(hdc, szBox.cx, szBox.cy);
+		HBITMAP hMaskBmp = ::CreateCompatibleBitmap(hdc, szBox.cx, szBox.cy);
+
+		auto holdBmp = static_cast<HBITMAP>(::SelectObject(hBoxDC, hBoxBmp));
+		::DrawThemeBackground(hTheme, hBoxDC, BP_CHECKBOX, CBS_UNCHECKEDNORMAL, &rcBox, nullptr);
+
+		ICONINFO ii{};
+		ii.fIcon = TRUE;
+		ii.hbmColor = hBoxBmp;
+		ii.hbmMask = hMaskBmp;
+
+		HICON hIcon = ::CreateIconIndirect(&ii);
+		if (hIcon != nullptr)
+		{
+			::ImageList_AddIcon(hImgList, hIcon);
+			::DestroyIcon(hIcon);
+			hIcon = nullptr;
+		}
+
+		::DrawThemeBackground(hTheme, hBoxDC, BP_CHECKBOX, CBS_CHECKEDNORMAL, &rcBox, nullptr);
+		ii.hbmColor = hBoxBmp;
+
+		hIcon = ::CreateIconIndirect(&ii);
+		if (hIcon != nullptr)
+		{
+			::ImageList_AddIcon(hImgList, hIcon);
+			::DestroyIcon(hIcon);
+			hIcon = nullptr;
+		}
+
+		::SelectObject(hBoxDC, holdBmp);
+		::DeleteObject(hMaskBmp);
+		::DeleteObject(hBoxBmp);
+		::DeleteDC(hBoxDC);
+		::CloseThemeData(hTheme);
+		::ReleaseDC(nullptr, hdc);
+	}
+
+	/**
+	 * @brief Sets colors and edges for a RichEdit control.
+	 *
+	 * Determines if the control has `WS_BORDER` or `WS_EX_STATICEDGE`, and sets the background
+	 * accordingly: uses control background color when edged, otherwise dialog background.
+	 *
+	 * In dark mode:
+	 * - Sets background color via `EM_SETBKGNDCOLOR`
+	 * - Updates default text color via `EM_SETCHARFORMAT`
+	 * - Applies themed scroll bars using `DarkMode_Explorer::ScrollBar`
+	 *
+	 * When not in dark mode, restores default visual styles and coloring.
+	 * Also conditionally swaps `WS_BORDER` and `WS_EX_STATICEDGE`.
+	 *
+	 * @param hWnd Handle to the RichEdit control.
+	 *
+	 * @see DarkMode::setWindowStyle()
+	 * @see DarkMode::setWindowExStyle()
+	 */
+	void setDarkRichEdit(HWND hWnd)
+	{
+		const auto nStyle = ::GetWindowLongPtr(hWnd, GWL_STYLE);
+		const bool hasBorder = (nStyle & WS_BORDER) == WS_BORDER;
+
+		const auto nExStyle = ::GetWindowLongPtr(hWnd, GWL_EXSTYLE);
+		const bool hasStaticEdge = (nExStyle & WS_EX_STATICEDGE) == WS_EX_STATICEDGE;
+
+		if (DarkMode::isEnabled())
+		{
+			const COLORREF clrBg = (hasStaticEdge || hasBorder ? DarkMode::getCtrlBackgroundColor() : DarkMode::getDlgBackgroundColor());
+			::SendMessage(hWnd, EM_SETBKGNDCOLOR, 0, static_cast<LPARAM>(clrBg));
+
+			CHARFORMATW cf{};
+			cf.cbSize = sizeof(CHARFORMATW);
+			cf.dwMask = CFM_COLOR;
+			cf.crTextColor = DarkMode::getTextColor();
+			::SendMessage(hWnd, EM_SETCHARFORMAT, SCF_DEFAULT, reinterpret_cast<LPARAM>(&cf));
+
+			::SetWindowTheme(hWnd, nullptr, L"DarkMode_Explorer::ScrollBar");
+		}
+		else
+		{
+			::SendMessage(hWnd, EM_SETBKGNDCOLOR, TRUE, 0);
+			::SendMessage(hWnd, EM_SETCHARFORMAT, 0, 0);
+
+			::SetWindowTheme(hWnd, nullptr, nullptr);
+		}
+
+		DarkMode::setWindowStyle(hWnd, DarkMode::isEnabled() && hasStaticEdge, WS_BORDER);
+		DarkMode::setWindowExStyle(hWnd, !DarkMode::isEnabled() && hasBorder, WS_EX_STATICEDGE);
+	}
+
+	/**
+	 * @brief Applies visual styles; ctl color message and child controls subclassings to a window safely.
+	 *
+	 * Ensures the specified window is not `nullptr` and then:
+	 * - Enables the dark title bar
+	 * - Subclasses the window for control ctl coloring
+	 * - Applies theming and subclassing to child controls
+	 *
+	 *
+	 * @param hWnd Handle to the window. No action taken if `nullptr`.
+	 * @param useWin11Features `true` to enable Windows 11 specific styling like Mica or rounded corners.
+	 *
+	 * @note Should not be used in combination with @ref DarkMode::setDarkWndNotifySafeEx
+	 *       and @ref DarkMode::setDarkWndNotifySafe to avoid overlapping styling logic.
+	 *
+	 * @see DarkMode::setDarkWndNotifySafeEx()
+	 * @see DarkMode::setDarkWndNotifySafe()
+	 * @see DarkMode::setDarkTitleBarEx()
+	 * @see DarkMode::setWindowCtlColorSubclass()
+	 * @see DarkMode::setChildCtrlsSubclassAndTheme()
+	 */
+	void setDarkWndSafe(HWND hWnd, bool useWin11Features)
+	{
+		if (hWnd == nullptr)
+		{
+			return;
+		}
+
+		DarkMode::setDarkTitleBarEx(hWnd, useWin11Features);
+		DarkMode::setWindowCtlColorSubclass(hWnd);
+		DarkMode::setChildCtrlsSubclassAndTheme(hWnd);
+	}
+
+	/**
+	 * @brief Applies visual styles; ctl color message, child controls, custom drawing, and setting change subclassings to a window safely.
+	 *
+	 * Ensures the specified window is not `nullptr` and then:
+	 * - Enables the dark title bar
+	 * - Subclasses the window for control coloring
+	 * - Applies theming and subclassing to child controls
+	 * - Enables custom draw-based theming via notification subclassing
+	 * - Subclasses the window to handle dark mode change if window mode is enabled.
+	 *
+	 * @param hWnd Handle to the window. No action taken if `nullptr`.
+	 * @param setSettingChangeSubclass `true` to set setting change subclass if applicable.
+	 * @param useWin11Features `true` to enable Windows 11 specific styling like Mica or rounded corners.
+	 *
+	 * @note `setSettingChangeSubclass = true` should be used only on main window.
+	 *       For other secondary windows and controls use @ref DarkMode::setDarkWndNotifySafe.
+	 *       Should not be used in combination with @ref DarkMode::setDarkWndSafe
+	 *       and @ref DarkMode::setDarkWndNotifySafe to avoid overlapping styling logic.
+	 *
+	 * @see DarkMode::setDarkWndNotifySafe()
+	 * @see DarkMode::setDarkWndSafe()
+	 * @see DarkMode::setDarkTitleBarEx()
+	 * @see DarkMode::setWindowCtlColorSubclass()
+	 * @see DarkMode::setWindowNotifyCustomDrawSubclass()
+	 * @see DarkMode::setChildCtrlsSubclassAndTheme()
+	 * @see DarkMode::isWindowsModeEnabled()
+	 * @see DarkMode::setWindowSettingChangeSubclass()
+	 */
+	void setDarkWndNotifySafeEx(HWND hWnd, bool setSettingChangeSubclass, bool useWin11Features)
+	{
+		if (hWnd == nullptr)
+		{
+			return;
+		}
+
+		DarkMode::setDarkTitleBarEx(hWnd, useWin11Features);
+		DarkMode::setWindowCtlColorSubclass(hWnd);
+		DarkMode::setWindowNotifyCustomDrawSubclass(hWnd);
+		DarkMode::setChildCtrlsSubclassAndTheme(hWnd);
+		if (setSettingChangeSubclass && DarkMode::isWindowsModeEnabled())
+		{
+			DarkMode::setWindowSettingChangeSubclass(hWnd);
+		}
+	}
+
+	/**
+	 * @brief Applies visual styles; ctl color message, child controls, and custom drawing subclassings to a window safely.
+	 *
+	 * Calls @ref DarkMode::setDarkWndNotifySafeEx with `setSettingChangeSubclass = false`, streamlining
+	 * dark mode setup for secondary or transient windows that don't need to track system dark mode changes.
+	 *
+	 * @param hWnd Handle to the target window.
+	 * @param useWin11Features Enable Windows 11-specific visual effects (e.g., Mica, rounded corners).
+	 *
+	 * @note Should not be used in combination with @ref DarkMode::setDarkWndSafe
+	 *       and @ref DarkMode::setDarkWndNotifySafeEx to avoid overlapping styling logic.
+	 *
+	 * @see DarkMode::setDarkWndNotifySafeEx()
+	 * @see DarkMode::setDarkWndSafe()
+	 */
+	void setDarkWndNotifySafe(HWND hWnd, bool useWin11Features)
+	{
+		DarkMode::setDarkWndNotifySafeEx(hWnd, false, useWin11Features);
+	}
+
+	/**
+	 * @brief Enables or disables theme-based dialog background textures in classic mode.
+	 *
+	 * Applies `ETDT_ENABLETAB` only when `theme` is `true` and the current mode is classic.
+	 * This replaces the default classic gray background with a lighter themed texture.
+	 * Otherwise disables themed dialog textures with `ETDT_DISABLE`.
+	 *
+	 * @param hWnd Handle to the target dialog window.
+	 * @param theme `true` to enable themed tab textures in classic mode.
+	 *
+	 * @see EnableThemeDialogTexture
+	 */
+	void enableThemeDialogTexture(HWND hWnd, bool theme)
+	{
+		::EnableThemeDialogTexture(hWnd, theme && (g_dmCfg._dmType == DarkModeType::classic) ? ETDT_ENABLETAB : ETDT_DISABLE);
+	}
+
+	/**
+	 * @brief Enables or disables visual styles for a window.
+	 *
+	 * Applies `SetWindowTheme(hWnd, L"", L"")` when `doDisable` is `true`, effectively removing
+	 * the current theme. Restores default theming when `doDisable` is `false`.
+	 *
+	 * @param hWnd Handle to the window.
+	 * @param doDisable `true` to strip visual styles, `false` to re-enable them.
+	 *
+	 * @see SetWindowTheme
+	 */
+	void disableVisualStyle(HWND hWnd, bool doDisable)
+	{
+		if (doDisable)
+		{
+			::SetWindowTheme(hWnd, L"", L"");
+		}
+		else
+		{
+			::SetWindowTheme(hWnd, nullptr, nullptr);
+		}
+	}
+
+	/**
+	 * @brief Calculates perceptual lightness of a COLORREF color.
+	 *
+	 * Converts the RGB color to linear space and calculates perceived lightness.
+	 *
+	 * @param clr COLORREF in 0xBBGGRR format.
+	 * @return Lightness value as a double.
+	 *
+	 * @note Based on: https://stackoverflow.com/a/56678483
+	 */
+	double calculatePerceivedLightness(COLORREF clr)
+	{
+		auto linearValue = [](double colorChannel) -> double {
+			colorChannel /= 255.0;
+
+			static constexpr double treshhold = 0.04045;
+			static constexpr double lowScalingFactor = 12.92;
+			static constexpr double gammaOffset = 0.055;
+			static constexpr double gammaScalingFactor = 1.055;
+			static constexpr double gammaExp = 2.4;
+
+			if (colorChannel <= treshhold)
+			{
+				return colorChannel / lowScalingFactor;
+			}
+			return std::pow(((colorChannel + gammaOffset) / gammaScalingFactor), gammaExp);
+		};
+
+		const double r = linearValue(static_cast<double>(GetRValue(clr)));
+		const double g = linearValue(static_cast<double>(GetGValue(clr)));
+		const double b = linearValue(static_cast<double>(GetBValue(clr)));
+
+		static constexpr double rWeight = 0.2126;
+		static constexpr double gWeight = 0.7152;
+		static constexpr double bWeight = 0.0722;
+
+		const double luminance = (rWeight * r) + (gWeight * g) + (bWeight * b);
+
+		static constexpr double cieEpsilon = 216.0 / 24389.0;
+		static constexpr double cieKappa = 24389.0 / 27.0;
+		static constexpr double oneThird = 1.0 / 3.0;
+		static constexpr double scalingFactor = 116.0;
+		static constexpr double offset = 16.0;
+
+		// calculate lightness
+
+		if (luminance <= cieEpsilon)
+		{
+			return (luminance * cieKappa);
+		}
+		return ((std::pow(luminance, oneThird) * scalingFactor) - offset);
+	}
+
+	/**
+	 * @brief Retrieves the current TreeView style configuration.
+	 *
+	 * @return Reference to the current `TreeViewStyle`.
+	 */
+	const TreeViewStyle& getTreeViewStyle()
+	{
+		return g_dmCfg._tvStyle;
+	}
+
+	/// Set TreeView style
+	static void setTreeViewStyle(TreeViewStyle tvStyle)
+	{
+		g_dmCfg._tvStyle = tvStyle;
+	}
+
+	/**
+	 * @brief Determines appropriate TreeView style based on background perceived lightness.
+	 *
+	 * Checks the perceived lightness of the current view background and
+	 * selects a corresponding style: dark, light, or classic. Style selection
+	 * is based on how far the lightness deviates from the middle gray threshold range
+	 * around the midpoint value (50.0).
+	 *
+	 * @see DarkMode::calculatePerceivedLightness()
+	 */
+	void calculateTreeViewStyle()
+	{
+		static constexpr double middle = 50.0;
+		const COLORREF bgColor = DarkMode::getViewBackgroundColor();
+
+		if (g_dmCfg._tvBackground != bgColor || g_dmCfg._lightness == middle)
+		{
+			g_dmCfg._lightness = DarkMode::calculatePerceivedLightness(bgColor);
+			g_dmCfg._tvBackground = bgColor;
+		}
+
+		if (g_dmCfg._lightness < (middle - kMiddleGrayRange))
+		{
+			DarkMode::setTreeViewStyle(TreeViewStyle::dark);
+		}
+		else if (g_dmCfg._lightness > (middle + kMiddleGrayRange))
+		{
+			DarkMode::setTreeViewStyle(TreeViewStyle::light);
+		}
+		else
+		{
+			DarkMode::setTreeViewStyle(TreeViewStyle::classic);
+		}
+	}
+
+	/**
+	 * @brief Applies the appropriate window theme style to the specified TreeView.
+	 *
+	 * Updates the TreeView's visual behavior and theme based on the currently selected
+	 * style @ref DarkMode::getTreeViewStyle. It conditionally adjusts the `TVS_TRACKSELECT`
+	 * style flag and applies a matching visual theme using `SetWindowTheme()`.
+	 *
+	 * If `force` is `true`, the style is applied regardless of previous state.
+	 * Otherwise, the update occurs only if the style has changed since the last update.
+	 *
+	 * - `light`: Enables `TVS_TRACKSELECT`, applies "Explorer" theme.
+	 * - `dark`: If supported, enables `TVS_TRACKSELECT`, applies "DarkMode_Explorer" theme.
+	 * - `classic`: Disables `TVS_TRACKSELECT`, clears the theme.
+	 *
+	 * @param hWnd Handle to the TreeView control.
+	 * @param force Whether to forcibly reapply the style even if unchanged.
+	 *
+	 * @see TreeViewStyle
+	 * @see DarkMode::getTreeViewStyle()
+	 * @see DarkMode::getPrevTreeViewStyle()
+	 */
+	void setTreeViewWindowTheme(HWND hWnd, bool force)
+	{
+		if (force || DarkMode::getPrevTreeViewStyle() != DarkMode::getTreeViewStyle())
+		{
+			auto nStyle = ::GetWindowLongPtr(hWnd, GWL_STYLE);
+			const bool hasHotStyle = (nStyle & TVS_TRACKSELECT) == TVS_TRACKSELECT;
+			bool change = false;
+			std::wstring strSubAppName;
+
+			switch (DarkMode::getTreeViewStyle())
+			{
+				case TreeViewStyle::light:
+				{
+					if (!hasHotStyle)
+					{
+						nStyle |= TVS_TRACKSELECT;
+						change = true;
+					}
+					strSubAppName = L"Explorer";
+					break;
+				}
+
+				case TreeViewStyle::dark:
+				{
+					if (DarkMode::isExperimentalSupported())
+					{
+						if (!hasHotStyle)
+						{
+							nStyle |= TVS_TRACKSELECT;
+							change = true;
+						}
+						strSubAppName = L"DarkMode_Explorer";
+						break;
+					}
+					[[fallthrough]];
+				}
+
+				case TreeViewStyle::classic:
+				{
+					if (hasHotStyle)
+					{
+						nStyle &= ~TVS_TRACKSELECT;
+						change = true;
+					}
+					strSubAppName = L"";
+					break;
+				}
+			}
+
+			if (change)
+			{
+				::SetWindowLongPtr(hWnd, GWL_STYLE, nStyle);
+			}
+
+			::SetWindowTheme(hWnd, strSubAppName.empty() ? nullptr : strSubAppName.c_str(), nullptr);
+		}
+	}
+
+	/**
+	 * @brief Retrieves the previous TreeView style configuration.
+	 *
+	 * @return Reference to the previous `TreeViewStyle`.
+	 */
+	const TreeViewStyle& getPrevTreeViewStyle()
+	{
+		return g_dmCfg._tvStylePrev;
+	}
+
+	/**
+	 * @brief Stores the current TreeView style as the previous style for later comparison.
+	 */
+	void setPrevTreeViewStyle()
+	{
+		g_dmCfg._tvStylePrev = DarkMode::getTreeViewStyle();
+	}
+
+	/**
+	 * @brief Checks whether the current theme is dark.
+	 *
+	 * Internally it use TreeView style to determine if dark theme is used.
+	 *
+	 * @return `true` if the active style is `TreeViewStyle::dark`, otherwise `false`.
+	 *
+	 * @see DarkMode::getTreeViewStyle()
+	 */
+	bool isThemeDark()
+	{
+		return DarkMode::getTreeViewStyle() == TreeViewStyle::dark;
+	}
+
+	/**
+	 * @brief Checks whether the color is dark.
+	 *
+	 * @param clr Color to check.
+	 *
+	 * @return `true` if the perceived lightness of the color
+	 *         is less than (50.0 - kMiddleGrayRange), otherwise `false`.
+	 *
+	 * @see DarkMode::calculatePerceivedLightness()
+	 */
+	bool isColorDark(COLORREF clr)
+	{
+		static constexpr double middle = 50.0;
+		return DarkMode::calculatePerceivedLightness(clr) < (middle - kMiddleGrayRange);
+	}
+
+	/**
+	 * @brief Forces a window to redraw its non-client frame.
+	 *
+	 * Triggers a non-client area update by using `SWP_FRAMECHANGED` without changing
+	 * size, position, or Z-order.
+	 *
+	 * @param hWnd Handle to the target window.
+	 */
+	void redrawWindowFrame(HWND hWnd)
+	{
+		::SetWindowPos(hWnd, nullptr, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);
+	}
+
+	/**
+	 * @brief Sets or clears a specific window style or extended style.
+	 *
+	 * Checks if the specified `dwFlag` is already set and toggles it if needed.
+	 * Only valid for `GWL_STYLE` or `GWL_EXSTYLE`.
+	 *
+	 * @param hWnd Handle to the window.
+	 * @param setFlag `true` to set the flag, `false` to clear it.
+	 * @param dwFlag Style bitmask to apply.
+	 * @param gwlIdx Either `GWL_STYLE` or `GWL_EXSTYLE`.
+	 * @return `TRUE` if modified, `FALSE` if unchanged, `-1` if invalid index.
+	 */
+	static int setWindowLongPtrStyle(HWND hWnd, bool setFlag, LONG_PTR dwFlag, int gwlIdx)
+	{
+		if ((gwlIdx != GWL_STYLE) && (gwlIdx != GWL_EXSTYLE))
+		{
+			return -1;
+		}
+
+		auto nStyle = ::GetWindowLongPtr(hWnd, gwlIdx);
+		const bool hasFlag = (nStyle & dwFlag) == dwFlag;
+
+		if (setFlag != hasFlag)
+		{
+			nStyle ^= dwFlag;
+			::SetWindowLongPtr(hWnd, gwlIdx, nStyle);
+			return TRUE;
+		}
+		return FALSE;
+	}
+
+	/**
+	 * @brief Sets a window's standard style flags and redraws window if needed.
+	 *
+	 * Wraps @ref DarkMode::setWindowLongPtrStyle with `GWL_STYLE`
+	 * and calls @ref DarkMode::redrawWindowFrame if a change occurs.
+	 *
+	 * @param hWnd Handle to the target window.
+	 * @param setStyle `true` to set the flag, `false` to remove it.
+	 * @param styleFlag Style bit to modify.
+	 */
+	void setWindowStyle(HWND hWnd, bool setStyle, LONG_PTR styleFlag)
+	{
+		if (DarkMode::setWindowLongPtrStyle(hWnd, setStyle, styleFlag, GWL_STYLE) == TRUE)
+		{
+			DarkMode::redrawWindowFrame(hWnd);
+		}
+	}
+
+	/**
+	 * @brief Sets a window's extended style flags and redraws window if needed.
+	 *
+	 * Wraps @ref DarkMode::setWindowLongPtrStyle with `GWL_EXSTYLE`
+	 * and calls @ref DarkMode::redrawWindowFrame if a change occurs.
+	 *
+	 * @param hWnd Handle to the target window.
+	 * @param setExStyle `true` to set the flag, `false` to remove it.
+	 * @param exStyleFlag Extended style bit to modify.
+	 */
+	void setWindowExStyle(HWND hWnd, bool setExStyle, LONG_PTR exStyleFlag)
+	{
+		if (DarkMode::setWindowLongPtrStyle(hWnd, setExStyle, exStyleFlag, GWL_EXSTYLE) == TRUE)
+		{
+			DarkMode::redrawWindowFrame(hWnd);
+		}
+	}
+
+	/**
+	 * @brief Replaces an extended edge (e.g. client edge) with a standard window border.
+	 *
+	 * The given `exStyleFlag` must be a valid edge-related extended window style:
+	 * - `WS_EX_CLIENTEDGE`
+	 * - `WS_EX_DLGMODALFRAME`
+	 * - `WS_EX_STATICEDGE`
+	 * - `WS_EX_WINDOWEDGE`
+	 * ...or any combination of these.
+	 *
+	 * If `replace` is `true`, the specified extended edge style(s) are removed and
+	 * `WS_BORDER` is applied. If `false`, the edge style(s) are restored and `WS_BORDER` is cleared.
+	 *
+	 * @param hWnd Handle to the target window.
+	 * @param replace `true` to apply standard border; `false` to restore extended edge(s).
+	 * @param exStyleFlag One or more valid edge-related extended styles.
+	 *
+	 * @see DarkMode::setWindowExStyle()
+	 * @see DarkMode::setWindowStyle()
+	 */
+	void replaceExEdgeWithBorder(HWND hWnd, bool replace, LONG_PTR exStyleFlag)
+	{
+		DarkMode::setWindowExStyle(hWnd, !replace, exStyleFlag);
+		DarkMode::setWindowStyle(hWnd, replace, WS_BORDER);
+	}
+
+	/**
+	 * @brief Safely toggles `WS_EX_CLIENTEDGE` with `WS_BORDER` based on dark mode state.
+	 *
+	 * If dark mode is enabled, removes `WS_EX_CLIENTEDGE` and applies `WS_BORDER`.
+	 * Otherwise restores the extended edge style.
+	 *
+	 * @param hWnd Handle to the target window. No action is taken if `hWnd` is `nullptr`.
+	 *
+	 * @see DarkMode::replaceExEdgeWithBorder()
+	 */
+	void replaceClientEdgeWithBorderSafe(HWND hWnd)
+	{
+		if (hWnd != nullptr)
+		{
+			DarkMode::replaceExEdgeWithBorder(hWnd, DarkMode::isEnabled(), WS_EX_CLIENTEDGE);
+		}
+	}
+
+	/**
+	 * @brief Applies classic-themed styling to a progress bar in non-classic mode.
+	 *
+	 * When dark mode is enabled, applies `WS_DLGFRAME`, removes visual styles
+	 * to allow to set custom background and fill colors using:
+	 * - Background: `DarkMode::getBackgroundColor()`
+	 * - Fill: Hardcoded green `0x06B025` via `PBM_SETBARCOLOR`
+	 *
+	 * Typically used for marquee style progress bar.
+	 *
+	 * @param hWnd Handle to the progress bar control.
+	 *
+	 * @see DarkMode::setWindowStyle()
+	 * @see DarkMode::disableVisualStyle()
+	 */
+	void setProgressBarClassicTheme(HWND hWnd)
+	{
+		DarkMode::setWindowStyle(hWnd, DarkMode::isEnabled(), WS_DLGFRAME);
+		DarkMode::disableVisualStyle(hWnd, DarkMode::isEnabled());
+		if (DarkMode::isEnabled())
+		{
+			::SendMessage(hWnd, PBM_SETBKCOLOR, 0, static_cast<LPARAM>(DarkMode::getCtrlBackgroundColor()));
+			static constexpr COLORREF greenLight = HEXRGB(0x06B025);
+			static constexpr COLORREF greenDark = HEXRGB(0x0F7B0F);
+			::SendMessage(hWnd, PBM_SETBARCOLOR, 0, static_cast<LPARAM>(DarkMode::isExperimentalActive() ? greenDark : greenLight));
+		}
+	}
+
+	/**
+	 * @brief Handles text and background colorizing for read-only controls.
+	 *
+	 * Sets the text color and background color on the provided HDC.
+	 * Returns the corresponding background brush for painting.
+	 * Typically used for read-only controls (e.g. edit control and combo box' list box).
+	 * Typically used in response to `WM_CTLCOLORSTATIC` or in `WM_CTLCOLORLISTBOX`
+	 * via @ref DarkMode::onCtlColorListbox
+	 *
+	 * @param hdc Handle to the device context (HDC) receiving the drawing instructions.
+	 * @return Background brush to use for painting, or `FALSE` (0) if classic mode is enabled
+	 *         and `_DARKMODELIB_DLG_PROC_CTLCOLOR_RETURNS` is defined
+	 *         and has non-zero unsigned value.
+	 *
+	 * @see DarkMode::WindowCtlColorSubclass()
+	 * @see DarkMode::onCtlColorListbox()
+	 */
+	LRESULT onCtlColor(HDC hdc)
+	{
+#if defined(_DARKMODELIB_DLG_PROC_CTLCOLOR_RETURNS) && (_DARKMODELIB_DLG_PROC_CTLCOLOR_RETURNS > 0)
+		if (!DarkMode::_isEnabled())
+		{
+			return FALSE;
+		}
+#endif
+		::SetTextColor(hdc, DarkMode::getTextColor());
+		::SetBkColor(hdc, DarkMode::getBackgroundColor());
+		return reinterpret_cast<LRESULT>(DarkMode::getBackgroundBrush());
+	}
+
+	/**
+	 * @brief Handles text and background colorizing for interactive controls.
+	 *
+	 * Sets the text and background colors on the provided HDC.
+	 * Returns the corresponding brush used to paint the background.
+	 * Typically used in response to `WM_CTLCOLOREDIT` and `WM_CTLCOLORLISTBOX`
+	 * via @ref DarkMode::onCtlColorListbox
+	 *
+	 * @param hdc Handle to the device context for the target control.
+	 * @return The background brush, or `FALSE` if dark mode is disabled and
+	 *         `_DARKMODELIB_DLG_PROC_CTLCOLOR_RETURNS` is defined
+	 *         and has non-zero unsigned value.
+	 *
+	 * @see DarkMode::WindowCtlColorSubclass()
+	 * @see DarkMode::onCtlColorListbox()
+	 */
+	LRESULT onCtlColorCtrl(HDC hdc)
+	{
+#if defined(_DARKMODELIB_DLG_PROC_CTLCOLOR_RETURNS) && (_DARKMODELIB_DLG_PROC_CTLCOLOR_RETURNS > 0)
+		if (!DarkMode::_isEnabled())
+		{
+			return FALSE;
+		}
+#endif
+
+		::SetTextColor(hdc, DarkMode::getTextColor());
+		::SetBkColor(hdc, DarkMode::getCtrlBackgroundColor());
+		return reinterpret_cast<LRESULT>(DarkMode::getCtrlBackgroundBrush());
+	}
+
+	/**
+	 * @brief Handles text and background colorizing for window and disabled non-text controls.
+	 *
+	 * Sets the text and background colors on the provided HDC.
+	 * Returns the corresponding brush used to paint the background.
+	 * Typically used in response to `WM_CTLCOLORDLG`, `WM_CTLCOLORSTATIC`
+	 * and `WM_CTLCOLORLISTBOX` via @ref DarkMode::onCtlColorListbox
+	 *
+	 * @param hdc Handle to the device context for the target control.
+	 * @return The background brush, or `FALSE` if dark mode is disabled and
+	 *         `_DARKMODELIB_DLG_PROC_CTLCOLOR_RETURNS` is defined
+	 *         and has non-zero unsigned value.
+	 *
+	 * @see DarkMode::WindowCtlColorSubclass()
+	 * @see DarkMode::onCtlColorListbox()
+	 */
+	LRESULT onCtlColorDlg(HDC hdc)
+	{
+#if defined(_DARKMODELIB_DLG_PROC_CTLCOLOR_RETURNS) && (_DARKMODELIB_DLG_PROC_CTLCOLOR_RETURNS > 0)
+		if (!DarkMode::_isEnabled())
+		{
+			return FALSE;
+		}
+#endif
+
+		::SetTextColor(hdc, DarkMode::getTextColor());
+		::SetBkColor(hdc, DarkMode::getDlgBackgroundColor());
+		return reinterpret_cast<LRESULT>(DarkMode::getDlgBackgroundBrush());
+	}
+
+	/**
+	 * @brief Handles text and background colorizing for error state (for specific usage).
+	 *
+	 * Sets the text and background colors on the provided HDC.
+	 *
+	 * @param hdc Handle to the device context for the target control.
+	 * @return The background brush, or `FALSE` if dark mode is disabled and
+	 *         `_DARKMODELIB_DLG_PROC_CTLCOLOR_RETURNS` is defined
+	 *         and has non-zero unsigned value.
+	 *
+	 * @see DarkMode::WindowCtlColorSubclass()
+	 */
+	LRESULT onCtlColorError(HDC hdc)
+	{
+#if defined(_DARKMODELIB_DLG_PROC_CTLCOLOR_RETURNS) && (_DARKMODELIB_DLG_PROC_CTLCOLOR_RETURNS > 0)
+		if (!DarkMode::_isEnabled())
+		{
+			return FALSE;
+		}
+#endif
+
+		::SetTextColor(hdc, DarkMode::getTextColor());
+		::SetBkColor(hdc, DarkMode::getErrorBackgroundColor());
+		return reinterpret_cast<LRESULT>(DarkMode::getErrorBackgroundBrush());
+	}
+
+	/**
+	 * @brief Handles text and background colorizing for static text controls.
+	 *
+	 * Sets the text and background colors on the provided HDC.
+	 * Colors depend on if control is enabled.
+	 * Returns the corresponding brush used to paint the background.
+	 * Typically used in response to `WM_CTLCOLORSTATIC`.
+	 *
+	 * @param hdc Handle to the device context for the target control.
+	 * @return The background brush, or `FALSE` if dark mode is disabled and
+	 *         `_DARKMODELIB_DLG_PROC_CTLCOLOR_RETURNS` is defined
+	 *         and has non-zero unsigned value.
+	 *
+	 * @see DarkMode::WindowCtlColorSubclass()
+	 */
+	LRESULT onCtlColorDlgStaticText(HDC hdc, bool isTextEnabled)
+	{
+#if defined(_DARKMODELIB_DLG_PROC_CTLCOLOR_RETURNS) && (_DARKMODELIB_DLG_PROC_CTLCOLOR_RETURNS > 0)
+		if (!DarkMode::_isEnabled())
+		{
+			::SetTextColor(hdc, ::GetSysColor(isTextEnabled ? COLOR_WINDOWTEXT : COLOR_GRAYTEXT));
+			return FALSE;
+		}
+#endif
+		::SetTextColor(hdc, isTextEnabled ? DarkMode::getTextColor() : DarkMode::getDisabledTextColor());
+		::SetBkColor(hdc, DarkMode::getDlgBackgroundColor());
+		return reinterpret_cast<LRESULT>(DarkMode::getDlgBackgroundBrush());
+	}
+
+	/**
+	 * @brief Handles text and background colorizing for syslink controls.
+	 *
+	 * Sets the text and background colors on the provided HDC.
+	 * Colors depend on if control is enabled.
+	 * Returns the corresponding brush used to paint the background.
+	 * Typically used in response to `WM_CTLCOLORSTATIC`.
+	 *
+	 * @param hdc Handle to the device context for the target control.
+	 * @return The background brush, or `FALSE` if dark mode is disabled and
+	 *         `_DARKMODELIB_DLG_PROC_CTLCOLOR_RETURNS` is defined
+	 *         and has non-zero unsigned value.
+	 *
+	 * @see DarkMode::WindowCtlColorSubclass()
+	 */
+	LRESULT onCtlColorDlgLinkText(HDC hdc, bool isTextEnabled)
+	{
+#if defined(_DARKMODELIB_DLG_PROC_CTLCOLOR_RETURNS) && (_DARKMODELIB_DLG_PROC_CTLCOLOR_RETURNS > 0)
+		if (!DarkMode::_isEnabled())
+		{
+			::SetTextColor(hdc, ::GetSysColor(isTextEnabled ? COLOR_HOTLIGHT : COLOR_GRAYTEXT));
+			return FALSE;
+		}
+#endif
+		::SetTextColor(hdc, isTextEnabled ? DarkMode::getLinkTextColor() : DarkMode::getDisabledTextColor());
+		::SetBkColor(hdc, DarkMode::getDlgBackgroundColor());
+		return reinterpret_cast<LRESULT>(DarkMode::getDlgBackgroundBrush());
+	}
+
+	/**
+	 * @brief Handles text and background colorizing for list box controls.
+	 *
+	 * Inspects the list box style flags to detect if it's part of a combo box (via `LBS_COMBOBOX`)
+	 * and whether experimental feature is active. Based on the context, delegates to:
+	 * - @ref DarkMode::onCtlColorCtrl for standard enabled listboxes
+	 * - @ref DarkMode::onCtlColorDlg for disabled ones or when dark mode is disabled
+	 * - @ref DarkMode::onCtlColor for combo box' listbox
+	 *
+	 * @param wParam WPARAM from `WM_CTLCOLORLISTBOX`, representing the HDC.
+	 * @param lParam LPARAM from `WM_CTLCOLORLISTBOX`, representing the HWND of the listbox.
+	 * @return The brush handle as LRESULT for background painting, or `FALSE` if not themed.
+	 *
+	 * @see DarkMode::WindowCtlColorSubclass()
+	 * @see DarkMode::onCtlColor()
+	 * @see DarkMode::onCtlColorCtrl()
+	 * @see DarkMode::onCtlColorDlg()
+	 */
+	LRESULT onCtlColorListbox(WPARAM wParam, LPARAM lParam)
+	{
+		auto hdc = reinterpret_cast<HDC>(wParam);
+		auto hWnd = reinterpret_cast<HWND>(lParam);
+
+		const auto nStyle = ::GetWindowLongPtr(hWnd, GWL_STYLE);
+		const bool isComboBox = (nStyle & LBS_COMBOBOX) == LBS_COMBOBOX;
+		if ((!isComboBox || !DarkMode::isExperimentalActive()))
+		{
+			if (::IsWindowEnabled(hWnd) == TRUE)
+			{
+				return DarkMode::onCtlColorCtrl(hdc);
+			}
+			return DarkMode::onCtlColorDlg(hdc);
+		}
+		return DarkMode::onCtlColor(hdc);
+	}
+
+	/**
+	 * @brief Hook procedure for customizing common dialogs with dark mode.
+	 */
+	UINT_PTR CALLBACK HookDlgProc(HWND hWnd, UINT uMsg, [[maybe_unused]] WPARAM wParam, [[maybe_unused]] LPARAM lParam)
+	{
+		if (uMsg == WM_INITDIALOG)
+		{
+			DarkMode::setDarkWndSafe(hWnd);
+			return TRUE;
+		}
+		return FALSE;
+	}
+} // namespace DarkMode
+
+#endif // !defined(_DARKMODELIB_NOT_USED)
diff --git a/DarkMode/src/DarkModeSubclass.h b/DarkMode/src/DarkModeSubclass.h
new file mode 100644
index 000000000..677b50fdb
--- /dev/null
+++ b/DarkMode/src/DarkModeSubclass.h
@@ -0,0 +1,656 @@
+// SPDX-License-Identifier: MPL-2.0
+
+/*
+ * Copyright (c) 2025 ozone10
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at https://mozilla.org/MPL/2.0/.
+ */
+
+// Based on the Notepad++ dark mode code licensed under GPLv3.
+// Originally by adzm / Adam D. Walling, with modifications by the Notepad++ team.
+// Heavily modified by ozone10 (Notepad++ contributor).
+// Used with permission to relicense under the Mozilla Public License, v. 2.0.
+
+
+#pragma once
+
+#include <windows.h>
+
+#if (NTDDI_VERSION >= NTDDI_VISTA) /*\
+	&& (defined(__x86_64__) || defined(_M_X64)\
+	|| defined(__arm64__) || defined(__arm64) || defined(_M_ARM64))*/
+
+#if defined(_MSC_VER)
+#pragma comment(lib, "dwmapi.lib")
+#pragma comment(lib, "uxtheme.lib")
+#pragma comment(lib, "Comctl32.lib")
+#pragma comment(lib, "Gdi32.lib")
+#endif
+
+namespace DarkMode
+{
+	struct Colors
+	{
+		COLORREF background = 0;
+		COLORREF ctrlBackground = 0;
+		COLORREF hotBackground = 0;
+		COLORREF dlgBackground = 0;
+		COLORREF errorBackground = 0;
+		COLORREF text = 0;
+		COLORREF darkerText = 0;
+		COLORREF disabledText = 0;
+		COLORREF linkText = 0;
+		COLORREF edge = 0;
+		COLORREF hotEdge = 0;
+		COLORREF disabledEdge = 0;
+	};
+
+	struct ColorsView
+	{
+		COLORREF background = 0;
+		COLORREF text = 0;
+		COLORREF gridlines = 0;
+		COLORREF headerBackground = 0;
+		COLORREF headerHotBackground = 0;
+		COLORREF headerText = 0;
+		COLORREF headerEdge = 0;
+	};
+
+	// unsigned char == std::uint8_t
+
+	/**
+	 * @brief Represents tooltip from different controls.
+	 */
+	enum class ToolTipsType : unsigned char
+	{
+		tooltip,   ///< Standard tooltip control.
+		toolbar,   ///< Tooltips associated with toolbar buttons.
+		listview,  ///< Tooltips associated with list views.
+		treeview,  ///< Tooltips associated with tree views.
+		tabbar,    ///< Tooltips associated with tab controls.
+		trackbar,  ///< Tooltips associated with trackbar (slider) controls.
+		rebar      ///< Tooltips associated with rebar controls.
+	};
+
+	/**
+	 * @brief Defines dark mode preset color tones.
+	 *
+	 * Used as preset to choose default colors in dark mode.
+	 * Value `max` is reserved for internal range checking,
+	 * do not use in application code.
+	 */
+	enum class ColorTone : unsigned char
+	{
+		black   = 0,  ///< Black
+		red     = 1,  ///< Red
+		green   = 2,  ///< Green
+		blue    = 3,  ///< Blue
+		purple  = 4,  ///< Purple
+		cyan    = 5,  ///< Cyan
+		olive   = 6,  ///< Olive
+		max     = 7   ///< Don't use, for internal checks
+	};
+
+	/**
+	 * @brief Defines the available visual styles for TreeView controls.
+	 *
+	 * Used to control theming behavior for TreeViews:
+	 * - `classic`: Legacy style without theming.
+	 * - `light`: Light mode appearance.
+	 * - `dark`: Dark mode appearance.
+	 *
+	 * Set via configuration and used by style evaluators (e.g. @ref DarkMode::calculateTreeViewStyle).
+	 *
+	 * @see DarkMode::calculateTreeViewStyle()
+	 */
+	enum class TreeViewStyle : unsigned char
+	{
+		classic,  ///< Non-themed legacy appearance.
+		light,    ///< Light mode.
+		dark      ///< Dark mode.
+	};
+
+	/**
+	 * @brief Describes metadata fields and compile-time features of the dark mode library.
+	 *
+	 * Values of this enum are used with @ref DarkMode::getLibInfo to retrieve version numbers and
+	 * determine whether specific features were enabled during compilation.
+	 *
+	 * @see DarkMode::getLibInfo()
+	 */
+	enum class LibInfo : unsigned char
+	{
+		featureCheck,     ///< Returns maxValue to verify enum coverage.
+		verMajor,         ///< Major version number of the library.
+		verMinor,         ///< Minor version number of the library.
+		verRevision,      ///< Revision/patch number of the library.
+		iathookExternal,  ///< Indicates if external IAT hooking is used.
+		iniConfigUsed,    ///< True if `.ini` file configuration is supported.
+		allowOldOS,       ///< '1' if older Windows 10 versions are allowed, '2' if all older Windows are allowed.
+		useDlgProcCtl,    ///< True if WM_CTLCOLORxxx can be handled directly in dialog procedure.
+		preferTheme,      ///< True if theme is supported and can be used over subclass, e.g. combo box on Windows 10+.
+		useSBFix,         ///< '1' if scroll bar fix is applied to all scroll bars, '2' if scroll bar fix can be limited to specific window.
+		maxValue          ///< Sentinel value for internal validation (not intended for use).
+	};
+
+	/**
+	 * @brief Defines the available dark mode types for manual configurations.
+	 *
+	 * Can be used in DarkMode::initDarkModeConfig and in DarkMode::setDarkModeConfig
+	 * with static_cast<UINT>(DarkModeType::'value').
+	 *
+	 * @note Also used internally to distinguish between light, dark, and classic modes.
+	 *
+	 * @see DarkMode::initDarkModeConfig()
+	 * @see DarkMode::setDarkModeConfig()
+	 */
+	enum class DarkModeType : unsigned char
+	{
+		light = 0,  ///< Light mode appearance.
+		dark = 1,   ///< Dark mode appearance.
+		classic = 3 ///< Classic (non-themed or system) appearance.
+	};
+
+	/**
+	 * @brief Returns library version information or compile-time feature flags.
+	 *
+	 * @param libInfoType The type of information to query.
+	 * @return Integer representing the requested value or feature flag.
+	 *
+	 * @see LibInfo
+	 */
+	[[nodiscard]] int getLibInfo(LibInfo libInfoType);
+
+	// ========================================================================
+	// Config
+	// ========================================================================
+
+	/**
+	 * @brief Initializes the dark mode configuration based on the selected mode.
+	 *
+	 * For convenience @ref DarkModeType enums values can be used.
+	 *
+	 * @param dmType Configuration mode:
+	 *        - 0: Light mode
+	 *        - 1: Dark mode
+	 *        - 3: Classic mode
+	 *
+	 * @note Values 2 and 4 are reserved for internal use only.
+	 *       Using them can cause visual glitches.
+	 */
+	void initDarkModeConfig(UINT dmType);
+
+	/// Sets the preferred window corner style on Windows 11. (DWM_WINDOW_CORNER_PREFERENCE values)
+	void setRoundCornerConfig(UINT roundCornerStyle);
+
+	/// Sets the preferred border color for window edge on Windows 11.
+	void setBorderColorConfig(COLORREF clr);
+
+	// Sets the Mica effects on Windows 11 setting. (DWM_SYSTEMBACKDROP_TYPE values)
+	void setMicaConfig(UINT mica);
+
+	/// Sets Mica effects on the full window setting.
+	void setMicaExtendedConfig(bool extendMica);
+
+	/// Sets dialog colors on title bar on Windows 11 setting.
+	void setColorizeTitleBarConfig(bool colorize);
+
+	/// Applies dark mode settings based on the given configuration type. (DarkModeType values)
+	void setDarkModeConfig(UINT dmType);
+
+	/// Applies dark mode settings based on system mode preference.
+	void setDarkModeConfig();
+
+	/// Initializes dark mode experimental features, colors, and other settings.
+	void initDarkMode(const wchar_t* iniName);
+
+	///Initializes dark mode without INI settings.
+	void initDarkMode();
+
+	// ========================================================================
+	// Basic checks
+	// ========================================================================
+
+	/// Checks if non-classic mode is enabled.
+	[[nodiscard]] bool isEnabled();
+
+	/// Checks if experimental dark mode features are currently active.
+	[[nodiscard]] bool isExperimentalActive();
+
+	/// Checks if experimental dark mode features are supported by the system.
+	[[nodiscard]] bool isExperimentalSupported();
+
+	/// Checks if follow the system mode behavior is enabled.
+	[[nodiscard]] bool isWindowsModeEnabled();
+
+	/// Checks if the host OS is at least Windows 10.
+	[[nodiscard]] bool isAtLeastWindows10();
+
+	/// Checks if the host OS is at least Windows 11.
+	[[nodiscard]] bool isAtLeastWindows11();
+
+	/// Retrieves the current Windows build number.
+	[[nodiscard]] DWORD getWindowsBuildNumber();
+
+	// ========================================================================
+	// System Events
+	// ========================================================================
+
+	/// Handles system setting changes related to dark mode.
+	bool handleSettingChange(LPARAM lParam);
+
+	/// Checks if dark mode is enabled in the Windows registry.
+	[[nodiscard]] bool isDarkModeReg();
+
+	// ========================================================================
+	// From DarkMode.h
+	// ========================================================================
+
+	/**
+	 * @brief Overrides a specific system color with a custom color.
+	 *
+	 * Currently supports:
+	 * - `COLOR_WINDOW`: Background of ComboBoxEx list.
+	 * - `COLOR_WINDOWTEXT`: Text color of ComboBoxEx list.
+	 * - `COLOR_BTNFACE`: Gridline color in ListView (when applicable).
+	 *
+	 * @param nIndex One of the supported system color indices.
+	 * @param color Custom `COLORREF` value to apply.
+	 */
+	void setSysColor(int nIndex, COLORREF color);
+
+	// ========================================================================
+	// Enhancements to DarkMode.h
+	// ========================================================================
+
+	/// Makes scroll bars on the specified window and all its children consistent.
+	void enableDarkScrollBarForWindowAndChildren(HWND hWnd);
+
+	// ========================================================================
+	// Colors
+	// ========================================================================
+
+	/// Sets the color tone and its color set for the active theme.
+	void setColorTone(ColorTone colorTone);
+
+	/// Retrieves the currently active color tone for the theme.
+	[[nodiscard]] ColorTone getColorTone();
+
+	COLORREF setBackgroundColor(COLORREF clrNew);
+	COLORREF setCtrlBackgroundColor(COLORREF clrNew);
+	COLORREF setHotBackgroundColor(COLORREF clrNew);
+	COLORREF setDlgBackgroundColor(COLORREF clrNew);
+	COLORREF setErrorBackgroundColor(COLORREF clrNew);
+
+	COLORREF setTextColor(COLORREF clrNew);
+	COLORREF setDarkerTextColor(COLORREF clrNew);
+	COLORREF setDisabledTextColor(COLORREF clrNew);
+	COLORREF setLinkTextColor(COLORREF clrNew);
+
+	COLORREF setEdgeColor(COLORREF clrNew);
+	COLORREF setHotEdgeColor(COLORREF clrNew);
+	COLORREF setDisabledEdgeColor(COLORREF clrNew);
+
+	void setThemeColors(Colors colors);
+	void updateThemeBrushesAndPens();
+
+	[[nodiscard]] COLORREF getBackgroundColor();
+	[[nodiscard]] COLORREF getCtrlBackgroundColor();
+	[[nodiscard]] COLORREF getHotBackgroundColor();
+	[[nodiscard]] COLORREF getDlgBackgroundColor();
+	[[nodiscard]] COLORREF getErrorBackgroundColor();
+
+	[[nodiscard]] COLORREF getTextColor();
+	[[nodiscard]] COLORREF getDarkerTextColor();
+	[[nodiscard]] COLORREF getDisabledTextColor();
+	[[nodiscard]] COLORREF getLinkTextColor();
+
+	[[nodiscard]] COLORREF getEdgeColor();
+	[[nodiscard]] COLORREF getHotEdgeColor();
+	[[nodiscard]] COLORREF getDisabledEdgeColor();
+
+	[[nodiscard]] HBRUSH getBackgroundBrush();
+	[[nodiscard]] HBRUSH getDlgBackgroundBrush();
+	[[nodiscard]] HBRUSH getCtrlBackgroundBrush();
+	[[nodiscard]] HBRUSH getHotBackgroundBrush();
+	[[nodiscard]] HBRUSH getErrorBackgroundBrush();
+
+	[[nodiscard]] HBRUSH getEdgeBrush();
+	[[nodiscard]] HBRUSH getHotEdgeBrush();
+	[[nodiscard]] HBRUSH getDisabledEdgeBrush();
+
+	[[nodiscard]] HPEN getDarkerTextPen();
+	[[nodiscard]] HPEN getEdgePen();
+	[[nodiscard]] HPEN getHotEdgePen();
+	[[nodiscard]] HPEN getDisabledEdgePen();
+
+	COLORREF setViewBackgroundColor(COLORREF clrNew);
+	COLORREF setViewTextColor(COLORREF clrNew);
+	COLORREF setViewGridlinesColor(COLORREF clrNew);
+
+	COLORREF setHeaderBackgroundColor(COLORREF clrNew);
+	COLORREF setHeaderHotBackgroundColor(COLORREF clrNew);
+	COLORREF setHeaderTextColor(COLORREF clrNew);
+	COLORREF setHeaderEdgeColor(COLORREF clrNew);
+
+	void setViewColors(ColorsView colors);
+	void updateViewBrushesAndPens();
+
+	[[nodiscard]] COLORREF getViewBackgroundColor();
+	[[nodiscard]] COLORREF getViewTextColor();
+	[[nodiscard]] COLORREF getViewGridlinesColor();
+
+	[[nodiscard]] COLORREF getHeaderBackgroundColor();
+	[[nodiscard]] COLORREF getHeaderHotBackgroundColor();
+	[[nodiscard]] COLORREF getHeaderTextColor();
+	[[nodiscard]] COLORREF getHeaderEdgeColor();
+
+	[[nodiscard]] HBRUSH getViewBackgroundBrush();
+	[[nodiscard]] HBRUSH getViewGridlinesBrush();
+
+	[[nodiscard]] HBRUSH getHeaderBackgroundBrush();
+	[[nodiscard]] HBRUSH getHeaderHotBackgroundBrush();
+
+	[[nodiscard]] HPEN getHeaderEdgePen();
+
+	/// Initializes default color set based on the current mode type.
+	void setDefaultColors(bool updateBrushesAndOther);
+
+	// ========================================================================
+	// Paint Helpers
+	// ========================================================================
+
+	/// Paints a rounded rectangle using the specified pen and brush.
+	void paintRoundRect(HDC hdc, const RECT& rect, HPEN hpen, HBRUSH hBrush, int width = 0, int height = 0);
+	/// Paints an unfilled rounded rectangle (frame only).
+	void paintRoundFrameRect(HDC hdc, const RECT& rect, HPEN hpen, int width = 0, int height = 0);
+
+	// ========================================================================
+	// Control Subclassing
+	// ========================================================================
+
+	/// Applies themed owner drawn subclassing to a checkbox, radio, or tri-state button control.
+	void setCheckboxOrRadioBtnCtrlSubclass(HWND hWnd);
+	/// Removes the owner drawn subclass from a a checkbox, radio, or tri-state button control.
+	void removeCheckboxOrRadioBtnCtrlSubclass(HWND hWnd);
+
+	/// Applies owner drawn subclassing to a groupbox button control.
+	void setGroupboxCtrlSubclass(HWND hWnd);
+	/// Removes the owner drawn subclass from a groupbox button control.
+	void removeGroupboxCtrlSubclass(HWND hWnd);
+
+	/// Applies owner drawn subclassing and theming to an updown (spinner) control.
+	void setUpDownCtrlSubclass(HWND hWnd);
+	/// Removes the owner drawn subclass from a updown (spinner) control.
+	void removeUpDownCtrlSubclass(HWND hWnd);
+
+	void setTabCtrlUpDownSubclass(HWND hWnd);
+	void removeTabCtrlUpDownSubclass(HWND hWnd);
+	void setTabCtrlSubclass(HWND hWnd);
+	void removeTabCtrlSubclass(HWND hWnd);
+
+	void setCustomBorderForListBoxOrEditCtrlSubclass(HWND hWnd);
+	void removeCustomBorderForListBoxOrEditCtrlSubclass(HWND hWnd);
+
+	void setComboBoxCtrlSubclass(HWND hWnd);
+	void removeComboBoxCtrlSubclass(HWND hWnd);
+
+	void setComboBoxExCtrlSubclass(HWND hWnd);
+	void removeComboBoxExCtrlSubclass(HWND hWnd);
+
+	void setListViewCtrlSubclass(HWND hWnd);
+	void removeListViewCtrlSubclass(HWND hWnd);
+
+	void setHeaderCtrlSubclass(HWND hWnd);
+	void removeHeaderCtrlSubclass(HWND hWnd);
+
+	void setStatusBarCtrlSubclass(HWND hWnd);
+	void removeStatusBarCtrlSubclass(HWND hWnd);
+
+	void setProgressBarCtrlSubclass(HWND hWnd);
+	void removeProgressBarCtrlSubclass(HWND hWnd);
+
+	void setStaticTextCtrlSubclass(HWND hWnd);
+	void removeStaticTextCtrlSubclass(HWND hWnd);
+
+	// ========================================================================
+	// Child Subclassing
+	// ========================================================================
+
+	void setChildCtrlsSubclassAndTheme(HWND hParent, bool subclass = true, bool theme = true);
+	void setChildCtrlsTheme(HWND hParent);
+
+	// ========================================================================
+	// Window, Parent, And Other Subclassing
+	// ========================================================================
+
+	/// Applies window subclassing to handle `WM_ERASEBKGND` message.
+	void setWindowEraseBgSubclass(HWND hWnd);
+	/// Removes the subclass used for `WM_ERASEBKGND` message handling.
+	void removeWindowEraseBgSubclass(HWND hWnd);
+
+	/// Applies window subclassing to handle `WM_CTLCOLOR*` messages.
+	void setWindowCtlColorSubclass(HWND hWnd);
+	/// Removes the subclass used for `WM_CTLCOLOR*` messages handling.
+	void removeWindowCtlColorSubclass(HWND hWnd);
+
+	/// Applies window subclassing for handling `NM_CUSTOMDRAW` notifications for custom drawing.
+	void setWindowNotifyCustomDrawSubclass(HWND hWnd);
+	/// Removes the subclass used for handling `NM_CUSTOMDRAW` notifications for custom drawing.
+	void removeWindowNotifyCustomDrawSubclass(HWND hWnd);
+
+	/// Applies window subclassing for menu bar themed custom drawing.
+	void setWindowMenuBarSubclass(HWND hWnd);
+	/// Removes the subclass used for menu bar themed custom drawing.
+	void removeWindowMenuBarSubclass(HWND hWnd);
+
+	/// Applies window subclassing to handle `WM_SETTINGCHANGE` message.
+	void setWindowSettingChangeSubclass(HWND hWnd);
+	/// Removes the subclass used for `WM_SETTINGCHANGE` message handling.
+	void removeWindowSettingChangeSubclass(HWND hWnd);
+
+	// ========================================================================
+	// Theme And Helpers
+	// ========================================================================
+
+	/// Configures the SysLink control to be affected by `WM_CTLCOLORSTATIC` message.
+	void enableSysLinkCtrlCtlColor(HWND hWnd);
+
+	/// Sets dark title bar and optional Windows 11 features.
+	void setDarkTitleBarEx(HWND hWnd, bool useWin11Features);
+	/// Sets dark mode title bar on supported Windows versions.
+	void setDarkTitleBar(HWND hWnd);
+
+	/// Applies an experimental visual style to the specified window, if supported.
+	void setDarkThemeExperimental(HWND hWnd, const wchar_t* themeClassName = L"Explorer");
+	/// Applies "DarkMode_Explorer" visual style if experimental mode is active.
+	void setDarkExplorerTheme(HWND hWnd);
+	/// Applies "DarkMode_Explorer" visual style to scroll bars.
+	void setDarkScrollBar(HWND hWnd);
+	/// Applies "DarkMode_Explorer" visual style to tooltip controls based on context.
+	void setDarkTooltips(HWND hWnd, ToolTipsType type = ToolTipsType::tooltip);
+
+	/// Sets the color of line above a toolbar control for non-classic mode.
+	void setDarkLineAbovePanelToolbar(HWND hWnd);
+	/// Applies an experimental Explorer visual style to a list view.
+	void setDarkListView(HWND hWnd);
+	/// Replaces default list view checkboxes with themed dark-mode versions on Windows 11.
+	void setDarkListViewCheckboxes(HWND hWnd);
+	/// Sets colors and edges for a RichEdit control.
+	void setDarkRichEdit(HWND hWnd);
+
+	/// Applies visual styles; ctl color message and child controls subclassings to a window safely.
+	void setDarkWndSafe(HWND hWnd, bool useWin11Features = true);
+	/// Applies visual styles; ctl color message, child controls, custom drawing, and setting change subclassings to a window safely.
+	void setDarkWndNotifySafeEx(HWND hWnd, bool setSettingChangeSubclass, bool useWin11Features);
+	/// Applies visual styles; ctl color message, child controls, and custom drawing subclassings to a window safely.
+	void setDarkWndNotifySafe(HWND hWnd, bool useWin11Features = true);
+
+	/// Enables or disables theme-based dialog background textures in classic mode.
+	void enableThemeDialogTexture(HWND hWnd, bool theme);
+
+	/// Enables or disables visual styles for a window.
+	void disableVisualStyle(HWND hWnd, bool doDisable);
+
+	/// Calculates perceptual lightness of a COLORREF color.
+	[[nodiscard]] double calculatePerceivedLightness(COLORREF clr);
+
+	/// Retrieves the current TreeView style configuration.
+	[[nodiscard]] const TreeViewStyle& getTreeViewStyle();
+
+	/// Determines appropriate TreeView style based on background perceived lightness.
+	void calculateTreeViewStyle();
+
+	/// Applies the appropriate window theme style to the specified TreeView.
+	void setTreeViewWindowTheme(HWND hWnd, bool force = false);
+
+	/// Retrieves the previous TreeView style configuration.
+	[[nodiscard]] const TreeViewStyle& getPrevTreeViewStyle();
+
+	/// Stores the current TreeView style as the previous style for later comparison.
+	void setPrevTreeViewStyle();
+
+	/// Checks whether the current theme is dark.
+	[[nodiscard]] bool isThemeDark();
+
+	/// Checks whether the color is dark.
+	[[nodiscard]] bool isColorDark(COLORREF clr);
+
+	/// Forces a window to redraw its non-client frame.
+	void redrawWindowFrame(HWND hWnd);
+	/// Sets a window's standard style flags and redraws window if needed.
+	void setWindowStyle(HWND hWnd, bool setStyle, LONG_PTR styleFlag);
+	/// Sets a window's extended style flags and redraws window if needed.
+	void setWindowExStyle(HWND hWnd, bool setExStyle, LONG_PTR exStyleFlag);
+	/// Replaces an extended edge (e.g. client edge) with a standard window border.
+	void replaceExEdgeWithBorder(HWND hWnd, bool replace, LONG_PTR exStyleFlag);
+	/// Safely toggles `WS_EX_CLIENTEDGE` with `WS_BORDER` based on dark mode state.
+	void replaceClientEdgeWithBorderSafe(HWND hWnd);
+
+	/// Applies classic-themed styling to a progress bar in non-classic mode.
+	void setProgressBarClassicTheme(HWND hWnd);
+
+	// ========================================================================
+	// Ctl Color
+	// ========================================================================
+
+	/// Handles text and background colorizing for read-only controls.
+	[[nodiscard]] LRESULT onCtlColor(HDC hdc);
+
+	/// Handles text and background colorizing for interactive controls.
+	[[nodiscard]] LRESULT onCtlColorCtrl(HDC hdc);
+
+	/// Handles text and background colorizing for window and disabled non-text controls.
+	[[nodiscard]] LRESULT onCtlColorDlg(HDC hdc);
+
+	/// Handles text and background colorizing for error state (for specific usage).
+	[[nodiscard]] LRESULT onCtlColorError(HDC hdc);
+
+	/// Handles text and background colorizing for static text controls.
+	[[nodiscard]] LRESULT onCtlColorDlgStaticText(HDC hdc, bool isTextEnabled);
+
+	/// Handles text and background colorizing for syslink controls.
+	[[nodiscard]] LRESULT onCtlColorDlgLinkText(HDC hdc, bool isTextEnabled = true);
+
+	/// Handles text and background colorizing for list box controls.
+	[[nodiscard]] LRESULT onCtlColorListbox(WPARAM wParam, LPARAM lParam);
+
+	// ========================================================================
+	// Hook Callback Dialog Procedure
+	// ========================================================================
+
+	/**
+	 * @brief Hook procedure for customizing common dialogs with dark mode.
+	 *
+	 * This function handles messages for all Windows common dialogs.
+	 * When initialized (`WM_INITDIALOG`), it applies dark mode styling to the dialog.
+	 *
+	 * ## Special Case: Font Dialog Workaround
+	 * - When a hook is used with `ChooseFont`, Windows **automatically falls back**
+	 *   to an **older template**, losing modern UI elements.
+	 * - To prevent this forced downgrade, a **modified template** (based on Font.dlg) is used.
+	 * - **CBS_OWNERDRAWFIXED should be removed** from the **Size** and **Script** combo boxes
+	 *   to restore proper visualization.
+	 * - **Custom owner-draw visuals remain** for other font combo boxes to allow font preview.
+	 * - Same for the `"AaBbYyZz"` sample text.
+	 * - However **Automatic system translation for captions and static texts is lost** in this workaround.
+	 *
+	 * ## Custom Font Dialog Template (Resource File)
+	 * ```rc
+	 * IDD_DARK_FONT_DIALOG DIALOG 13, 54, 243, 234
+	 * STYLE DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU |
+	 *       DS_3DLOOK
+	 * CAPTION "Font"
+	 * FONT 9, "Segoe UI"
+	 * BEGIN
+	 *     LTEXT           "&Font:", stc1, 7, 7, 98, 9
+	 *     COMBOBOX        cmb1, 7, 16, 98, 76,
+	 *                     CBS_SIMPLE | CBS_AUTOHSCROLL | CBS_DISABLENOSCROLL |
+	 *                     CBS_SORT | WS_VSCROLL | WS_TABSTOP | CBS_HASSTRINGS |
+	 *                     CBS_OWNERDRAWFIXED
+	 *
+	 *     LTEXT           "Font st&yle:", stc2, 114, 7, 74, 9
+	 *     COMBOBOX        cmb2, 114, 16, 74, 76,
+	 *                     CBS_SIMPLE | CBS_AUTOHSCROLL | CBS_DISABLENOSCROLL |
+	 *                     WS_VSCROLL | WS_TABSTOP | CBS_HASSTRINGS |
+	 *                     CBS_OWNERDRAWFIXED
+	 *
+	 *     LTEXT           "&Size:", stc3, 198, 7, 36, 9
+	 *     COMBOBOX        cmb3, 198, 16, 36, 76,
+	 *                     CBS_SIMPLE | CBS_AUTOHSCROLL | CBS_DISABLENOSCROLL |
+	 *                     CBS_SORT | WS_VSCROLL | WS_TABSTOP | CBS_HASSTRINGS |
+	 *                     CBS_OWNERDRAWFIXED // remove CBS_OWNERDRAWFIXED
+	 *
+	 *     GROUPBOX        "Effects", grp1, 7, 97, 98, 76, WS_GROUP
+	 *     AUTOCHECKBOX    "Stri&keout", chx1, 13, 111, 90, 10, WS_TABSTOP
+	 *     AUTOCHECKBOX    "&Underline", chx2, 13, 127, 90, 10
+	 *
+	 *     LTEXT           "&Color:", stc4, 13, 144, 89, 9
+	 *     COMBOBOX        cmb4, 13, 155, 85, 100,
+	 *                     CBS_DROPDOWNLIST | CBS_OWNERDRAWFIXED | CBS_AUTOHSCROLL |
+	 *                     CBS_HASSTRINGS | WS_BORDER | WS_VSCROLL | WS_TABSTOP
+	 *
+	 *     GROUPBOX        "Sample", grp2, 114, 97, 120, 43, WS_GROUP
+	 *     CTEXT           "AaBbYyZz", stc5, 116, 106, 117, 33,
+	 *                     SS_NOPREFIX | NOT WS_VISIBLE
+	 *     LTEXT           "", stc6, 7, 178, 227, 20, SS_NOPREFIX | NOT WS_GROUP
+	 *
+	 *     LTEXT           "Sc&ript:", stc7, 114, 145, 118, 9
+	 *     COMBOBOX        cmb5, 114, 155, 120, 30, CBS_DROPDOWNLIST |
+	 *                     CBS_OWNERDRAWFIXED | CBS_AUTOHSCROLL | CBS_HASSTRINGS | // remove CBS_OWNERDRAWFIXED
+	 *                     WS_BORDER | WS_VSCROLL | WS_TABSTOP
+	 *
+	 *     CONTROL         "<A>Show more fonts</A>", IDC_MANAGE_LINK, "SysLink",
+	 *                     WS_TABSTOP, 7, 199, 227, 9
+	 *
+	 *     DEFPUSHBUTTON   "OK", IDOK, 141, 215, 45, 14, WS_GROUP
+	 *     PUSHBUTTON      "Cancel", IDCANCEL, 190, 215, 45, 14, WS_GROUP
+	 *     PUSHBUTTON      "&Apply", psh3, 92, 215, 45, 14, WS_GROUP
+	 *     PUSHBUTTON      "&Help", pshHelp, 43, 215, 45, 14, WS_GROUP
+	 * END
+	 * ```
+	 *
+	 * ## Usage Example:
+	 * ```cpp
+	 * #define IDD_DARK_FONT_DIALOG 1000 // usually in resource.h or other header
+	 *
+	 * CHOOSEFONT cf{};
+	 * cf.Flags |= CF_ENABLEHOOK | CF_ENABLETEMPLATE;
+	 * cf.lpfnHook = static_cast<LPCFHOOKPROC>(DarkMode::HookDlgProc);
+	 * cf.hInstance = GetModuleHandle(nullptr);
+	 * cf.lpTemplateName = MAKEINTRESOURCE(IDD_DARK_FONT_DIALOG);
+	 * ```
+	 *
+	 * @param hWnd Handle to the dialog window.
+	 * @param uMsg Message identifier.
+	 * @param wParam First message parameter (unused).
+	 * @param lParam Second message parameter (unused).
+	 * @return A value defined by the hook procedure.
+	 */
+	UINT_PTR CALLBACK HookDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
+} // namespace DarkMode
+
+#else
+#define _DARKMODELIB_NOT_USED
+#endif // (NTDDI_VERSION >= NTDDI_VISTA) //&& (x64 or arm64)
diff --git a/DarkMode/src/IatHook.h b/DarkMode/src/IatHook.h
new file mode 100644
index 000000000..f400b07b8
--- /dev/null
+++ b/DarkMode/src/IatHook.h
@@ -0,0 +1,112 @@
+// SPDX-License-Identifier: MIT
+
+// This file is a modified version of IatHook.h from the win32-darkmode project
+// https://github.com/ysc3839/win32-darkmode
+
+// This file contains code from
+// https://github.com/stevemk14ebr/PolyHook_2_0/blob/master/sources/IatHook.cpp
+// which is licensed under the MIT License.
+// See LICENSE-PolyHook_2_0 for more information.
+
+#pragma once
+
+#include <windows.h>
+
+#include <cstdint>
+
+template <typename T, typename T1, typename T2>
+inline constexpr T RVA2VA(T1 base, T2 rva)
+{
+	return reinterpret_cast<T>(reinterpret_cast<ULONG_PTR>(base) + rva);
+}
+
+template <typename T>
+inline constexpr T DataDirectoryFromModuleBase(void* moduleBase, size_t entryID)
+{
+	const auto* dosHdr = static_cast<PIMAGE_DOS_HEADER>(moduleBase);
+	const auto* ntHdr = RVA2VA<PIMAGE_NT_HEADERS>(moduleBase, static_cast<DWORD>(dosHdr->e_lfanew));
+	const auto* dataDir = ntHdr->OptionalHeader.DataDirectory;
+	return RVA2VA<T>(moduleBase, dataDir[entryID].VirtualAddress);
+}
+
+inline PIMAGE_THUNK_DATA FindAddressByName(void* moduleBase, PIMAGE_THUNK_DATA impName, PIMAGE_THUNK_DATA impAddr, const char* funcName)
+{
+	for (; impName->u1.Ordinal != 0; ++impName, ++impAddr)
+	{
+		if (IMAGE_SNAP_BY_ORDINAL(impName->u1.Ordinal))
+		{
+			continue;
+		}
+
+		const auto* import = RVA2VA<PIMAGE_IMPORT_BY_NAME>(moduleBase, impName->u1.AddressOfData);
+		if (strcmp(reinterpret_cast<const char*>(import->Name), funcName) != 0)
+		{
+			continue;
+		}
+		return impAddr;
+	}
+	return nullptr;
+}
+
+inline PIMAGE_THUNK_DATA FindAddressByOrdinal(void* /*moduleBase*/, PIMAGE_THUNK_DATA impName, PIMAGE_THUNK_DATA impAddr, uint16_t ordinal)
+{
+	for (; impName->u1.Ordinal != 0; ++impName, ++impAddr)
+	{
+		if (IMAGE_SNAP_BY_ORDINAL(impName->u1.Ordinal) && IMAGE_ORDINAL(impName->u1.Ordinal) == ordinal)
+		{
+			return impAddr;
+		}
+	}
+	return nullptr;
+}
+
+inline PIMAGE_THUNK_DATA FindIatThunkInModule(void* moduleBase, const char* dllName, const char* funcName)
+{
+	auto* imports = DataDirectoryFromModuleBase<PIMAGE_IMPORT_DESCRIPTOR>(moduleBase, IMAGE_DIRECTORY_ENTRY_IMPORT);
+	for (; imports->Name != 0; ++imports)
+	{
+		if (_stricmp(RVA2VA<LPCSTR>(moduleBase, imports->Name), dllName) != 0)
+		{
+			continue;
+		}
+
+		auto* origThunk = RVA2VA<PIMAGE_THUNK_DATA>(moduleBase, imports->OriginalFirstThunk);
+		auto* thunk = RVA2VA<PIMAGE_THUNK_DATA>(moduleBase, imports->FirstThunk);
+		return FindAddressByName(moduleBase, origThunk, thunk, funcName);
+	}
+	return nullptr;
+}
+
+inline PIMAGE_THUNK_DATA FindDelayLoadThunkInModule(void* moduleBase, const char* dllName, const char* funcName)
+{
+	auto* imports = DataDirectoryFromModuleBase<PIMAGE_DELAYLOAD_DESCRIPTOR>(moduleBase, IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT);
+	for (; imports->DllNameRVA != 0; ++imports)
+	{
+		if (_stricmp(RVA2VA<LPCSTR>(moduleBase, imports->DllNameRVA), dllName) != 0)
+		{
+			continue;
+		}
+
+		auto* impName = RVA2VA<PIMAGE_THUNK_DATA>(moduleBase, imports->ImportNameTableRVA);
+		auto* impAddr = RVA2VA<PIMAGE_THUNK_DATA>(moduleBase, imports->ImportAddressTableRVA);
+		return FindAddressByName(moduleBase, impName, impAddr, funcName);
+	}
+	return nullptr;
+}
+
+inline PIMAGE_THUNK_DATA FindDelayLoadThunkInModule(void* moduleBase, const char* dllName, uint16_t ordinal)
+{
+	auto* imports = DataDirectoryFromModuleBase<PIMAGE_DELAYLOAD_DESCRIPTOR>(moduleBase, IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT);
+	for (; imports->DllNameRVA != 0; ++imports)
+	{
+		if (_stricmp(RVA2VA<LPCSTR>(moduleBase, imports->DllNameRVA), dllName) != 0)
+		{
+			continue;
+		}
+
+		auto* impName = RVA2VA<PIMAGE_THUNK_DATA>(moduleBase, imports->ImportNameTableRVA);
+		auto* impAddr = RVA2VA<PIMAGE_THUNK_DATA>(moduleBase, imports->ImportAddressTableRVA);
+		return FindAddressByOrdinal(moduleBase, impName, impAddr, ordinal);
+	}
+	return nullptr;
+}
diff --git a/DarkMode/src/StdAfx.h b/DarkMode/src/StdAfx.h
new file mode 100644
index 000000000..92af2f1d4
--- /dev/null
+++ b/DarkMode/src/StdAfx.h
@@ -0,0 +1 @@
+// StdAfx.h
diff --git a/DarkMode/src/UAHMenuBar.h b/DarkMode/src/UAHMenuBar.h
new file mode 100644
index 000000000..a6c653619
--- /dev/null
+++ b/DarkMode/src/UAHMenuBar.h
@@ -0,0 +1,78 @@
+// SPDX-License-Identifier: MIT
+
+// Copyright (c) 2021 adzm / Adam D. Walling
+// MIT license, see LICENSE-UAHMenuBar
+
+#pragma once
+#include <windows.h>
+
+// processes messages related to UAH / custom menubar drawing.
+// return true if handled, false to continue with normal processing in your wndproc
+//bool UAHDarkModeWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam, LRESULT* lr);
+
+// window messages related to menu bar drawing
+#define WM_UAHDESTROYWINDOW    0x0090 // handled by DefWindowProc
+#define WM_UAHDRAWMENU         0x0091 // lParam is UAHMENU
+#define WM_UAHDRAWMENUITEM     0x0092 // lParam is UAHDRAWMENUITEM
+#define WM_UAHINITMENU         0x0093 // handled by DefWindowProc
+#define WM_UAHMEASUREMENUITEM  0x0094 // lParam is UAHMEASUREMENUITEM
+#define WM_UAHNCPAINTMENUPOPUP 0x0095 // handled by DefWindowProc
+
+// describes the sizes of the menu bar or menu item
+typedef union tagUAHMENUITEMMETRICS
+{
+	// cx appears to be 14 / 0xE less than rcItem's width!
+	// cy 0x14 seems stable, i wonder if it is 4 less than rcItem's height which is always 24 atm
+	struct
+	{
+		DWORD cx;
+		DWORD cy;
+	} rgsizeBar[2];
+	struct
+	{
+		DWORD cx;
+		DWORD cy;
+	} rgsizePopup[4];
+} UAHMENUITEMMETRICS;
+
+// not really used in our case but part of the other structures
+typedef struct tagUAHMENUPOPUPMETRICS
+{
+	DWORD rgcx[4];
+	DWORD fUpdateMaxWidths : 2; // from kernel symbols, padded to full dword
+} UAHMENUPOPUPMETRICS;
+
+// hmenu is the main window menu; hdc is the context to draw in
+typedef struct tagUAHMENU
+{
+	HMENU hmenu;
+	HDC hdc;
+	DWORD dwFlags; // no idea what these mean, in my testing it's either 0x00000a00 or sometimes 0x00000a10
+} UAHMENU;
+
+// menu items are always referred to by iPosition here
+typedef struct tagUAHMENUITEM
+{
+	int iPosition; // 0-based position of menu item in menubar
+	UAHMENUITEMMETRICS umim;
+	UAHMENUPOPUPMETRICS umpm;
+} UAHMENUITEM;
+
+// the DRAWITEMSTRUCT contains the states of the menu items, as well as
+// the position index of the item in the menu, which is duplicated in
+// the UAHMENUITEM's iPosition as well
+typedef struct UAHDRAWMENUITEM
+{
+	DRAWITEMSTRUCT dis; // itemID looks uninitialized
+	UAHMENU um;
+	UAHMENUITEM umi;
+} UAHDRAWMENUITEM;
+
+// the MEASUREITEMSTRUCT is intended to be filled with the size of the item
+// height appears to be ignored, but width can be modified
+typedef struct tagUAHMEASUREMENUITEM
+{
+	MEASUREITEMSTRUCT mis;
+	UAHMENU um;
+	UAHMENUITEM umi;
+} UAHMEASUREMENUITEM;
diff --git a/DarkMode/src/Version.h b/DarkMode/src/Version.h
new file mode 100644
index 000000000..0f1f481e2
--- /dev/null
+++ b/DarkMode/src/Version.h
@@ -0,0 +1,16 @@
+// SPDX-License-Identifier: MPL-2.0
+
+/*
+ * Copyright (c) 2025 ozone10
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at https://mozilla.org/MPL/2.0/.
+ */
+
+
+#define DM_VERSION_MAJOR    0
+#define DM_VERSION_MINOR    12
+#define DM_VERSION_REVISION 0
+
+#define DM_VERSION   "Dark mode v0.12.0"
+#define DM_COPYRIGHT "Copyright (c) 2024-2025 ozone10"
diff --git a/LICENSE.md b/LICENSE.md
new file mode 100644
index 000000000..68c1b0194
--- /dev/null
+++ b/LICENSE.md
@@ -0,0 +1,39 @@
+## License
+The license for use and distribution is the same as that of the 7-Zip ZS fork. For more information check `COPYING` file.  
+Additionally, code in `DarkMode` folder is from [darkmodelib](https://github.com/ozone10/darkmodelib) which is licensed under the MIT License or the Mozilla Public License, version 2.0.  
+
+## Dark mode source code (darkmodelib)
+
+Copyright (c) 2024-2025 ozone10
+
+Mozilla Public License Version 2.0
+--------------------
+
+    Copyright (c) 2025 ozone10
+    This Source Code Form is subject to the terms of the Mozilla Public
+    License, v. 2.0. If a copy of the MPL was not distributed with this
+    file, You can obtain one at https://mozilla.org/MPL/2.0/.
+
+MIT License
+--------------------
+
+    Copyright (c) 2024-2025 ozone10
+
+    Permission is hereby granted, free of charge, to any person obtaining a copy
+    of this software and associated documentation files (the "Software"), to deal
+    in the Software without restriction, including without limitation the rights
+    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+    copies of the Software, and to permit persons to whom the Software is
+    furnished to do so, subject to the following conditions:
+
+    The above copyright notice and this permission notice shall be included in all
+    copies or substantial portions of the Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+    SOFTWARE.
+
diff --git a/README.md b/README.md
index 8cb21505b..14aa18825 100644
--- a/README.md
+++ b/README.md
@@ -1,3 +1,232 @@
+# Dark7zip
+
+[![7z](https://img.shields.io/badge/7z-DarkMode-black.svg?&logo=7zip)](https://github.com/ozone10/7zip-Dark7zip)
+[![Build status](https://img.shields.io/github/actions/workflow/status/ozone10/7zip-Dark7zip/build_win.yml?logo=Github)](https://github.com/ozone10/7zip-Dark7zip/actions)
+[![Latest release](https://img.shields.io/github/v/release/ozone10/7zip-Dark7zip?include_prereleases)](https://github.com/ozone10/7zip-Dark7zip/releases/latest)
+[![Total downloads](https://img.shields.io/github/downloads/ozone10/7zip-Dark7zip/total.svg)](https://github.com/ozone10/7zip-Dark7zip/releases)
+[![License](https://img.shields.io/badge/License-7--Zip-black?logo=data:image/svg%2bxml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0IiBmaWxsPSIjRkZGRkZGIj48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xMi43NSAyLjc1YS43NS43NSAwIDAwLTEuNSAwVjQuNUg5LjI3NmExLjc1IDEuNzUgMCAwMC0uOTg1LjMwM0w2LjU5NiA1Ljk1N0EuMjUuMjUgMCAwMTYuNDU1IDZIMi4zNTNhLjc1Ljc1IDAgMTAwIDEuNUgzLjkzTC41NjMgMTUuMThhLjc2Mi43NjIgMCAwMC4yMS44OGMuMDguMDY0LjE2MS4xMjUuMzA5LjIyMS4xODYuMTIxLjQ1Mi4yNzguNzkyLjQzMy42OC4zMTEgMS42NjIuNjIgMi44NzYuNjJhNi45MTkgNi45MTkgMCAwMDIuODc2LS42MmMuMzQtLjE1NS42MDYtLjMxMi43OTItLjQzMy4xNS0uMDk3LjIzLS4xNTguMzEtLjIyM2EuNzUuNzUgMCAwMC4yMDktLjg3OEw1LjU2OSA3LjVoLjg4NmMuMzUxIDAgLjY5NC0uMTA2Ljk4NC0uMzAzbDEuNjk2LTEuMTU0QS4yNS4yNSAwIDAxOS4yNzUgNmgxLjk3NXYxNC41SDYuNzYzYS43NS43NSAwIDAwMCAxLjVoMTAuNDc0YS43NS43NSAwIDAwMC0xLjVIMTIuNzVWNmgxLjk3NGMuMDUgMCAuMS4wMTUuMTQuMDQzbDEuNjk3IDEuMTU0Yy4yOS4xOTcuNjMzLjMwMy45ODQuMzAzaC44ODZsLTMuMzY4IDcuNjhhLjc1Ljc1IDAgMDAuMjMuODk2Yy4wMTIuMDA5IDAgMCAuMDAyIDBhMy4xNTQgMy4xNTQgMCAwMC4zMS4yMDZjLjE4NS4xMTIuNDUuMjU2Ljc5LjRhNy4zNDMgNy4zNDMgMCAwMDIuODU1LjU2OCA3LjM0MyA3LjM0MyAwIDAwMi44NTYtLjU2OWMuMzM4LS4xNDMuNjA0LS4yODcuNzktLjM5OWEzLjUgMy41IDAgMDAuMzEtLjIwNi43NS43NSAwIDAwLjIzLS44OTZMMjAuMDcgNy41aDEuNTc4YS43NS43NSAwIDAwMC0xLjVoLTQuMTAyYS4yNS4yNSAwIDAxLS4xNC0uMDQzbC0xLjY5Ny0xLjE1NGExLjc1IDEuNzUgMCAwMC0uOTg0LS4zMDNIMTIuNzVWMi43NXpNMi4xOTMgMTUuMTk4YTUuNDE4IDUuNDE4IDAgMDAyLjU1Ny42MzUgNS40MTggNS40MTggMCAwMDIuNTU3LS42MzVMNC43NSA5LjM2OGwtMi41NTcgNS44M3ptMTQuNTEtLjAyNGMuMDgyLjA0LjE3NC4wODMuMjc1LjEyNi41My4yMjMgMS4zMDUuNDUgMi4yNzIuNDVhNS44NDYgNS44NDYgMCAwMDIuNTQ3LS41NzZMMTkuMjUgOS4zNjdsLTIuNTQ3IDUuODA3eiI+PC9wYXRoPjwvc3ZnPg==
+)](LICENSE.md)
+[![PayPal.me](https://img.shields.io/badge/PayPal-me-00457C?&logo=paypal&logoColor=white&maxAge=2592000)](https://paypal.me/ozone10/)
+[![ko-fi.com](https://img.shields.io/badge/Ko--fi-Buy_Me_a_Tea-F16061?logo=ko-fi&logoColor=white&maxAge=2592000)](https://ko-fi.com/ozone10/)
+---
+
+Dark7zip is project to experiment with dark mode via [darkmodelib](https://github.com/ozone10/darkmodelib) library for [7-Zip](https://github.com/ip7z/7zip) and its fork [7-Zip-zstd](#7-zip-zstd).  
+It is mainly for Windows 10 and Windows 11. Some controls might, might not use dark/custom colors on older OS.
+
+* * *
+
+<p align="center">
+  <img src="https://i.imgur.com/pghAZEA.png">
+</p>
+
+<details>
+  <summary>Gallery</summary>
+
+  <p align="center">
+    <img src="https://i.imgur.com/cnYZPAE.png">
+  </p>
+
+  <p align="center">
+    <img src="https://i.imgur.com/6tNDlFM.png">
+  </p>
+
+  <p align="center">
+    <img src="https://i.imgur.com/Ddc4z7O.png">
+  </p>
+
+  <p align="center">
+    <img src="https://i.imgur.com/6a4lu9U.png">
+  </p>
+</details>
+
+* * *
+
+## Installation
+
+Replace 7z original files (e.g. `C:\Program Files\7-Zip\`) with files from downloaded zip file.  
+
+- `7zFM.exe` - file manager, "main exe"
+- `7zG.exe` - mainly extraction, compression dialogs
+- `7z.sfx`- optional, file needed for creating self-extracting archives
+- `7zDark.ini` - optional, more information below
+
+> [!IMPORTANT]  
+> Ensure that you have downloaded the correct version. If the zip file name contains "zstd" (e.g. `7z-zstd-v24.09-v1.5.7-R1-dark-x64.zip`), it is intended for the zstd fork. If you are using the wrong version, a message box titled "7‑Zip ZS" will appear when attempting to extract the archive.
+
+> [!NOTE]  
+> Currently files are released only for x64 platform. You can get files for other platform from Github Actions for original 7-Zip, 7-Zip-zstd has only x64 platform. Ensure that you get correct version - [main](https://github.com/ozone10/7zip-Dark7zip/actions?query=branch%3Amain) for original 7-Zip, [7z-zstd](https://github.com/ozone10/7zip-Dark7zip/actions?query=branch%3A7z-zstd) for 7-Zip-zstd.
+
+## Config
+
+`7zDark.ini` is configuration file to allow mainly to set custom colors.
+`7zDark.ini` should be in same folder as `7zFM.exe` and `7zG.exe`.
+
+- [main]
+  - mode - determine which sections color "key=value" pairs will be used and theming of title bar, buttons, scrollbars, and tooltips
+      - 0 - use light mode
+      - 1 - use dark mode, default value in system with dark mode enabled
+      - 2 - follow system settings, use light mode in system with light mode enabled
+      - 3 - use classic style, default value in system with light mode enabled, disable almost every custom GUI styles and colors
+      - 4 - follow system settings, use classic style in system with light mode enabled
+
+- [dark]
+  - tone - set default colors for [dark.colors] sections, there are no tones for light mode
+    - 0 - black, default value
+    - 1 - red
+    - 2 - green
+    - 3 - blue
+    - 4 - purple
+    - 5 - cyan
+    - 6 - olive
+  - micaExtend - apply Mica material on all window/dialog, experimental, only for "dark" mode
+    - 0 - apply Mica material only on title bar, default value
+    - 1 - extend Mica material on all window/dialog
+
+> [!IMPORTANT]  
+> `micaExtend=1` is only used with `[main]` `mode=1` and with `mica` with other valid values than `0`.
+> `micaExtend=1` should also be used with HDR and ACM (Auto Color Management) off.
+> Due to Windows bug using `micaExtend=1` can cause visual glitches, with HDR/ACM visual glitches are more severe (e.g. invisible controls).  
+> It is also recommended when using with `mica=1` to turn off Settings -> Personalization > Colors -> "Show accent color on title bars and window borders" setting.
+
+- [dark]/[light]
+  - roundCorner - on Windows 11 specifies rounded corners preference
+    - 0 - let the system decide when to round window corners, default value
+    - 1 - never round window corners
+    - 2 - round the corners, if appropriate
+    - 3 - round the corners if appropriate, with a small radius
+  - borderColor - on Windows 11 specifies the color of the window border, color is in RGB hex format - RRGGBB
+    - FFFFFF - use default system color, special value, default value
+  - mica - apply Mica material on title bar, requires Windows 11 22H2 build 22621
+    - 0 - let OS automatically decide the use of Mica material, default value
+    - 1 - do not use Mica material
+    - 2 - apply Mica material
+    - 3 - apply "acrylic" effect
+    - 4 - apply Mica Alt material
+  - colorizeTitleBar - on Windows 11 applies same colors as dialog background and static text on title bar, with `micaExtend=1` this option will be ignored
+    - 0 - Use system colors (default)
+    - 1 - Use custom colors (backgroundDlg and text)
+
+Values for custom colors are in RGB hex format - RRGGBB.
+
+- [dark.colors]/[light.colors]
+  - background - for some controls (status bar, ...)
+  - backgroundCtrl - mainly for controls with some input 
+  - backgroundHot - for hot item
+  - backgroundDlg - for dialog and some controls
+  - text - for most text
+  - textItem - for some controls
+  - textDisabled - for disabled controls
+  - edge - for border
+  - edgeHot - for hot border
+  - edgeDisabled - for disabled border
+
+- [dark.colors.view]/[light.colors.view] - for listview and treeview
+  - backgroundView
+  - textView
+  - gridlines - color for listview grid lines, when View -> Details is used and Tools -> Options... -> Settings tab -> Show grid lines is checked
+  - backgroundHeader
+  - backgroundHotHeader
+  - textHeader
+  - edgeHeader
+
+All options are optional. You can define only "[section]" and "key=value" you want to be applied.  
+
+> [!TIP]  
+> Renaming section will disable all "key=value" pairs of that section and default values will be used.
+
+Examples:
+- full config
+```ini
+[main]
+mode = 1
+
+[dark]
+tone = 0
+roundCorner = 0
+borderColor = "FFFFFF"
+mica = 0
+micaExtend = 0
+colorizeTitleBar = 0
+
+[dark.colors]
+background =            "202020"
+backgroundCtrl =        "383838"
+backgroundHot =         "454545"
+backgroundDlg =         "202020"
+text =                  "E0E0E0"
+textItem =              "C0C0C0"
+textDisabled =          "808080"
+edge =                  "646464"
+edgeHot =               "9B9B9B"
+edgeDisabled =          "484848"
+
+[dark.colors.view]
+backgroundView =        "3F3F3F"
+textView =              "DCDCDC"
+gridlines =             "646464"
+backgroundHeader =      "202020"
+backgroundHotHeader =   "454545"
+textHeader =            "C0C0C0"
+edgeHeader =            "646464"
+
+[light]
+roundCorner = 0
+borderColor = "FFFFFF"
+mica = 0
+colorizeTitleBar = 0
+
+[light.colors]
+background =            "F0F0F0"
+backgroundCtrl =        "FFFFFF"
+backgroundHot =         "C0DCF3"
+backgroundDlg =         "F0F0F0"
+text =                  "000000"
+textItem =              "000000"
+textDisabled =          "6D6D6D"
+edge =                  "8D8D8D"
+edgeHot =               "0078D4"
+edgeDisabled =          "6D6D6D"
+
+[light.colors.view]
+backgroundView =        "FFFFFF"
+textView =              "000000"
+gridlines =             "F0F0F0"
+backgroundHeader =      "FFFFFF"
+backgroundHotHeader =   "D9EBF9"
+textHeader =            "000000"
+edgeHeader =            "E5E5E5"
+```
+
+- only views, with defaults: `[main]` `mode=1`, and `[dark]` `tone=0`
+```ini
+[dark.colors.view]
+backgroundView =        "112435"
+textView =              "C3BE98"
+gridlines =             "4F5F5F"
+```
+
+## 7-Zip-zstd
+
+7-Zip-zstd is popular 7-Zip fork which contains additional compression algorithms such as Zstandard and Brotli.
+Source code for dark mode for it is in [7z-zstd](https://github.com/ozone10/7zip-Dark7zip/tree/7z-zstd) branch.
+
+For more information about 7-Zip-zstd fork check [7-Zip-zstd](https://github.com/mcmilk/7-Zip-zstd).
+
+## License
+The license for use and distribution is the same as that of the 7-Zip ZS fork.  
+Additionally, code related to dark mode in `DarkMode` folder is licensed under the MIT License or the Mozilla Public License, version 2.0.  
+[MPL-2.0](DarkMode\LICENSE.md)  
+[MIT](DarkMode\LICENSE-MIT.md)
+
+For details on the 7-Zip ZS license, see the `DOC` folder and `COPYING` file.  
+[License.txt](DOC/License.txt)  
+[readme.txt](DOC/readme.txt)  
+[COPYING](COPYING)
+
+## 7-Zip ZS README
+
+<details>
+  <summary>7-Zip ZS README</summary>
 
 # README
 
@@ -315,3 +544,5 @@ You find this project useful, maybe you consider a donation ;-)
 [Fast LZMA2]:https://github.com/conor42/fast-lzma2
 [Codecs.7z]:https://github.com/mcmilk/7-Zip-zstd/releases
 [TotalCmd.7z]:https://github.com/mcmilk/7-Zip-zstd/releases
+
+</details>
diff --git a/build.cmd b/build.cmd
new file mode 100644
index 000000000..c40fdddae
--- /dev/null
+++ b/build.cmd
@@ -0,0 +1,45 @@
+@echo off
+
+cd /d "%~dp0"
+
+for /f "usebackq tokens=*" %%i in (`"%ProgramFiles(x86)%\Microsoft Visual Studio\Installer\vswhere.exe" -latest -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 -property installationPath`) do (
+  set InstallDir=%%i
+)
+
+setlocal
+
+set PLATFORM=%1
+
+if "%PLATFORM%" == "" (
+  set ARCH=x64
+  set PLATFORM=x64
+)
+if "%PLATFORM%" == "x64" set ARCH=x64
+if "%PLATFORM%" == "x86" set ARCH=x64_x86
+if "%PLATFORM%" == "arm64" set ARCH=x64_arm64
+
+if exist "%InstallDir%\VC\Auxiliary\Build\vcvarsall.bat" (
+  call "%InstallDir%\VC\Auxiliary\Build\vcvarsall.bat" %ARCH%
+
+  pushd CPP\7zip\UI\FileManager
+  nmake
+  popd
+
+  pushd CPP\7zip\UI\GUI
+  nmake
+  popd
+
+  pushd CPP\7zip\Bundles\SFXWin
+  nmake
+  popd
+
+  if not exist "%PLATFORM%-bin\" mkdir "%PLATFORM%-bin"
+  copy "CPP\7zip\Bundles\SFXWin\%PLATFORM%\7z.sfx" "%PLATFORM%-bin"
+  copy "CPP\7zip\UI\FileManager\%PLATFORM%\7zFM.exe" "%PLATFORM%-bin"
+  copy "CPP\7zip\UI\GUI\%PLATFORM%\7zG.exe" "%PLATFORM%-bin"
+  copy "DarkMode\7zRes\7zDark.ini" "%PLATFORM%-bin"
+  copy "COPYING" "%PLATFORM%-bin"
+  copy "LICENSE.md" "%PLATFORM%-bin"
+)
+
+endlocal
